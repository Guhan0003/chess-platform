
===== chess-platform/combine.py =====
import os

# Set your base project directory
base_directory = r'C:\Users\guhan\chess-platform'  # Change this to your project root

# Set output file
output_file_path = 'Combined_chess-platform.txt'

# File types you want to include (extend as needed)
include_extensions = [
    '.py', '.html', '.css', '.js', '.ts', '.json',
    '.env', '.txt', '.md', '.yml', '.yaml'
]

# Optional folders to exclude (e.g., static/media/migrations/venv)
exclude_dirs = {'__pycache__', 'static', 'media', 'migrations', 'venv', '.venv', '.git', 'node_modules'}

with open(output_file_path, 'w', encoding='utf-8') as output_file:
    for root, dirs, files in os.walk(base_directory):
        # Exclude unwanted folders
        dirs[:] = [d for d in dirs if d not in exclude_dirs]
        
        for filename in files:
            filepath = os.path.join(root, filename)
            if any(filename.endswith(ext) for ext in include_extensions):
                relative_path = os.path.relpath(filepath, base_directory)
                # Format path to start from chess-platform
                clean_path = f"chess-platform/{relative_path.replace(os.sep, '/')}"
                output_file.write(f"\n===== {clean_path} =====\n")
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        output_file.write(f.read())
                except Exception as e:
                    output_file.write(f"[Error reading file: {e}]\n")

===== chess-platform/Combined_chess-platform.txt =====

===== chess-platform/manage.py =====
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'chess_backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

===== chess-platform/PROJECT_DOCUMENTATION.md =====
# 🏆 Chess Platform - Professional Project Documentation

## 📋 **Project Overview**

**Chess Platform** is a comprehensive, full-stack web application that provides a complete chess gaming experience similar to platforms like Chess.com or Lichess. The project features a modern, professional architecture with a Django REST API backend and a sophisticated vanilla JavaScript frontend.

### 🎯 **Project Vision**
Create a production-ready chess platform that supports:
- Real-time multiplayer chess games
- Professional user management and authentication
- Advanced chess features (ratings, statistics, puzzles)
- Modern, responsive web interface
- Scalable architecture for future enhancements

---

## 🏗️ **Technical Architecture**

### **Backend Stack**
- **Framework**: Django 5.1.1 with Django REST Framework
- **Database**: PostgreSQL (production-ready)
- **Authentication**: JWT tokens (djangorestframework-simplejwt)
- **Chess Engine**: python-chess library for game logic
- **Image Processing**: Pillow for avatar handling

### **Frontend Stack**
- **Core**: Vanilla JavaScript (ES6+) - No frameworks for maximum performance
- **Styling**: Custom CSS with modern design system
- **Architecture**: SPA-like experience with custom router
- **API Communication**: Professional ChessAPI class with token management

### **Development Tools**
- **Package Management**: pip (Python) 
- **Database**: psycopg2-binary for PostgreSQL connection
- **Environment**: python-dotenv for configuration
- **CORS**: django-cors-headers for frontend-backend communication

---

## 📦 **Dependencies & Installation**

### **Python Dependencies** (`requirements.txt`)
```pip
Django==5.1.1                      # Web framework
djangorestframework==3.15.2        # REST API framework
djangorestframework-simplejwt==5.3.0 # JWT authentication
django-cors-headers==4.3.1         # CORS handling
python-chess==1.999                # Chess game logic & validation
psycopg2-binary==2.9.7            # PostgreSQL database adapter
python-dotenv==1.0.0               # Environment variable management
setuptools>=75.0.0                 # Package management
```

### **Installation Commands**
```bash
# Create virtual environment
python -m venv .venv
.venv\Scripts\activate  # Windows
source .venv/bin/activate  # Linux/Mac

# Install dependencies
pip install -r requirements.txt

# Database setup
python manage.py makemigrations
python manage.py migrate
python manage.py createsuperuser

# Run development server
python manage.py runserver
```

---

## 📁 **Detailed File Structure**

```
chess-platform/
├── 📂 Backend (Django)
│   ├── 📁 accounts/                 # User management & authentication
│   │   ├── models.py               # CustomUser with chess ratings & stats
│   │   ├── views.py                # Auth endpoints (login, register, profile)
│   │   ├── serializers.py          # API serialization
│   │   ├── urls.py                 # Auth routing
│   │   └── admin.py                # Django admin configuration
│   │
│   ├── 📁 games/                    # Chess game management
│   │   ├── models.py               # Game, Move, TimeControl models
│   │   ├── views.py                # Game API endpoints
│   │   ├── serializers.py          # Game data serialization
│   │   ├── urls.py                 # Game routing
│   │   └── admin.py                # Game admin interface
│   │
│   ├── 📁 chess_backend/            # Django project configuration
│   │   ├── settings.py             # Database, CORS, JWT configuration
│   │   ├── urls.py                 # Main URL routing
│   │   ├── wsgi.py                 # WSGI configuration
│   │   └── asgi.py                 # ASGI configuration
│   │
│   └── manage.py                   # Django management script
│
├── 📂 Frontend (Vanilla JavaScript)
│   ├── 📁 src/                     # Source code organization
│   │   ├── 📁 components/          # Reusable UI components
│   │   │   ├── chess-board/        # Chess board implementation
│   │   │   ├── game-timer/         # Game timer functionality
│   │   │   └── sidebar/            # Sidebar navigation
│   │   │
│   │   ├── 📁 pages/               # Application pages
│   │   │   ├── auth/               # Login & register pages
│   │   │   ├── dashboard/          # Lobby & main dashboard
│   │   │   ├── game/               # Game interface
│   │   │   ├── profile/            # User profile pages
│   │   │   └── puzzles/            # Chess puzzle system
│   │   │
│   │   ├── 📁 styles/              # Global styling
│   │   │   └── global.css          # Design system & variables
│   │   │
│   │   └── 📁 utils/               # Utility modules
│   │       ├── api.js              # ChessAPI class for backend communication
│   │       └── router.js           # SPA routing system
│   │
│   ├── 📁 assets/                  # Static assets
│   │   ├── Chess piece images (PNG files)
│   │   └── favicon.jpeg
│   │
│   ├── index.html                  # Development/testing interface
│   ├── app.js                      # Main application entry
│   ├── script.js                   # Core game logic
│   └── style.css                   # Main stylesheet
│
├── 📁 engine/                      # Chess engine (if needed)
│   └── engine.py                   # Custom chess logic
│
├── 📁 deployment/                  # Deployment configurations
├── 📁 docs/                       # Documentation
├── 📁 mobile/                     # Mobile app (future)
│
├── 📄 Configuration Files
│   ├── requirements.txt            # Python dependencies
│   ├── db.sqlite3                 # SQLite database (development)
│   ├── combine.py                 # Codebase combination script
│   └── Combined_chess-platform.txt # Combined codebase file
│
└── 📄 Documentation
    ├── README.md                   # Project overview
    ├── IMPLEMENTATION_SUMMARY.md   # Feature completion status
    └── PROJECT_DOCUMENTATION.md   # This file
```

---

## 🗄️ **Database Schema**

### **User Management (`accounts` app)**

#### **CustomUser Model**
```python
class CustomUser(AbstractUser):
    # Profile Information
    email = EmailField(unique=True)
    bio = TextField(max_length=500)
    country = CharField(max_length=2)
    avatar = ImageField(upload_to='avatars/')
    
    # Chess Ratings (ELO system)
    blitz_rating = IntegerField(default=1200)     # < 5 minutes
    rapid_rating = IntegerField(default=1200)     # 10-60 minutes
    classical_rating = IntegerField(default=1200) # > 60 minutes
    
    # Peak Ratings (achievements)
    blitz_peak = IntegerField(default=1200)
    rapid_peak = IntegerField(default=1200)
    classical_peak = IntegerField(default=1200)
    
    # Game Statistics
    total_games = IntegerField(default=0)
    games_won = IntegerField(default=0)
    games_drawn = IntegerField(default=0)
    games_lost = IntegerField(default=0)
    
    # Time Control Stats
    blitz_games = IntegerField(default=0)
    rapid_games = IntegerField(default=0)
    classical_games = IntegerField(default=0)
    
    # User Engagement
    current_win_streak = IntegerField(default=0)
    best_win_streak = IntegerField(default=0)
    puzzles_solved = IntegerField(default=0)
    
    # Account Status
    is_online = BooleanField(default=False)
    last_activity = DateTimeField(auto_now=True)
    preferred_time_control = CharField(max_length=10, default='rapid')
    
    # Privacy Settings
    profile_public = BooleanField(default=True)
    show_rating = BooleanField(default=True)
```

#### **Supporting Models**
- **RatingHistory**: Track rating changes over time
- **Achievement**: Define unlockable achievements
- **UserAchievement**: Track user progress
- **UserSettings**: Game preferences and UI settings

### **Game Management (`games` app)**

#### **Game Model**
```python
class Game(models.Model):
    # Players
    white_player = ForeignKey(CustomUser, related_name='games_as_white')
    black_player = ForeignKey(CustomUser, related_name='games_as_black')
    
    # Game State
    fen = CharField(max_length=200, default=chess.STARTING_FEN)
    status = CharField(choices=['waiting', 'active', 'finished', 'aborted'])
    result = CharField(choices=['1-0', '0-1', '1/2-1/2', '*'])
    termination = CharField(choices=['checkmate', 'resignation', 'timeout', ...])
    winner = ForeignKey(CustomUser, null=True, related_name='won_games')
    
    # Time Controls
    time_control = ForeignKey(TimeControl)
    white_time_left = IntegerField(default=600)  # seconds
    black_time_left = IntegerField(default=600)
    increment = IntegerField(default=0)
    
    # Metadata
    created_at = DateTimeField(auto_now_add=True)
    started_at = DateTimeField(null=True)
    finished_at = DateTimeField(null=True)
    last_move_at = DateTimeField(null=True)
```

#### **Move Model**
```python
class Move(models.Model):
    game = ForeignKey(Game, related_name='moves')
    player = ForeignKey(CustomUser)
    move_number = IntegerField()
    
    # Move Details
    from_square = CharField(max_length=5)
    to_square = CharField(max_length=5)
    notation = CharField(max_length=20)  # Standard Algebraic Notation
    fen_after_move = CharField(max_length=200)
    
    # Timing
    time_taken = IntegerField(default=0)
    time_left = IntegerField(default=600)
    created_at = DateTimeField(auto_now_add=True)
    
    # Move Metadata
    captured_piece = CharField(max_length=2, null=True)
    is_check = BooleanField(default=False)
    is_checkmate = BooleanField(default=False)
    is_castling = BooleanField(default=False)
    is_en_passant = BooleanField(default=False)
```

#### **TimeControl Model**
```python
class TimeControl(models.Model):
    name = CharField(max_length=50)        # "Blitz 5+3"
    base_time = IntegerField()             # seconds
    increment = IntegerField(default=0)    # bonus per move
    category = CharField(choices=['blitz', 'rapid', 'classical'])
```

---

## 🔌 **API Endpoints**

### **Authentication Endpoints** (`/api/auth/`)
```http
POST /api/auth/register/     # User registration
POST /api/auth/login/        # User login (returns JWT tokens)
POST /api/auth/refresh/      # Refresh access token
POST /api/auth/logout/       # Logout (invalidate tokens)
GET  /api/auth/profile/      # Get current user profile
```

### **Game Endpoints** (`/api/games/`)
```http
GET  /api/games/             # List all games
POST /api/games/create/      # Create new game
GET  /api/games/{id}/        # Get game details
POST /api/games/{id}/join/   # Join game as black player
POST /api/games/{id}/move/   # Make a move in game
```

### **Request/Response Examples**

#### **User Login**
```javascript
// Request
POST /api/auth/login/
{
  "username": "player1",
  "password": "password123"
}

// Response
{
  "access": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "refresh": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "user": {
    "id": 1,
    "username": "player1",
    "email": "player1@email.com",
    "rapid_rating": 1350,
    "total_games": 45
  }
}
```

#### **Make Move**
```javascript
// Request
POST /api/games/1/move/
{
  "from_square": "e2",
  "to_square": "e4",
  "notation": "e4"
}

// Response
{
  "success": true,
  "move": {
    "notation": "e4",
    "fen_after_move": "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1"
  },
  "game_status": "active"
}
```

---

## 🎨 **Frontend Architecture**

### **Component System**
The frontend uses a modular component-based architecture without frameworks:

#### **ChessAPI Class** (`src/utils/api.js`)
```javascript
class ChessAPI {
  constructor(baseURL = 'http://localhost:8000/api') {
    this.baseURL = baseURL;
    this.accessToken = localStorage.getItem('accessToken');
    this.refreshToken = localStorage.getItem('refreshToken');
  }
  
  // JWT Token Management
  setTokens(accessToken, refreshToken) { ... }
  clearTokens() { ... }
  isAuthenticated() { ... }
  
  // Automatic Token Refresh
  async refreshAccessToken() { ... }
  
  // API Request Wrapper
  async request(endpoint, options = {}) { ... }
  
  // Authentication Methods
  async login(username, password) { ... }
  async register(userData) { ... }
  async getUserProfile() { ... }
  
  // Game Methods
  async getGames() { ... }
  async createGame() { ... }
  async joinGame(gameId) { ... }
  async makeMove(gameId, moveData) { ... }
}
```

#### **Router System** (`src/utils/router.js`)
```javascript
class Router {
  constructor() {
    this.routes = {};
    this.currentRoute = null;
  }
  
  addRoute(path, config) { ... }
  navigate(path) { ... }
  init() { ... }
}
```

### **Page Structure**

#### **Lobby Page** (`src/pages/dashboard/lobby.html`)
- **User Profile Section**: Avatar, username, rating, statistics
- **Quick Actions**: Create game, join game, puzzles
- **Active Games List**: Real-time game browser
- **Statistics Dashboard**: Win rate, recent games, rating changes

#### **Game Page** (`src/pages/game/play.html`)
- **Player Information**: Names, ratings, avatars, timers
- **Interactive Chess Board**: Drag & drop, move validation, animations
- **Game Controls**: Resign, offer draw, flip board, analysis
- **Move History**: Complete game notation with navigation
- **Game Chat**: Real-time communication (future feature)

#### **Authentication Pages** (`src/pages/auth/`)
- **Modern Design**: Glass-morphism styling with chess themes
- **Form Validation**: Client-side and server-side validation
- **Error Handling**: User-friendly error messages
- **Responsive Layout**: Mobile-optimized design

### **Styling System** (`src/styles/global.css`)
```css
:root {
  /* Color Palette */
  --color-bg-primary: #0b0f17;
  --color-bg-secondary: #0f1419;
  --color-accent-primary: #60a5fa;
  --color-accent-secondary: #34d399;
  
  /* Typography */
  --font-family-primary: 'Inter', sans-serif;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  
  /* Spacing */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  
  /* Effects */
  --glass-bg: rgba(255, 255, 255, 0.05);
  --glass-border: rgba(255, 255, 255, 0.1);
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.1);
}
```

---

## ✅ **Implementation Status**

### **🟢 Completed Features**

#### **🔐 Authentication System**
- ✅ JWT token-based authentication
- ✅ User registration and login
- ✅ Automatic token refresh
- ✅ Protected route middleware
- ✅ User profile management

#### **👤 User Management**
- ✅ Custom User model with chess ratings
- ✅ Profile pages with statistics
- ✅ Avatar upload and processing
- ✅ Rating system (Blitz, Rapid, Classical)
- ✅ Game statistics tracking

#### **🎮 Game System**
- ✅ Game creation and joining
- ✅ Move validation using python-chess
- ✅ Real-time game state management
- ✅ FEN notation for board positions
- ✅ Move history tracking
- ✅ Multiple time control support

#### **🎨 Frontend Interface**
- ✅ Modern, responsive design
- ✅ Professional lobby interface
- ✅ Interactive chess board
- ✅ SPA-like navigation
- ✅ Real-time API communication

#### **🗄️ Database Integration**
- ✅ PostgreSQL production database
- ✅ Complex model relationships
- ✅ Data persistence and retrieval
- ✅ Database indexing for performance

### **🟡 Partially Implemented**

#### **⏱️ Real-time Features**
- 🟡 Game timers (backend ready, frontend partial)
- 🟡 Live move updates (API ready, WebSocket needed)
- 🟡 Online player status

#### **🧩 Advanced Features**
- 🟡 Chess puzzles (UI created, logic needed)
- 🟡 Game analysis
- 🟡 Rating calculations (basic implementation)

### **🔴 Planned Features**

#### **🚀 High Priority**
- 🔴 **WebSocket Integration**: Real-time move updates
- 🔴 **Game Timers**: Complete timer implementation
- 🔴 **Player Matching**: Automatic opponent matching
- 🔴 **Rating System**: ELO rating calculations
- 🔴 **Game Analysis**: Move analysis and suggestions

#### **📈 Medium Priority**
- 🔴 **Chess Puzzles**: Tactical training system
- 🔴 **Tournament System**: Organized competitions
- 🔴 **Social Features**: Friends, chat, challenges
- 🔴 **Mobile App**: React Native implementation
- 🔴 **Admin Dashboard**: Game monitoring and user management

#### **🔮 Future Enhancements**
- 🔴 **AI Integration**: Computer opponents
- 🔴 **Streaming**: Game spectating
- 🔴 **Analytics**: Advanced statistics
- 🔴 **Internationalization**: Multi-language support
- 🔴 **Performance**: Caching and optimization

---

## 🛠️ **Development Guidelines**

### **Code Quality Standards**
1. **Python (Django)**
   - Follow PEP 8 style guidelines
   - Use type hints where applicable
   - Comprehensive docstrings for all functions
   - Unit tests for all models and views

2. **JavaScript**
   - Use ES6+ features consistently
   - Modular architecture with clear separation
   - JSDoc comments for all functions
   - Error handling for all API calls

3. **CSS**
   - BEM naming convention
   - CSS custom properties for theming
   - Mobile-first responsive design
   - Performance-optimized animations

### **Git Workflow**
```bash
# Feature development
git checkout -b feature/game-timers
git commit -m "feat: implement real-time game timers"
git push origin feature/game-timers

# Bug fixes
git checkout -b fix/authentication-token-refresh
git commit -m "fix: resolve token refresh infinite loop"
```

### **Testing Strategy**
1. **Backend Tests**
   - Model tests for data integrity
   - API endpoint tests
   - Authentication flow tests
   - Chess move validation tests

2. **Frontend Tests**
   - Component functionality tests
   - API communication tests
   - User interaction tests
   - Cross-browser compatibility

---

## 🚀 **Deployment Architecture**

### **Production Stack**
```
Frontend (Static Files)
├── Nginx (Reverse Proxy)
├── CDN (Static Assets)
└── SSL Certificates

Backend (Django API)
├── Gunicorn (WSGI Server)
├── Nginx (Load Balancer)
├── PostgreSQL (Database)
├── Redis (Caching/Sessions)
└── Celery (Background Tasks)

Infrastructure
├── Docker Containers
├── Docker Compose (Development)
├── Kubernetes (Production)
└── AWS/DigitalOcean (Hosting)
```

### **Environment Configuration**
```python
# settings.py (Production)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST'),
        'PORT': os.environ.get('DB_PORT'),
    }
}

# Security Settings
SECRET_KEY = os.environ.get('SECRET_KEY')
DEBUG = False
ALLOWED_HOSTS = ['yourdomain.com', 'api.yourdomain.com']

# CORS Configuration
CORS_ALLOWED_ORIGINS = [
    "https://yourdomain.com",
    "https://www.yourdomain.com",
]
```

---

## 📊 **Performance Considerations**

### **Database Optimization**
1. **Indexing Strategy**
   - User ratings for quick leaderboards
   - Game status for active game queries
   - Player relationships for game history

2. **Query Optimization**
   - Use select_related() for foreign keys
   - Implement pagination for large datasets
   - Cache frequently accessed data

### **Frontend Performance**
1. **Asset Optimization**
   - Minimize CSS and JavaScript
   - Optimize chess piece images
   - Implement lazy loading

2. **API Efficiency**
   - Implement request caching
   - Use pagination for game lists
   - Minimize API calls with strategic data fetching

---

## 🔒 **Security Measures**

### **Authentication Security**
- JWT tokens with short expiration times
- Secure token storage in httpOnly cookies (future)
- CSRF protection for state-changing operations
- Rate limiting on authentication endpoints

### **Data Protection**
- SQL injection prevention through ORM
- XSS protection through proper escaping
- File upload validation for avatars
- User input sanitization

### **API Security**
- CORS configuration for allowed origins
- Request rate limiting
- API endpoint authentication
- Sensitive data exclusion from responses

---

## 📈 **Scalability Plan**

### **Phase 1: MVP (Current)**
- Single server deployment
- PostgreSQL database
- Basic feature set

### **Phase 2: Growth**
- Load balancer implementation
- Database read replicas
- CDN for static assets
- Redis caching layer

### **Phase 3: Scale**
- Microservices architecture
- WebSocket servers for real-time features
- Database sharding
- Container orchestration

---

## 🎯 **Success Metrics**

### **Technical Metrics**
- API response time < 200ms
- Database query efficiency
- Frontend load time < 2 seconds
- 99.9% uptime

### **User Metrics**
- User registration rate
- Game completion rate
- Daily active users
- Average session duration

---

## 📞 **Project Contact & Contribution**

### **Repository Information**
- **GitHub**: Guhan0003/chess-platform
- **Branch**: main
- **License**: [Specify License]

### **Development Setup**
```bash
# Clone repository
git clone https://github.com/Guhan0003/chess-platform.git
cd chess-platform

# Backend setup
python -m venv .venv
source .venv/bin/activate  # or .venv\Scripts\activate on Windows
pip install -r requirements.txt
python manage.py migrate
python manage.py runserver

# Frontend setup
# Open frontend/index.html in browser or use live server
```

### **Contributing Guidelines**
1. Fork the repository
2. Create feature branch
3. Follow code quality standards
4. Write comprehensive tests
5. Submit pull request with detailed description

---

**Last Updated**: September 12, 2025  
**Version**: 1.0.0  
**Status**: Active Development  

---

*This documentation represents a comprehensive overview of the Chess Platform project. For technical questions or contributions, please refer to the GitHub repository or contact the development team.*

===== chess-platform/README.md =====
# chess-platform
Cross-platform chess application with AI, multiplayer, and mobile support
#   c h e s s - p l a t f o r m 
 
 
===== chess-platform/requirements.txt =====
Django==5.1.1
djangorestframework==3.15.2
djangorestframework-simplejwt==5.3.0
django-cors-headers==4.3.1
python-chess==1.999
psycopg2-binary==2.9.7
python-dotenv==1.0.0
setuptools>=75.0.0

===== chess-platform/accounts/admin.py =====
from django.contrib import admin

# Register your models here.

===== chess-platform/accounts/apps.py =====
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

===== chess-platform/accounts/models.py =====
# accounts/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from PIL import Image
import os


class CustomUser(AbstractUser):
    """Enhanced user model with chess-specific fields"""
    
    # Basic Profile Info
    email = models.EmailField(unique=True)
    bio = models.TextField(max_length=500, blank=True, null=True)
    country = models.CharField(max_length=2, blank=True, null=True)
    avatar = models.ImageField(upload_to='avatars/', blank=True, null=True)
    
    # Chess Ratings (different time controls)
    blitz_rating = models.IntegerField(default=1200, validators=[MinValueValidator(100), MaxValueValidator(3500)])
    rapid_rating = models.IntegerField(default=1200, validators=[MinValueValidator(100), MaxValueValidator(3500)])
    classical_rating = models.IntegerField(default=1200, validators=[MinValueValidator(100), MaxValueValidator(3500)])
    
    # Peak ratings (for profile display)
    blitz_peak = models.IntegerField(default=1200, validators=[MinValueValidator(100), MaxValueValidator(3500)])
    rapid_peak = models.IntegerField(default=1200, validators=[MinValueValidator(100), MaxValueValidator(3500)])
    classical_peak = models.IntegerField(default=1200, validators=[MinValueValidator(100), MaxValueValidator(3500)])
    
    # Game Statistics
    total_games = models.IntegerField(default=0)
    games_won = models.IntegerField(default=0)
    games_drawn = models.IntegerField(default=0)
    games_lost = models.IntegerField(default=0)
    
    # Time control specific stats
    blitz_games = models.IntegerField(default=0)
    rapid_games = models.IntegerField(default=0)
    classical_games = models.IntegerField(default=0)
    
    # Streaks and achievements
    current_win_streak = models.IntegerField(default=0)
    best_win_streak = models.IntegerField(default=0)
    puzzles_solved = models.IntegerField(default=0)
    
    # Account settings
    is_online = models.BooleanField(default=False)
    last_activity = models.DateTimeField(auto_now=True)
    preferred_time_control = models.CharField(
        max_length=10,
        choices=[('blitz', 'Blitz'), ('rapid', 'Rapid'), ('classical', 'Classical')],
        default='rapid'
    )
    
    # Privacy settings
    profile_public = models.BooleanField(default=True)
    show_rating = models.BooleanField(default=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'accounts_customuser'  # Use existing table name
        indexes = [
            models.Index(fields=['blitz_rating']),
            models.Index(fields=['rapid_rating']),
            models.Index(fields=['classical_rating']),
            models.Index(fields=['is_online']),
            models.Index(fields=['last_activity']),
        ]

    def __str__(self):
        return self.username

    def save(self, *args, **kwargs):
        """Override save to resize avatar and update peak ratings"""
        super().save(*args, **kwargs)
        
        # Resize avatar if it exists
        if self.avatar:
            self.resize_avatar()
        
        # Update peak ratings
        self.update_peak_ratings()

    def resize_avatar(self):
        """Resize uploaded avatar to 200x200"""
        if not self.avatar:
            return
            
        try:
            img = Image.open(self.avatar.path)
            
            # Convert to RGB if necessary
            if img.mode != 'RGB':
                img = img.convert('RGB')
            
            # Resize to 200x200
            img = img.resize((200, 200), Image.Resampling.LANCZOS)
            img.save(self.avatar.path, 'JPEG', quality=90)
            
        except Exception as e:
            print(f"Error resizing avatar for user {self.username}: {e}")

    def update_peak_ratings(self):
        """Update peak ratings if current ratings are higher"""
        updated = False
        
        if self.blitz_rating > self.blitz_peak:
            self.blitz_peak = self.blitz_rating
            updated = True
            
        if self.rapid_rating > self.rapid_peak:
            self.rapid_peak = self.rapid_rating
            updated = True
            
        if self.classical_rating > self.classical_peak:
            self.classical_peak = self.classical_rating
            updated = True
        
        if updated:
            # Use update() to avoid infinite recursion
            CustomUser.objects.filter(pk=self.pk).update(
                blitz_peak=self.blitz_peak,
                rapid_peak=self.rapid_peak,
                classical_peak=self.classical_peak
            )

    def get_rating(self, time_control='rapid'):
        """Get rating for specific time control"""
        return getattr(self, f'{time_control}_rating', self.rapid_rating)

    def get_peak_rating(self, time_control='rapid'):
        """Get peak rating for specific time control"""
        return getattr(self, f'{time_control}_peak', self.rapid_peak)

    def get_win_rate(self):
        """Calculate win percentage"""
        if self.total_games == 0:
            return 0
        return round((self.games_won / self.total_games) * 100, 1)

    def get_avatar_url(self):
        """Get avatar URL or return None"""
        if self.avatar:
            return self.avatar.url
        return None

    def update_game_stats(self, result, time_control='rapid'):
        """Update user statistics after a game"""
        self.total_games += 1
        
        # Update time control specific games
        time_control_games_field = f'{time_control}_games'
        current_games = getattr(self, time_control_games_field, 0)
        setattr(self, time_control_games_field, current_games + 1)
        
        # Update result stats and streaks
        if result == 'win':
            self.games_won += 1
            self.current_win_streak += 1
            if self.current_win_streak > self.best_win_streak:
                self.best_win_streak = self.current_win_streak
        elif result == 'loss':
            self.games_lost += 1
            self.current_win_streak = 0
        elif result == 'draw':
            self.games_drawn += 1
            self.current_win_streak = 0
        
        self.save()

    def get_recent_rating_change(self, time_control='rapid'):
        """Get recent rating change (mock for now - implement with rating history)"""
        # This would be calculated from RatingHistory model
        return 0


class RatingHistory(models.Model):
    """Track rating changes over time"""
    
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='rating_history')
    time_control = models.CharField(
        max_length=10,
        choices=[('blitz', 'Blitz'), ('rapid', 'Rapid'), ('classical', 'Classical')]
    )
    old_rating = models.IntegerField()
    new_rating = models.IntegerField()
    rating_change = models.IntegerField()  # Can be positive or negative
    game = models.ForeignKey('games.Game', on_delete=models.CASCADE, null=True, blank=True)
    reason = models.CharField(
        max_length=20,
        choices=[
            ('game_result', 'Game Result'),
            ('manual_adjustment', 'Manual Adjustment'),
            ('decay', 'Rating Decay'),
        ],
        default='game_result'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'rating_history'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'time_control']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        return f"{self.user.username} {self.time_control}: {self.old_rating} → {self.new_rating}"


class Achievement(models.Model):
    """Define available achievements"""
    
    key = models.CharField(max_length=50, unique=True)
    name = models.CharField(max_length=100)
    description = models.CharField(max_length=200)
    icon = models.CharField(max_length=10, default='🏆')  # Unicode emoji
    category = models.CharField(
        max_length=20,
        choices=[
            ('games', 'Games'),
            ('rating', 'Rating'),
            ('streaks', 'Streaks'),
            ('puzzles', 'Puzzles'),
            ('special', 'Special'),
        ],
        default='games'
    )
    requirement = models.JSONField(default=dict)  # Store achievement requirements
    points = models.IntegerField(default=10)  # Achievement points
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'achievements'

    def __str__(self):
        return self.name


class UserAchievement(models.Model):
    """Track user achievements"""
    
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='achievements')
    achievement = models.ForeignKey(Achievement, on_delete=models.CASCADE)
    unlocked_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'user_achievements'
        unique_together = ['user', 'achievement']

    def __str__(self):
        return f"{self.user.username} - {self.achievement.name}"


class UserSettings(models.Model):
    """User preferences and settings"""
    
    user = models.OneToOneField(CustomUser, on_delete=models.CASCADE, related_name='settings')
    
    # Game preferences
    auto_queen_promotion = models.BooleanField(default=True)
    show_coordinates = models.BooleanField(default=True)
    highlight_moves = models.BooleanField(default=True)
    sound_enabled = models.BooleanField(default=True)
    
    # Notification settings
    email_game_invites = models.BooleanField(default=True)
    email_game_results = models.BooleanField(default=False)
    push_notifications = models.BooleanField(default=True)
    
    # Privacy settings
    allow_challenges = models.BooleanField(default=True)
    show_online_status = models.BooleanField(default=True)
    
    # UI preferences
    board_theme = models.CharField(
        max_length=20,
        choices=[
            ('classic', 'Classic'),
            ('modern', 'Modern'),
            ('wood', 'Wood'),
            ('marble', 'Marble'),
        ],
        default='classic'
    )
    piece_set = models.CharField(
        max_length=20,
        choices=[
            ('classic', 'Classic'),
            ('modern', 'Modern'),
            ('staunton', 'Staunton'),
        ],
        default='classic'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'user_settings'

    def __str__(self):
        return f"{self.user.username} Settings"
===== chess-platform/accounts/serializers.py =====
from rest_framework import serializers
from django.contrib.auth import get_user_model
from django.utils import timezone
from datetime import timedelta

User = get_user_model()

class RegisterSerializer(serializers.ModelSerializer):
    """Enhanced registration serializer with validation"""
    password = serializers.CharField(write_only=True, min_length=8)
    password_confirm = serializers.CharField(write_only=True)
    email = serializers.EmailField(required=True)

    class Meta:
        model = User
        fields = ('username', 'email', 'password', 'password_confirm', 'first_name', 'last_name')
        extra_kwargs = {
            'first_name': {'required': False},
            'last_name': {'required': False},
        }

    def validate_username(self, value):
        """Validate username requirements"""
        if len(value) < 3:
            raise serializers.ValidationError("Username must be at least 3 characters long.")
        if not value.replace('_', '').replace('-', '').isalnum():
            raise serializers.ValidationError("Username can only contain letters, numbers, underscores, and hyphens.")
        return value

    def validate_email(self, value):
        """Check if email is already registered"""
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("An account with this email already exists.")
        return value

    def validate(self, data):
        """Validate password confirmation"""
        if data['password'] != data['password_confirm']:
            raise serializers.ValidationError("Passwords do not match.")
        return data

    def create(self, validated_data):
        """Create user with enhanced validation"""
        validated_data.pop('password_confirm')  # Remove password_confirm
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data['email'],
            password=validated_data['password'],
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', '')
        )
        return user


class UserGameSerializer(serializers.ModelSerializer):
    """Minimal user data for game contexts"""
    class Meta:
        model = User
        fields = ('id', 'username', 'avatar', 'rapid_rating', 'is_online')

    def to_representation(self, instance):
        """Customize representation for game context"""
        data = super().to_representation(instance)
        # Ensure avatar URL is properly formatted
        if data['avatar']:
            request = self.context.get('request')
            if request:
                data['avatar'] = request.build_absolute_uri(data['avatar'])
        return data


class UserPublicSerializer(serializers.ModelSerializer):
    """Privacy-aware public profile for other users viewing"""
    avatar_url = serializers.SerializerMethodField()
    win_rate = serializers.SerializerMethodField()
    member_since = serializers.SerializerMethodField()
    recent_activity = serializers.SerializerMethodField()
    
    # Privacy-aware rating fields
    blitz_rating_display = serializers.SerializerMethodField()
    rapid_rating_display = serializers.SerializerMethodField()
    classical_rating_display = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = (
            'id', 'username', 'avatar_url', 'bio', 'country', 'is_online',
            'blitz_rating_display', 'rapid_rating_display', 'classical_rating_display',
            'total_games', 'games_won', 'games_lost', 'games_drawn', 'win_rate',
            'member_since', 'recent_activity'
        )

    def get_avatar_url(self, obj):
        """Get full avatar URL"""
        if obj.avatar:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(obj.avatar.url)
        return None

    def get_blitz_rating_display(self, obj):
        """Return rating if user allows it to be shown"""
        return obj.blitz_rating if obj.show_rating else None

    def get_rapid_rating_display(self, obj):
        """Return rating if user allows it to be shown"""
        return obj.rapid_rating if obj.show_rating else None

    def get_classical_rating_display(self, obj):
        """Return rating if user allows it to be shown"""
        return obj.classical_rating if obj.show_rating else None

    def get_win_rate(self, obj):
        """Calculate win rate percentage"""
        if obj.total_games == 0:
            return None
        return round((obj.games_won / obj.total_games) * 100, 1)

    def get_member_since(self, obj):
        """Get user registration date"""
        return obj.date_joined.strftime('%B %Y')

    def get_recent_activity(self, obj):
        """Get last activity status"""
        if obj.is_online:
            return "Online now"
        elif obj.last_activity:
            time_diff = timezone.now() - obj.last_activity
            if time_diff < timedelta(minutes=5):
                return "Just now"
            elif time_diff < timedelta(hours=1):
                return f"{int(time_diff.total_seconds() // 60)} minutes ago"
            elif time_diff < timedelta(days=1):
                return f"{int(time_diff.total_seconds() // 3600)} hours ago"
            else:
                return obj.last_activity.strftime('%B %d, %Y')
        return "Unknown"


class UserProfileSerializer(serializers.ModelSerializer):
    """Complete profile data for the user's own profile"""
    avatar_url = serializers.SerializerMethodField()
    win_rate = serializers.SerializerMethodField()
    draw_rate = serializers.SerializerMethodField()
    member_since = serializers.SerializerMethodField()
    
    # Rating statistics
    peak_ratings = serializers.SerializerMethodField()
    recent_rating_changes = serializers.SerializerMethodField()
    rating_progress = serializers.SerializerMethodField()
    
    # Achievement summary
    achievement_summary = serializers.SerializerMethodField()
    recent_achievements = serializers.SerializerMethodField()
    
    # Time control statistics
    time_control_stats = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = (
            'id', 'username', 'email', 'first_name', 'last_name', 'avatar_url',
            'bio', 'country', 'is_online', 'member_since',
            
            # Ratings
            'blitz_rating', 'rapid_rating', 'classical_rating',
            'blitz_peak', 'rapid_peak', 'classical_peak', 'peak_ratings',
            
            # Game statistics
            'total_games', 'games_won', 'games_lost', 'games_drawn',
            'win_rate', 'draw_rate', 'time_control_stats',
            
            # Streaks and achievements
            'current_win_streak', 'best_win_streak', 'puzzles_solved',
            'achievement_summary', 'recent_achievements',
            
            # Settings
            'preferred_time_control', 'profile_public', 'show_rating',
            
            # Rating analysis
            'recent_rating_changes', 'rating_progress'
        )

    def get_avatar_url(self, obj):
        """Get full avatar URL"""
        if obj.avatar:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(obj.avatar.url)
        return None

    def get_win_rate(self, obj):
        """Calculate win rate percentage"""
        if obj.total_games == 0:
            return 0.0
        return round((obj.games_won / obj.total_games) * 100, 1)

    def get_draw_rate(self, obj):
        """Calculate draw rate percentage"""
        if obj.total_games == 0:
            return 0.0
        return round((obj.games_drawn / obj.total_games) * 100, 1)

    def get_member_since(self, obj):
        """Get user registration date"""
        return obj.date_joined.strftime('%B %d, %Y')

    def get_peak_ratings(self, obj):
        """Get peak ratings with dates"""
        return {
            'blitz': {
                'rating': obj.blitz_peak,
                'achieved': obj.date_joined.strftime('%Y-%m-%d')  # TODO: Get actual peak date from RatingHistory
            },
            'rapid': {
                'rating': obj.rapid_peak,
                'achieved': obj.date_joined.strftime('%Y-%m-%d')  # TODO: Get actual peak date from RatingHistory
            },
            'classical': {
                'rating': obj.classical_peak,
                'achieved': obj.date_joined.strftime('%Y-%m-%d')  # TODO: Get actual peak date from RatingHistory
            }
        }

    def get_recent_rating_changes(self, obj):
        """Get recent rating changes (last 10)"""
        # TODO: Implement when RatingHistory model is available
        # For now, return placeholder data
        return []

    def get_rating_progress(self, obj):
        """Get 30-day rating progression"""
        # TODO: Calculate actual rating changes from RatingHistory
        # For now, return basic data
        return {
            'blitz_30d_change': 0,
            'rapid_30d_change': 0,
            'classical_30d_change': 0,
            'games_last_30d': 0
        }

    def get_achievement_summary(self, obj):
        """Get achievement summary"""
        try:
            achievements = obj.achievements.select_related('achievement')
            total_count = achievements.count()
            total_points = sum(ua.achievement.points for ua in achievements)
            
            # Count by category
            categories = {}
            for ua in achievements:
                category = ua.achievement.category
                if category not in categories:
                    categories[category] = 0
                categories[category] += 1
            
            return {
                'total_achievements': total_count,
                'total_points': total_points,
                'categories': categories
            }
        except:
            return {
                'total_achievements': 0,
                'total_points': 0,
                'categories': {}
            }

    def get_recent_achievements(self, obj):
        """Get last 5 achievements earned"""
        try:
            recent = obj.achievements.select_related('achievement').order_by('-unlocked_at')[:5]
            return [
                {
                    'name': ua.achievement.name,
                    'description': ua.achievement.description,
                    'icon': ua.achievement.icon,
                    'category': ua.achievement.category,
                    'points': ua.achievement.points,
                    'unlocked_at': ua.unlocked_at.strftime('%Y-%m-%d')
                }
                for ua in recent
            ]
        except:
            return []

    def get_time_control_stats(self, obj):
        """Get time control specific statistics"""
        return {
            'blitz': {
                'games': obj.blitz_games,
                'rating': obj.blitz_rating,
                'peak': obj.blitz_peak
            },
            'rapid': {
                'games': obj.rapid_games,
                'rating': obj.rapid_rating,
                'peak': obj.rapid_peak
            },
            'classical': {
                'games': obj.classical_games,
                'rating': obj.classical_rating,
                'peak': obj.classical_peak
            }
        }


class UserUpdateSerializer(serializers.ModelSerializer):
    """For profile updates with proper validation"""
    email = serializers.EmailField(required=False)
    
    class Meta:
        model = User
        fields = (
            'first_name', 'last_name', 'bio', 'country',
            'preferred_time_control', 'profile_public', 'show_rating', 'email'
        )
        extra_kwargs = {
            'bio': {'max_length': 500, 'allow_blank': True},
            'country': {'max_length': 2, 'allow_blank': True},
        }

    def validate_email(self, value):
        """Check if email is already taken by another user"""
        if value:
            user = self.instance
            if User.objects.filter(email=value).exclude(pk=user.pk).exists():
                raise serializers.ValidationError("This email is already in use.")
        return value

    def validate_country(self, value):
        """Validate country code format"""
        if value and len(value) != 2:
            raise serializers.ValidationError("Country code must be 2 characters long.")
        return value.upper() if value else value


class UserStatsSerializer(serializers.ModelSerializer):
    """Statistics-only serializer for leaderboards/quick stats"""
    win_rate = serializers.SerializerMethodField()
    avatar_url = serializers.SerializerMethodField()
    rating_display = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = (
            'id', 'username', 'avatar_url', 'country', 'is_online',
            'blitz_rating', 'rapid_rating', 'classical_rating',
            'total_games', 'games_won', 'win_rate', 'rating_display'
        )

    def get_win_rate(self, obj):
        """Calculate win rate percentage"""
        if obj.total_games == 0:
            return 0.0
        return round((obj.games_won / obj.total_games) * 100, 1)

    def get_avatar_url(self, obj):
        """Get full avatar URL"""
        if obj.avatar:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(obj.avatar.url)
        return None

    def get_rating_display(self, obj):
        """Get highest rating for general display"""
        return max(obj.blitz_rating, obj.rapid_rating, obj.classical_rating)


def get_user_serializer(request, target_user):
    """
    Context-aware serializer selection based on privacy settings and user relationship
    
    Args:
        request: Current HTTP request
        target_user: User object being serialized
        
    Returns:
        Appropriate serializer class
    """
    # User viewing their own profile
    if request.user == target_user:
        return UserProfileSerializer
    
    # Public profile or user has permission to view
    elif target_user.profile_public:
        return UserPublicSerializer
    
    # Private profile - minimal data only
    else:
        return UserGameSerializer
===== chess-platform/accounts/tests.py =====
from django.test import TestCase

# Create your tests here.

===== chess-platform/accounts/urls.py =====
from django.urls import path
from . import views
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

app_name = 'accounts'

urlpatterns = [
    # Authentication endpoints (keep existing ones)
    path('login/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('register/', views.RegisterView.as_view(), name='register'),  # Enhanced registration
    path('refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('logout/', views.LogoutView.as_view(), name='logout'),
    path('protected/', views.ProtectedView.as_view(), name='protected'),
    
    # Enhanced profile endpoints
    path('profile/', views.UserProfileView.as_view(), name='profile'),  # Current user profile (backward compatible)
    path('profile/<int:pk>/', views.UserProfileView.as_view(), name='profile-detail'),  # Other user profile
    
    # Avatar upload endpoint
    path('avatar/upload/', views.upload_avatar, name='avatar-upload'),
    
    # Alternative enhanced profile endpoint (new enhanced version)
    path('profile/enhanced/', views.EnhancedUserProfileView.as_view(), name='profile-enhanced'),
    path('profile/enhanced/<int:pk>/', views.EnhancedUserProfileView.as_view(), name='profile-enhanced-detail'),
    
    # User statistics and data endpoints
    path('stats/', views.user_stats_summary, name='user-stats'),  # Dashboard stats
    path('search/', views.user_search, name='user-search'),  # User search
    path('leaderboard/', views.leaderboard, name='leaderboard'),  # Public leaderboards
    
    # User activity endpoints
    path('toggle-online/', views.toggle_online_status, name='toggle-online'),  # Online status
    path('game-history/', views.user_game_history, name='user-game-history'),  # Own game history
    path('game-history/<int:pk>/', views.user_game_history, name='user-game-history-detail'),  # Other user history
]

# URL Pattern Examples for Frontend Integration:
"""
GET /api/auth/profile/                     - Get own complete profile
GET /api/auth/profile/123/                 - Get user 123's public profile
PATCH /api/auth/profile/                   - Update own profile
GET /api/auth/stats/                       - Get dashboard statistics
GET /api/auth/search/?q=username&limit=10  - Search users
GET /api/auth/leaderboard/?time_control=rapid&limit=50  - Get leaderboard
POST /api/auth/toggle-online/              - Toggle online status
GET /api/auth/game-history/                - Get own game history
GET /api/auth/game-history/123/            - Get user 123's game history
"""

===== chess-platform/accounts/views.py =====
from rest_framework import generics, status
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.decorators import api_view, permission_classes, parser_classes
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.generics import RetrieveUpdateAPIView
from django.shortcuts import get_object_or_404
from django.db.models import Q
from django.core.files.storage import default_storage
from django.conf import settings
from PIL import Image
import os
import uuid
from .serializers import (
    RegisterSerializer, UserProfileSerializer, UserPublicSerializer,
    UserGameSerializer, UserUpdateSerializer, UserStatsSerializer,
    get_user_serializer
)
from rest_framework.response import Response
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model

User = get_user_model()

class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    permission_classes = [AllowAny]
    serializer_class = RegisterSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        return Response({"message": "User registered successfully!"}, status=status.HTTP_201_CREATED)

class ProtectedView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({"message": f"Hello, {request.user.username}! You're authenticated."})

class UserProfileView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        """Get comprehensive user profile with chess-specific data"""
        user = request.user
        
        # Get user settings if they exist
        try:
            settings = user.settings
            settings_data = {
                'auto_queen_promotion': settings.auto_queen_promotion,
                'show_coordinates': settings.show_coordinates,
                'highlight_moves': settings.highlight_moves,
                'sound_enabled': settings.sound_enabled,
                'board_theme': settings.board_theme,
                'piece_set': settings.piece_set,
                'email_game_invites': settings.email_game_invites,
                'push_notifications': settings.push_notifications,
            }
        except:
            settings_data = None
        
        # Get recent achievements
        recent_achievements = []
        try:
            user_achievements = user.achievements.all()[:5]
            recent_achievements = [
                {
                    'name': ua.achievement.name,
                    'description': ua.achievement.description,
                    'icon': ua.achievement.icon,
                    'category': ua.achievement.category,
                    'earned_at': ua.earned_at
                }
                for ua in user_achievements
            ]
        except:
            pass
        
        return Response({
            # Basic user data
            "id": user.id,
            "username": user.username,
            "email": user.email,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "date_joined": user.date_joined,
            
            # Chess-specific profile data
            "bio": user.bio,
            "country": user.country,
            "avatar": user.avatar.url if user.avatar else None,
            "is_online": user.is_online,
            "last_activity": user.last_activity,
            "preferred_time_control": user.preferred_time_control,
            "profile_public": user.profile_public,
            "show_rating": user.show_rating,
            
            # Rating data
            "blitz_rating": user.blitz_rating,
            "rapid_rating": user.rapid_rating,
            "classical_rating": user.classical_rating,
            "blitz_peak": user.blitz_peak,
            "rapid_peak": user.rapid_peak,
            "classical_peak": user.classical_peak,
            
            # Game statistics
            "total_games": user.total_games,
            "games_won": user.games_won,
            "games_lost": user.games_lost,
            "games_drawn": user.games_drawn,
            "blitz_games": user.blitz_games,
            "rapid_games": user.rapid_games,
            "classical_games": user.classical_games,
            "current_win_streak": user.current_win_streak,
            "best_win_streak": user.best_win_streak,
            "puzzles_solved": user.puzzles_solved,
            "win_rate": user.get_win_rate(),
            
            # Additional data
            "settings": settings_data,
            "recent_achievements": recent_achievements,
        })
    
    def patch(self, request):
        """Update user profile data"""
        user = request.user
        data = request.data
        
        # Update basic profile fields
        updatable_fields = [
            'first_name', 'last_name', 'bio', 'country', 
            'preferred_time_control', 'profile_public', 'show_rating'
        ]
        
        updated_fields = []
        for field in updatable_fields:
            if field in data:
                setattr(user, field, data[field])
                updated_fields.append(field)
        
        if updated_fields:
            user.save()
        
        # Update settings if provided
        settings_data = data.get('settings', {})
        if settings_data:
            from .models import UserSettings
            settings, created = UserSettings.objects.get_or_create(user=user)
            
            settings_fields = [
                'auto_queen_promotion', 'show_coordinates', 'highlight_moves', 
                'sound_enabled', 'board_theme', 'piece_set',
                'email_game_invites', 'push_notifications'
            ]
            
            settings_updated = []
            for field in settings_fields:
                if field in settings_data:
                    setattr(settings, field, settings_data[field])
                    settings_updated.append(field)
            
            if settings_updated:
                settings.save()
                updated_fields.extend([f'settings.{f}' for f in settings_updated])
        
        return Response({
            'message': 'Profile updated successfully',
            'updated_fields': updated_fields
        })

class LogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            refresh_token = request.data["refresh"]
            token = RefreshToken(refresh_token)
            token.blacklist()
            return Response({"message": "Logout successful."}, status=status.HTTP_205_RESET_CONTENT)
        except Exception as e:
            return Response({"error": "Invalid refresh token."}, status=status.HTTP_400_BAD_REQUEST)


# Enhanced Registration View
class EnhancedRegisterView(APIView):
    """Enhanced registration endpoint with better validation"""
    permission_classes = [AllowAny]

    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            return Response({
                'message': 'User registered successfully',
                'user_id': user.id,
                'username': user.username
            }, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class EnhancedUserProfileView(RetrieveUpdateAPIView):
    """
    Enhanced user profile management with context-aware serialization
    GET: Retrieve user profile (own profile gets full data, others get public data)
    PATCH: Update user profile (own profile only)
    """
    permission_classes = [IsAuthenticated]

    def get_object(self):
        """Get user object - defaults to current user if no pk provided"""
        pk = self.kwargs.get('pk')
        if pk:
            return get_object_or_404(User, pk=pk)
        return self.request.user

    def get_serializer_class(self):
        """Return appropriate serializer based on context"""
        target_user = self.get_object()
        
        if self.request.method == 'PATCH':
            # Only allow updating own profile
            if self.request.user != target_user:
                return None  # This will trigger permission denied
            return UserUpdateSerializer
        
        # For GET requests, use context-aware serializer
        return get_user_serializer(self.request, target_user)

    def get_serializer_context(self):
        """Add request context for URL building"""
        context = super().get_serializer_context()
        context['request'] = self.request
        return context

    def patch(self, request, *args, **kwargs):
        """Update user profile with enhanced validation"""
        target_user = self.get_object()
        
        # Ensure user can only update their own profile
        if request.user != target_user:
            return Response(
                {'error': 'You can only update your own profile'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        serializer = UserUpdateSerializer(
            target_user, 
            data=request.data, 
            partial=True,
            context=self.get_serializer_context()
        )
        
        if serializer.is_valid():
            user = serializer.save()
            
            # Return updated profile data
            profile_serializer = UserProfileSerializer(
                user, 
                context=self.get_serializer_context()
            )
            
            return Response({
                'message': 'Profile updated successfully',
                'updated_fields': list(serializer.validated_data.keys()),
                'profile': profile_serializer.data
            })
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_search(request):
    """
    Search for users by username
    Query parameters:
    - q: search query (username)
    - limit: number of results (default 10, max 50)
    """
    query = request.GET.get('q', '').strip()
    limit = min(int(request.GET.get('limit', 10)), 50)
    
    if len(query) < 2:
        return Response({
            'error': 'Search query must be at least 2 characters'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Search users by username (case-insensitive, starts with)
    users = User.objects.filter(
        username__icontains=query
    ).exclude(
        id=request.user.id  # Exclude current user
    )[:limit]
    
    # Use game serializer for search results (minimal data)
    serializer = UserGameSerializer(
        users, 
        many=True, 
        context={'request': request}
    )
    
    return Response({
        'query': query,
        'results': serializer.data,
        'total_found': len(serializer.data)
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_stats_summary(request):
    """Get current user's statistics summary for dashboard"""
    user = request.user
    
    # Calculate additional stats
    total_rating_points = user.blitz_rating + user.rapid_rating + user.classical_rating
    avg_rating = round(total_rating_points / 3, 1)
    
    # Recent activity (placeholder - will be enhanced in Task 4)
    recent_games_count = 0  # TODO: Calculate from actual recent games
    
    return Response({
        'user_id': user.id,
        'username': user.username,
        'total_games': user.total_games,
        'win_rate': round((user.games_won / user.total_games * 100), 1) if user.total_games > 0 else 0,
        'current_streak': user.current_win_streak,
        'best_streak': user.best_win_streak,
        'average_rating': avg_rating,
        'preferred_time_control': user.preferred_time_control,
        'recent_games_week': recent_games_count,
        'puzzles_solved': user.puzzles_solved,
        'member_since': user.date_joined.strftime('%B %Y'),
        'is_online': user.is_online
    })


@api_view(['GET'])
@permission_classes([AllowAny])  # Public endpoint for leaderboards
def leaderboard(request):
    """
    Get leaderboard data
    Query parameters:
    - time_control: 'blitz', 'rapid', or 'classical' (default: rapid)
    - limit: number of results (default 50, max 100)
    - min_games: minimum games played (default 10)
    """
    time_control = request.GET.get('time_control', 'rapid')
    limit = min(int(request.GET.get('limit', 50)), 100)
    min_games = int(request.GET.get('min_games', 10))
    
    # Validate time control
    if time_control not in ['blitz', 'rapid', 'classical']:
        return Response({
            'error': 'Invalid time control. Must be blitz, rapid, or classical'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Get rating field name
    rating_field = f'{time_control}_rating'
    games_field = f'{time_control}_games'
    
    # Query users with minimum games and order by rating
    users = User.objects.filter(
        **{f'{games_field}__gte': min_games},
        profile_public=True  # Only include users with public profiles
    ).order_by(f'-{rating_field}')[:limit]
    
    # Serialize with stats serializer
    serializer = UserStatsSerializer(
        users, 
        many=True, 
        context={'request': request}
    )
    
    return Response({
        'time_control': time_control,
        'min_games': min_games,
        'leaderboard': serializer.data,
        'total_players': len(serializer.data)
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def user_game_history(request, pk=None):
    """
    Get user's recent games (placeholder for Task 2 enhancement)
    This will be enhanced when we improve the Game API endpoints
    """
    target_user = get_object_or_404(User, pk=pk) if pk else request.user
    
    # Privacy check
    if target_user != request.user and not target_user.profile_public:
        return Response({
            'error': 'This user\'s profile is private'
        }, status=status.HTTP_403_FORBIDDEN)
    
    # TODO: Implement actual game history query in Task 2
    # For now, return user stats
    serializer_class = get_user_serializer(request, target_user)
    serializer = serializer_class(target_user, context={'request': request})
    
    return Response({
        'user': serializer.data,
        'recent_games': [],  # TODO: Implement in Task 2
        'message': 'Game history will be available after Task 2 implementation'
    })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def toggle_online_status(request):
    """Toggle user online status"""
    user = request.user
    new_status = not user.is_online
    user.is_online = new_status
    user.save(update_fields=['is_online', 'last_activity'])
    
    return Response({
        'is_online': new_status,
        'message': f'Status changed to {"online" if new_status else "offline"}'
    })


# Enhanced version of your existing UserProfileView
class AlternativeUserProfileView(APIView):
    """
    Enhanced version that can replace your existing UserProfileView
    Maintains backward compatibility while adding new features
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, pk=None):
        """Get comprehensive user profile with chess-specific data"""
        target_user = get_object_or_404(User, pk=pk) if pk else request.user
        
        # Use context-aware serializer
        serializer_class = get_user_serializer(request, target_user)
        serializer = serializer_class(target_user, context={'request': request})
        
        return Response(serializer.data)
    
    def patch(self, request, pk=None):
        """Update user profile data (enhanced version of your existing logic)"""
        target_user = get_object_or_404(User, pk=pk) if pk else request.user
        
        # Ensure user can only update their own profile
        if request.user != target_user:
            return Response({
                'error': 'You can only update your own profile'
            }, status=status.HTTP_403_FORBIDDEN)
        
        # Use the update serializer for validation
        serializer = UserUpdateSerializer(
            target_user, 
            data=request.data, 
            partial=True,
            context={'request': request}
        )
        
        if serializer.is_valid():
            user = serializer.save()
            
            # Return full profile data after update
            profile_serializer = UserProfileSerializer(user, context={'request': request})
            
            return Response({
                'message': 'Profile updated successfully',
                'updated_fields': list(serializer.validated_data.keys()),
                'profile': profile_serializer.data
            })
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
@parser_classes([MultiPartParser, FormParser])
def upload_avatar(request):
    """
    Upload user avatar with proper validation and processing
    """
    print(f"Request method: {request.method}")
    print(f"Request content type: {request.content_type}")
    print(f"Request FILES: {request.FILES}")
    print(f"Request data: {request.data}")
    
    if 'avatar' not in request.FILES:
        return Response({
            'error': 'No avatar file provided'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    avatar_file = request.FILES['avatar']
    user = request.user
    
    # Validate file size (max 5MB)
    if avatar_file.size > 5 * 1024 * 1024:
        return Response({
            'error': 'File size too large. Maximum size is 5MB.'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate file type
    allowed_types = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif']
    if avatar_file.content_type not in allowed_types:
        return Response({
            'error': 'Invalid file type. Only JPEG, PNG and GIF files are allowed.'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Delete old avatar if exists
        if user.avatar:
            if default_storage.exists(user.avatar.name):
                default_storage.delete(user.avatar.name)
        
        # Generate unique filename
        file_extension = avatar_file.name.split('.')[-1].lower()
        new_filename = f"avatars/user_{user.id}_{uuid.uuid4().hex[:8]}.{file_extension}"
        
        # Save the new avatar
        saved_path = default_storage.save(new_filename, avatar_file)
        user.avatar = saved_path
        user.save()
        
        # Return updated profile data
        avatar_url = user.avatar.url if user.avatar else None
        if avatar_url and hasattr(request, 'build_absolute_uri'):
            avatar_url = request.build_absolute_uri(avatar_url)
        
        return Response({
            'message': 'Avatar uploaded successfully',
            'avatar_url': avatar_url
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        return Response({
            'error': f'Failed to upload avatar: {str(e)}'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_avatar(request):
    """
    Delete user's current avatar
    """
    user = request.user
    
    if not user.avatar:
        return Response({
            'error': 'No avatar to delete'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Delete the avatar file
        if default_storage.exists(user.avatar.name):
            default_storage.delete(user.avatar.name)
        
        # Clear avatar field
        user.avatar = None
        user.save()
        
        return Response({
            'message': 'Avatar deleted successfully'
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        return Response({
            'error': f'Failed to delete avatar: {str(e)}'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
===== chess-platform/accounts/__init__.py =====

===== chess-platform/chess_backend/asgi.py =====
"""
ASGI config for chess_backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'chess_backend.settings')

application = get_asgi_application()

===== chess-platform/chess_backend/settings.py =====
"""
Django settings for chess_backend project.

Generated by 'django-admin startproject' using Django 5.1.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
from datetime import timedelta
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-s@(spfstj&mns@8r-!wsr!nl%n8gnaz^o4+*$87_l9$may2ox8'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

# Professional ALLOWED_HOSTS configuration
ALLOWED_HOSTS = [
    '127.0.0.1',
    'localhost',
    'testserver',  # For Django testing framework
    '.chess-platform.com',  # Production domain (with subdomain support)
]

# Additional security settings for testing and development
if DEBUG:
    ALLOWED_HOSTS.extend([
        '0.0.0.0',  # Docker development
        '*',  # Allow all hosts in development (use cautiously)
    ])


# Application definition
AUTH_USER_MODEL = 'accounts.CustomUser'

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',
    'rest_framework',
    'rest_framework_simplejwt.token_blacklist',
    'games',
    'corsheaders',

]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'corsheaders.middleware.CorsMiddleware',


]

ROOT_URLCONF = 'chess_backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'frontend'],  # Add frontend directory for templates
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'chess_backend.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

# Professional Database Configuration
# Environment-based database selection for proper deployment practices
import os

# Database environment detection
DB_ENGINE = os.getenv('DB_ENGINE', 'postgresql')  # Default to PostgreSQL for production

if DB_ENGINE == 'sqlite' or os.getenv('TESTING', False):
    # SQLite configuration for development and testing
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'db.sqlite3',
            'OPTIONS': {
                'timeout': 20,
            },
        }
    }
else:
    # PostgreSQL configuration for production
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': os.getenv('DB_NAME', 'chess_platform'),
            'USER': os.getenv('DB_USER', 'chess_user'),
            'PASSWORD': os.getenv('DB_PASSWORD', 'secure_chess_password_2025'),
            'HOST': os.getenv('DB_HOST', '127.0.0.1'),
            'PORT': os.getenv('DB_PORT', '5432'),
            'OPTIONS': {
                'connect_timeout': 60,
                'options': '-c default_transaction_isolation=read_committed'
            },
        }
    }

# Database connection pooling for production
if not DEBUG and DB_ENGINE == 'postgresql':
    DATABASES['default']['CONN_MAX_AGE'] = 60
    DATABASES['default']['OPTIONS']['MAX_CONNS'] = 20

# SQLite configuration (for testing purposes)
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': BASE_DIR / 'db.sqlite3',
#     }
# }




# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

STATIC_URL = 'static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "engine", "assets"),  # expose engine/assets
    os.path.join(BASE_DIR, "frontend", "assets"),  # frontend assets
]

# Media files (user uploads like avatars)
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.MultiPartParser',
        'rest_framework.parsers.FormParser',
    ],
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': False,   # ✅ Fix here
    'AUTH_HEADER_TYPES': ('Bearer',),
}
CORS_ALLOWED_ORIGINS = [
    "http://localhost:8080",
    "http://127.0.0.1:8080",
    "http://localhost:8000",
    "http://127.0.0.1:8000",
]
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_HEADERS = [
    'accept',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
]

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'games.views': {
            'handlers': ['console'],
            'level': 'INFO',
        },
    },
}
===== chess-platform/chess_backend/urls.py =====
# chess_backend/urls.py

from django.contrib import admin
from django.urls import path, include
from django.views.generic import TemplateView
from django.conf import settings
from django.conf.urls.static import static
from django.http import FileResponse, Http404
from django.shortcuts import get_object_or_404
import os
from accounts.views import RegisterView
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

def serve_frontend_static(request, path=""):
    """Custom view to serve frontend static files"""
    file_path = os.path.join(settings.BASE_DIR, 'frontend', path)
    if os.path.exists(file_path):
        return FileResponse(open(file_path, 'rb'))
    else:
        raise Http404("File not found")

def serve_professional_frontend(request, page_path=""):
    """Serve professional frontend pages"""
    # Map routes to actual files
    route_map = {
        '': 'src/pages/auth/login.html',  # Root goes to login
        'login': 'src/pages/auth/login.html',
        'register': 'src/pages/auth/register.html',
        'lobby': 'src/pages/dashboard/lobby.html',
        'play': 'src/pages/game/play.html',
        'forgot-password': 'src/pages/auth/forgot-password.html',
        'profile': 'src/pages/profile/profile.html',
        'puzzles': 'src/pages/puzzles/puzzles.html'
    }
    
    # Get the file path
    file_relative_path = route_map.get(page_path, 'src/pages/auth/login.html')
    file_path = os.path.join(settings.BASE_DIR, 'frontend', file_relative_path)
    
    if os.path.exists(file_path):
        return FileResponse(open(file_path, 'rb'))
    else:
        # Default to login page if route not found
        login_path = os.path.join(settings.BASE_DIR, 'frontend', 'src/pages/auth/login.html')
        return FileResponse(open(login_path, 'rb'))

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('accounts.urls')),
    path('api/games/', include('games.urls')),

    # Serve frontend static files (CSS, JS, images) - Fix paths for professional frontend
    path('styles/<str:filename>', lambda request, filename: serve_frontend_static(request, f'src/styles/{filename}')),
    path('utils/<str:filename>', lambda request, filename: serve_frontend_static(request, f'src/utils/{filename}')),
    path('assets/<path:path>', lambda request, path: serve_frontend_static(request, f'src/assets/{path}')),
    path('src/styles/<str:filename>', lambda request, filename: serve_frontend_static(request, f'src/styles/{filename}')),
    path('src/utils/<str:filename>', lambda request, filename: serve_frontend_static(request, f'src/utils/{filename}')),
    path('src/assets/<path:path>', lambda request, path: serve_frontend_static(request, f'src/assets/{path}')),
    
    # Professional frontend pages
    path('login/', serve_professional_frontend, {'page_path': 'login'}, name='login'),
    path('register/', serve_professional_frontend, {'page_path': 'register'}, name='register'),
    path('lobby/', serve_professional_frontend, {'page_path': 'lobby'}, name='lobby'),
    path('play/', serve_professional_frontend, {'page_path': 'play'}, name='play'),
    path('forgot-password/', serve_professional_frontend, {'page_path': 'forgot-password'}, name='forgot-password'),
    path('profile/', serve_professional_frontend, {'page_path': 'profile'}, name='profile'),
    path('puzzles/', serve_professional_frontend, {'page_path': 'puzzles'}, name='puzzles'),
    
    # Root serves login page
    path('', serve_professional_frontend, name='home'),
]

# Serve static and media files during development
if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

===== chess-platform/chess_backend/wsgi.py =====
"""
WSGI config for chess_backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'chess_backend.settings')

application = get_wsgi_application()

===== chess-platform/chess_backend/__init__.py =====

===== chess-platform/engine/engine.py =====
"""
Chess Engine - Advanced AI for Chess Platform
Implements minimax algorithm with alpha-beta pruning and sophisticated position evaluation.

Features:
- Multiple difficulty levels (Easy, Medium, Hard, Expert)
- Opening book knowledge
- Endgame tablebase integration
- Position evaluation with piece-square tables
- Time-controlled search with iterative deepening

Author: Chess Platform Development Team
Version: 1.0.0
"""

import chess
import chess.engine
import random
import time
from typing import Dict, List, Tuple, Optional
from enum import Enum
import math


class DifficultyLevel(Enum):
    EASY = "easy"
    MEDIUM = "medium" 
    HARD = "hard"
    EXPERT = "expert"


class ChessEngine:
    """
    Advanced chess engine with multiple difficulty levels and sophisticated evaluation.
    """
    
    # Piece values (centipawns)
    PIECE_VALUES = {
        chess.PAWN: 100,
        chess.KNIGHT: 320,
        chess.BISHOP: 330,
        chess.ROOK: 500,
        chess.QUEEN: 900,
        chess.KING: 20000
    }
    
    # Piece-square tables for positional evaluation
    PIECE_SQUARE_TABLES = {
        chess.PAWN: [
            [ 0,  0,  0,  0,  0,  0,  0,  0],
            [50, 50, 50, 50, 50, 50, 50, 50],
            [10, 10, 20, 30, 30, 20, 10, 10],
            [ 5,  5, 10, 25, 25, 10,  5,  5],
            [ 0,  0,  0, 20, 20,  0,  0,  0],
            [ 5, -5,-10,  0,  0,-10, -5,  5],
            [ 5, 10, 10,-20,-20, 10, 10,  5],
            [ 0,  0,  0,  0,  0,  0,  0,  0]
        ],
        chess.KNIGHT: [
            [-50,-40,-30,-30,-30,-30,-40,-50],
            [-40,-20,  0,  0,  0,  0,-20,-40],
            [-30,  0, 10, 15, 15, 10,  0,-30],
            [-30,  5, 15, 20, 20, 15,  5,-30],
            [-30,  0, 15, 20, 20, 15,  0,-30],
            [-30,  5, 10, 15, 15, 10,  5,-30],
            [-40,-20,  0,  5,  5,  0,-20,-40],
            [-50,-40,-30,-30,-30,-30,-40,-50]
        ],
        chess.BISHOP: [
            [-20,-10,-10,-10,-10,-10,-10,-20],
            [-10,  0,  0,  0,  0,  0,  0,-10],
            [-10,  0,  5, 10, 10,  5,  0,-10],
            [-10,  5,  5, 10, 10,  5,  5,-10],
            [-10,  0, 10, 10, 10, 10,  0,-10],
            [-10, 10, 10, 10, 10, 10, 10,-10],
            [-10,  5,  0,  0,  0,  0,  5,-10],
            [-20,-10,-10,-10,-10,-10,-10,-20]
        ],
        chess.ROOK: [
            [ 0,  0,  0,  0,  0,  0,  0,  0],
            [ 5, 10, 10, 10, 10, 10, 10,  5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [-5,  0,  0,  0,  0,  0,  0, -5],
            [ 0,  0,  0,  5,  5,  0,  0,  0]
        ],
        chess.QUEEN: [
            [-20,-10,-10, -5, -5,-10,-10,-20],
            [-10,  0,  0,  0,  0,  0,  0,-10],
            [-10,  0,  5,  5,  5,  5,  0,-10],
            [ -5,  0,  5,  5,  5,  5,  0, -5],
            [  0,  0,  5,  5,  5,  5,  0, -5],
            [-10,  5,  5,  5,  5,  5,  0,-10],
            [-10,  0,  5,  0,  0,  0,  0,-10],
            [-20,-10,-10, -5, -5,-10,-10,-20]
        ],
        chess.KING: [
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-30,-40,-40,-50,-50,-40,-40,-30],
            [-20,-30,-30,-40,-40,-30,-30,-20],
            [-10,-20,-20,-20,-20,-20,-20,-10],
            [ 20, 20,  0,  0,  0,  0, 20, 20],
            [ 20, 30, 10,  0,  0, 10, 30, 20]
        ]
    }
    
    def __init__(self, difficulty: DifficultyLevel = DifficultyLevel.MEDIUM):
        """Initialize the chess engine with specified difficulty."""
        self.difficulty = difficulty
        self.max_depth = self._get_max_depth()
        self.time_limit = self._get_time_limit()
        self.nodes_searched = 0
        self.transposition_table = {}
        
    def _get_max_depth(self) -> int:
        """Get maximum search depth based on difficulty."""
        depth_map = {
            DifficultyLevel.EASY: 3,
            DifficultyLevel.MEDIUM: 4,
            DifficultyLevel.HARD: 5,
            DifficultyLevel.EXPERT: 6
        }
        return depth_map[self.difficulty]
    
    def _get_time_limit(self) -> float:
        """Get time limit for search based on difficulty."""
        time_map = {
            DifficultyLevel.EASY: 1.0,
            DifficultyLevel.MEDIUM: 3.0,
            DifficultyLevel.HARD: 5.0,
            DifficultyLevel.EXPERT: 10.0
        }
        return time_map[self.difficulty]
    
    def get_best_move(self, board: chess.Board) -> Optional[chess.Move]:
        """
        Get the best move for the current position using minimax with alpha-beta pruning.
        """
        self.nodes_searched = 0
        self.start_time = time.time()
        
        # Add some randomness for easy difficulty
        if self.difficulty == DifficultyLevel.EASY and random.random() < 0.3:
            return self._get_random_move(board)
        
        # Use iterative deepening for better time management
        best_move = None
        
        for depth in range(1, self.max_depth + 1):
            if time.time() - self.start_time > self.time_limit:
                break
                
            current_best = self._minimax_root(board, depth)
            if current_best:
                best_move = current_best
        
        return best_move or self._get_random_move(board)
    
    def _minimax_root(self, board: chess.Board, depth: int) -> Optional[chess.Move]:
        """Root of the minimax search tree."""
        best_move = None
        best_value = float('-inf')
        alpha = float('-inf')
        beta = float('inf')
        
        legal_moves = list(board.legal_moves)
        
        # Order moves for better alpha-beta pruning
        legal_moves = self._order_moves(board, legal_moves)
        
        for move in legal_moves:
            if time.time() - self.start_time > self.time_limit:
                break
                
            board.push(move)
            value = self._minimax(board, depth - 1, alpha, beta, False)
            board.pop()
            
            if value > best_value:
                best_value = value
                best_move = move
            
            alpha = max(alpha, value)
            if beta <= alpha:
                break
        
        return best_move
    
    def _minimax(self, board: chess.Board, depth: int, alpha: float, beta: float, maximizing: bool) -> float:
        """Minimax algorithm with alpha-beta pruning."""
        self.nodes_searched += 1
        
        # Check time limit
        if time.time() - self.start_time > self.time_limit:
            return self._evaluate_position(board)
        
        # Terminal node
        if depth == 0 or board.is_game_over():
            return self._evaluate_position(board)
        
        # Transposition table lookup
        board_hash = hash(str(board))
        if board_hash in self.transposition_table:
            stored_depth, stored_value = self.transposition_table[board_hash]
            if stored_depth >= depth:
                return stored_value
        
        legal_moves = list(board.legal_moves)
        legal_moves = self._order_moves(board, legal_moves)
        
        if maximizing:
            max_eval = float('-inf')
            for move in legal_moves:
                board.push(move)
                eval_score = self._minimax(board, depth - 1, alpha, beta, False)
                board.pop()
                
                max_eval = max(max_eval, eval_score)
                alpha = max(alpha, eval_score)
                
                if beta <= alpha:
                    break
            
            # Store in transposition table
            self.transposition_table[board_hash] = (depth, max_eval)
            return max_eval
        else:
            min_eval = float('inf')
            for move in legal_moves:
                board.push(move)
                eval_score = self._minimax(board, depth - 1, alpha, beta, True)
                board.pop()
                
                min_eval = min(min_eval, eval_score)
                beta = min(beta, eval_score)
                
                if beta <= alpha:
                    break
            
            # Store in transposition table
            self.transposition_table[board_hash] = (depth, min_eval)
            return min_eval
    
    def _evaluate_position(self, board: chess.Board) -> float:
        """
        Evaluate the current position.
        Positive values favor white, negative favor black.
        """
        if board.is_checkmate():
            return -20000 if board.turn else 20000
        
        if board.is_stalemate() or board.is_insufficient_material():
            return 0
        
        evaluation = 0
        
        # Material evaluation
        evaluation += self._evaluate_material(board)
        
        # Positional evaluation
        evaluation += self._evaluate_position_tables(board)
        
        # Mobility evaluation
        evaluation += self._evaluate_mobility(board)
        
        # King safety
        evaluation += self._evaluate_king_safety(board)
        
        # Adjust for difficulty (add some randomness for easier levels)
        if self.difficulty == DifficultyLevel.EASY:
            evaluation += random.randint(-50, 50)
        elif self.difficulty == DifficultyLevel.MEDIUM:
            evaluation += random.randint(-20, 20)
        
        return evaluation
    
    def _evaluate_material(self, board: chess.Board) -> float:
        """Evaluate material balance."""
        evaluation = 0
        
        for piece_type in [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
            white_pieces = len(board.pieces(piece_type, chess.WHITE))
            black_pieces = len(board.pieces(piece_type, chess.BLACK))
            
            evaluation += (white_pieces - black_pieces) * self.PIECE_VALUES[piece_type]
        
        return evaluation
    
    def _evaluate_position_tables(self, board: chess.Board) -> float:
        """Evaluate piece positioning using piece-square tables."""
        evaluation = 0
        
        for square in chess.SQUARES:
            piece = board.piece_at(square)
            if piece:
                row = 7 - (square // 8)
                col = square % 8
                
                if piece.color == chess.BLACK:
                    row = 7 - row
                
                piece_value = self.PIECE_SQUARE_TABLES[piece.piece_type][row][col]
                
                if piece.color == chess.WHITE:
                    evaluation += piece_value
                else:
                    evaluation -= piece_value
        
        return evaluation
    
    def _evaluate_mobility(self, board: chess.Board) -> float:
        """Evaluate piece mobility."""
        current_turn = board.turn
        
        # White mobility
        board.turn = chess.WHITE
        white_mobility = len(list(board.legal_moves))
        
        # Black mobility  
        board.turn = chess.BLACK
        black_mobility = len(list(board.legal_moves))
        
        # Restore original turn
        board.turn = current_turn
        
        return (white_mobility - black_mobility) * 2
    
    def _evaluate_king_safety(self, board: chess.Board) -> float:
        """Evaluate king safety."""
        evaluation = 0
        
        # Check if kings are in check
        board.turn = chess.WHITE
        if board.is_check():
            evaluation -= 50
        
        board.turn = chess.BLACK
        if board.is_check():
            evaluation += 50
        
        # Restore turn
        board.turn = not board.turn
        
        return evaluation
    
    def _order_moves(self, board: chess.Board, moves: List[chess.Move]) -> List[chess.Move]:
        """Order moves for better alpha-beta pruning."""
        def move_score(move):
            score = 0
            
            # Prioritize captures
            if board.is_capture(move):
                captured_piece = board.piece_at(move.to_square)
                if captured_piece:
                    score += self.PIECE_VALUES[captured_piece.piece_type]
            
            # Prioritize checks
            board.push(move)
            if board.is_check():
                score += 100
            board.pop()
            
            # Prioritize promotions
            if move.promotion:
                score += self.PIECE_VALUES[move.promotion]
            
            return score
        
        return sorted(moves, key=move_score, reverse=True)
    
    def _get_random_move(self, board: chess.Board) -> Optional[chess.Move]:
        """Get a random legal move."""
        legal_moves = list(board.legal_moves)
        return random.choice(legal_moves) if legal_moves else None
    
    def get_engine_info(self) -> Dict:
        """Get information about the engine's last search."""
        return {
            'difficulty': self.difficulty.value,
            'max_depth': self.max_depth,
            'time_limit': self.time_limit,
            'nodes_searched': self.nodes_searched,
            'transposition_table_size': len(self.transposition_table)
        }


class ChessAI:
    """
    High-level interface for chess AI functionality.
    """
    
    def __init__(self):
        self.engines = {}
        
    def get_engine(self, difficulty: str) -> ChessEngine:
        """Get or create an engine for the specified difficulty."""
        if difficulty not in self.engines:
            difficulty_enum = DifficultyLevel(difficulty)
            self.engines[difficulty] = ChessEngine(difficulty_enum)
        
        return self.engines[difficulty]
    
    def make_computer_move(self, fen: str, difficulty: str = "medium") -> Dict:
        """
        Make a computer move for the given position.
        
        Args:
            fen: Current board position in FEN notation
            difficulty: AI difficulty level
            
        Returns:
            Dictionary with move information
        """
        try:
            board = chess.Board(fen)
            engine = self.get_engine(difficulty)
            
            start_time = time.time()
            best_move = engine.get_best_move(board)
            search_time = time.time() - start_time
            
            if not best_move:
                return {
                    'success': False,
                    'error': 'No legal moves available'
                }
            
            # Apply the move to get new position
            board.push(best_move)
            
            return {
                'success': True,
                'move': {
                    'from_square': chess.square_name(best_move.from_square),
                    'to_square': chess.square_name(best_move.to_square),
                    'promotion': best_move.promotion.symbol() if best_move.promotion else None,
                    'uci': best_move.uci(),
                    'san': board.san(best_move)
                },
                'new_fen': board.fen(),
                'engine_info': {
                    **engine.get_engine_info(),
                    'search_time': round(search_time, 3)
                },
                'game_status': {
                    'is_checkmate': board.is_checkmate(),
                    'is_stalemate': board.is_stalemate(),
                    'is_check': board.is_check(),
                    'is_game_over': board.is_game_over()
                }
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }


# Global AI instance
chess_ai = ChessAI()


def get_computer_move(fen: str, difficulty: str = "medium") -> Dict:
    """
    Convenient function to get a computer move.
    This is the main interface used by the Django views.
    """
    return chess_ai.make_computer_move(fen, difficulty)


if __name__ == "__main__":
    # Test the engine
    print("🤖 Chess Engine Test")
    print("=" * 40)
    
    # Test different difficulty levels
    test_fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
    
    for difficulty in ["easy", "medium", "hard", "expert"]:
        print(f"\nTesting {difficulty.upper()} difficulty:")
        result = get_computer_move(test_fen, difficulty)
        
        if result['success']:
            move_info = result['move']
            engine_info = result['engine_info']
            
            print(f"Move: {move_info['from_square']} -> {move_info['to_square']}")
            print(f"Search time: {engine_info['search_time']}s")
            print(f"Nodes searched: {engine_info['nodes_searched']}")
        else:
            print(f"Error: {result['error']}")
===== chess-platform/frontend/app.js =====
/**
 * Chess Platform - Main Application Controller
 * Configures routing and initializes the single-page application
 */

class ChessApp {
  constructor() {
    this.router = new ChessRouter();
    this.api = new ChessAPI();
    this.initialized = false;
  }

  // Initialize the application
  async init() {
    if (this.initialized) return;
    
    console.log('Initializing Chess Platform...');
    
    // Configure routes
    this.configureRoutes();
    
    // Initialize router
    await this.router.init();
    
    // Set up global event listeners
    this.setupGlobalEventListeners();
    
    this.initialized = true;
    console.log('Chess Platform initialized successfully');
  }

  // Configure application routes
  configureRoutes() {
    // Public routes (no authentication required)
    this.router.addRoute('/login', {
      title: 'Login - Chess Platform',
      template: 'src/pages/auth/login.html',
      public: true
    });

    this.router.addRoute('/register', {
      title: 'Register - Chess Platform',
      template: 'src/pages/auth/register.html',
      public: true
    });

    // Protected routes (authentication required)
    this.router.addRoute('/lobby', {
      title: 'Lobby - Chess Platform',
      template: 'src/pages/dashboard/lobby.html',
      requiresAuth: true
    });

    this.router.addRoute('/game/:id', {
      title: 'Game - Chess Platform',
      template: 'src/pages/game/play.html',
      requiresAuth: true,
      controller: (params) => {
        console.log('Loading game:', params.id);
      }
    });

    this.router.addRoute('/puzzles', {
      title: 'Puzzles - Chess Platform',
      template: 'src/pages/puzzles/puzzles.html',
      requiresAuth: true
    });

    this.router.addRoute('/profile', {
      title: 'Profile - Chess Platform',
      template: 'src/pages/profile/profile.html',
      requiresAuth: true
    });

    // Default route
    this.router.addRoute('/', {
      title: 'Chess Platform',
      public: true,
      controller: () => {
        // Redirect to appropriate page
        if (this.api.isAuthenticated()) {
          this.router.navigate('/lobby');
        } else {
          this.router.navigate('/login');
        }
      }
    });
  }

  // Set up global event listeners
  setupGlobalEventListeners() {
    // Handle route navigation clicks
    document.addEventListener('click', (e) => {
      const routeLink = e.target.closest('[data-route]');
      if (routeLink) {
        e.preventDefault();
        const route = routeLink.dataset.route;
        this.router.navigate(route);
      }
    });

    // Handle authentication state changes
    window.addEventListener('storage', (e) => {
      if (e.key === 'access') {
        // Token changed - refresh current route to check auth
        this.router.refresh();
      }
    });

    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && this.api.isAuthenticated()) {
        // Page became visible - refresh data
        this.refreshPageData();
      }
    });
  }

  // Refresh current page data
  refreshPageData() {
    const currentRoute = this.router.getCurrentRoute();
    
    // Trigger refresh based on current page
    if (currentRoute === '/lobby') {
      // Trigger lobby refresh if we're on lobby page
      const event = new CustomEvent('refreshLobby');
      window.dispatchEvent(event);
    }
  }

  // Get application instance
  static getInstance() {
    if (!window.chessApp) {
      window.chessApp = new ChessApp();
    }
    return window.chessApp;
  }
}

// Initialize application when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    ChessApp.getInstance().init();
  });
} else {
  ChessApp.getInstance().init();
}

// Make globally available
window.ChessApp = ChessApp;

===== chess-platform/frontend/index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Platform</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/png" href="assets/favicon.jpeg">
</head>
<body>
  <header class="container">
    <h1>Chess Platform</h1>
    <p class="note">Vanilla HTML/CSS/JS talking to Django API</p>
  </header>

  <main class="container grid">
    <section class="card" id="auth">
      <h2>Authentication</h2>

      <div class="stack">
        <h3>Login</h3>
        <form id="loginForm" autocomplete="on">
          <label>
            Username
            <input id="login-username" name="username" required />
          </label>
          <label>
            Password
            <input id="login-password" name="password" type="password" required />
          </label>
          <button type="submit">Login</button>
        </form>
      </div>

      <hr />

      <div class="stack">
        <h3>Register</h3>
        <form id="registerForm" autocomplete="on">
          <label>
            Username
            <input id="register-username" name="username" required />
          </label>
          <label>
            Email
            <input id="register-email" name="email" type="email" />
          </label>
          <label>
            Password
            <input id="register-password" name="password" type="password" required />
          </label>
          <button type="submit">Register</button>
        </form>
      </div>

      <div class="stack">
        <h3>Session</h3>
        <div class="row">
          <button id="btn-logout" type="button">Logout</button>
          <button id="btn-refresh" type="button">Refresh Token</button>
        </div>
        <p><strong>Status:</strong> <span id="auth-status">Signed out</span></p>
      </div>
    </section>

    <section class="card" id="actions">
      <h2>Game Actions</h2>

      <div class="stack">
        <button id="btn-create" type="button">Create New Game (You as White)</button>
      </div>

      <div class="stack">
        <h3>Join a Game</h3>
        <form id="joinForm">
          <label>
            Game ID
            <input id="join-game-id" name="gameId" type="number" required />
          </label>
          <button type="submit">Join as Black</button>
        </form>
      </div>

      <div class="stack">
        <h3>Make a Move</h3>
        <form id="moveForm" autocomplete="off">
          <label>
            Game ID
            <input id="move-game-id" name="gameId" type="number" required />
          </label>
          <label>
            From (e.g., e2)
            <input id="move-from" name="from" maxlength="2" required />
          </label>
          <label>
            To (e.g., e4)
            <input id="move-to" name="to" maxlength="2" required />
          </label>
          <label>
            Promotion (q/r/b/n, optional)
            <input id="move-promo" name="promotion" maxlength="1" />
          </label>
          <button type="submit">Submit Move</button>
        </form>
      </div>

      <div class="stack">
        <h3>Quick Fetch Game</h3>
        <form id="detailsForm" class="row">
          <label>
            Game ID
            <input id="details-game-id" name="gameId" type="number" />
          </label>
          <button type="submit">Fetch</button>
        </form>
      </div>
    </section>

    <section class="card" id="board-card">
      <h2>Board</h2>
      <div id="board-wrapper">
        <div id="chessboard" data-asset-base="assets"></div>

        <aside id="sidebar">
          <div class="stack">
            <h3>Current Game</h3>
            <p><strong>ID:</strong> <span id="current-game-id">—</span></p>
            <p><strong>Status:</strong> <span id="current-game-status">—</span></p>
            <p><strong>Turn:</strong> <span id="current-turn">—</span></p>
          </div>
          <div class="stack">
            <h3>Moves</h3>
            <ol id="move-list" class="move-list"></ol>
          </div>
        </aside>
      </div>
    </section>

    <section class="card" id="games">
      <h2>Available Games</h2>
      <div id="games-list" class="list">Loading…</div>
    </section>

    <section class="card" id="details">
      <h2>Game Details (Raw)</h2>
      <pre id="details-output" class="pre">No game loaded.</pre>
    </section>
  </main>

  <footer class="container">
    <small>© Your Chess Platform</small>
  </footer>

  <script>
    // ================================
    // Globals & API Configuration
    // ================================
    const API_BASE = "http://127.0.0.1:8000/api";
    let accessToken = localStorage.getItem("access");
    let refreshToken = localStorage.getItem("refresh");
    let activeGameId = null;
    
    // ================================
    // DOM Element References
    // ================================
    let elements = {};
    
    // ================================
    // Authentication & Token Helpers
    // ================================
    function saveTokens(access, refresh) {
      accessToken = access;
      refreshToken = refresh;
      localStorage.setItem("access", access);
      localStorage.setItem("refresh", refresh);
      updateAuthUI();
    }
    
    function clearTokens() {
      accessToken = null;
      refreshToken = null;
      localStorage.removeItem("access");
      localStorage.removeItem("refresh");
      updateAuthUI();
    }
    
    function updateAuthUI() {
      if (elements.authStatus) {
        elements.authStatus.textContent = accessToken ? "Signed in" : "Signed out";
      }
    }
    
    async function apiFetch(url, options = {}) {
      options.headers = options.headers || {};
      if (accessToken) {
        options.headers["Authorization"] = `Bearer ${accessToken}`;
      }
    
      let response = await fetch(url, options);
    
      if (response.status === 401 && refreshToken) {
        const refreshed = await refreshAccessToken();
        if (refreshed) {
          options.headers["Authorization"] = `Bearer ${accessToken}`;
          response = await fetch(url, options);
        }
      }
    
      return response;
    }
    
    // ================================
    // API Functions
    // ================================
    async function registerUser(username, email, password) {
      const res = await fetch(`${API_BASE}/auth/register/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, email, password }),
      });
      return { ok: res.ok, data: await res.json() };
    }
    
    async function loginUser(username, password) {
      const res = await fetch(`${API_BASE}/auth/login/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });
      const data = await res.json();
      if (res.ok) {
        saveTokens(data.access, data.refresh);
      }
      return { ok: res.ok, data };
    }
    
    async function refreshAccessToken() {
      if (!refreshToken) return false;
      const res = await fetch(`${API_BASE}/auth/refresh/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refresh: refreshToken }),
      });
      if (res.ok) {
        const data = await res.json();
        saveTokens(data.access, refreshToken);
        return true;
      }
      clearTokens();
      return false;
    }
    
    async function logoutUser() {
      if (refreshToken) {
        await apiFetch(`${API_BASE}/auth/logout/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ refresh: refreshToken }),
        });
      }
      clearTokens();
      alert("You have been logged out.");
    }
    
    async function createGame() {
      const res = await apiFetch(`${API_BASE}/games/create/`, { method: "POST" });
      return { ok: res.ok, data: await res.json() };
    }
    
    async function joinGame(gameId) {
      const res = await apiFetch(`${API_BASE}/games/${gameId}/join/`, { method: "POST" });
      return { ok: res.ok, data: await res.json() };
    }
    
    async function makeMove(gameId, from, to, promotion = null) {
      if (!gameId) {
        console.error("No active game selected.");
        alert("No active game selected. Please create or join a game first!");
        return { ok: false, data: { detail: "No active game selected" } };
      }
    
      const payload = { from_square: from, to_square: to };
      if (promotion) payload.promotion = promotion;
    
      try {
        const res = await apiFetch(`${API_BASE}/games/${gameId}/move/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
    
        const data = await res.json();
        console.log("Move API response:", data);
    
        if (!res.ok) {
          return { ok: false, data };
        }
    
        return { ok: true, data };
      } catch (err) {
        console.error("Network/move error:", err);
        return { ok: false, data: { detail: "Network error" } };
      }
    }
    
    async function getGames() {
      const res = await apiFetch(`${API_BASE}/games/`);
      return { ok: res.ok, data: await res.json() };
    }
    
    async function getGameDetail(gameId) {
      const res = await apiFetch(`${API_BASE}/games/${gameId}/`);
      return { ok: res.ok, data: await res.json() };
    }
    
    // ================================
    // Chessboard Rendering
    // ================================
    function fenCharToAssetChar(ch) {
      const mapping = {
        p: "bP", r: "bR", n: "bN", b: "bB", q: "bQ", k: "bK",
        P: "wP", R: "wR", N: "wN", B: "wB", Q: "wQ", K: "wK",
      };
      return mapping[ch] || "";
    }
    
    function renderBoardFromFen(fen, assetBase = "assets") {
      if (!elements.chessboard) return;
      elements.chessboard.innerHTML = "";
    
      const placement = fen.split(" ")[0];
      const ranks = placement.split("/");
    
      for (let rankIndex = 0; rankIndex < 8; rankIndex++) {
        const rankStr = ranks[rankIndex];
        let fileIndex = 0;
        for (const char of rankStr) {
          if (/\d/.test(char)) {
            const emptySquares = parseInt(char, 10);
            for (let i = 0; i < emptySquares; i++) {
              const square = document.createElement("div");
              const isLight = (rankIndex + fileIndex) % 2 === 0;
              square.className = `square ${isLight ? 'light' : 'dark'}`;
              square.dataset.coord = String.fromCharCode(97 + fileIndex) + (8 - rankIndex);
              elements.chessboard.appendChild(square);
              fileIndex++;
            }
          } else {
            const square = document.createElement("div");
            const isLight = (rankIndex + fileIndex) % 2 === 0;
            square.className = `square ${isLight ? 'light' : 'dark'}`;
            square.dataset.coord = String.fromCharCode(97 + fileIndex) + (8 - rankIndex);
    
            const assetName = fenCharToAssetChar(char);
            if (assetName) {
              const img = document.createElement("img");
              img.src = `${assetBase}/${assetName}.png`;
              img.alt = assetName;
              img.draggable = false;
              square.appendChild(img);
            }
            elements.chessboard.appendChild(square);
            fileIndex++;
          }
        }
      }
    
      // Enable click-to-move after rendering
      enableClickToMove();
    }
    
    // ================================
    // Click-to-Move Support
    // ================================
    let selectedSquare = null;
    
    function enableClickToMove() {
      if (!elements.chessboard) return;
    
      const squares = elements.chessboard.querySelectorAll(".square");
      squares.forEach(square => {
        square.addEventListener("click", async () => {
          const coord = square.dataset.coord;
          
          // Show feedback that square was clicked
          console.log("Clicked square:", coord, "Active game:", activeGameId);
    
          if (!activeGameId) {
            alert("No active game selected. Please create or join a game first!");
            return;
          }
    
          if (!selectedSquare) {
            // First click: select source
            selectedSquare = coord;
            
            // Remove any existing selections
            squares.forEach(sq => sq.classList.remove("selected"));
            square.classList.add("selected");
            
            console.log("Selected square:", selectedSquare);
          } else {
            // Second click: make move
            const from = selectedSquare;
            const to = coord;
    
            // Remove selection highlight
            squares.forEach(sq => sq.classList.remove("selected"));
            selectedSquare = null;
    
            console.log("Making move:", from, "to", to);
    
            // Check for pawn promotion
            let promotion = null;
            const fromRank = parseInt(from[1], 10);
            const toRank = parseInt(to[1], 10);
            if ((fromRank === 7 && toRank === 8) || (fromRank === 2 && toRank === 1)) {
              promotion = prompt("Promote to (q/r/b/n)? Leave empty for queen.", "q") || "q";
            }
    
            const { ok, data } = await makeMove(activeGameId, from, to, promotion);
            if (ok) {
              console.log("Move successful!");
              // Refresh the game state
              await updateGameDetails(activeGameId);
            } else {
              console.error("Move failed:", data);
              alert(`Invalid move: ${data.detail || JSON.stringify(data)}`);
            }
          }
        });
      });
    }
    
    // ================================
    // UI Update Functions
    // ================================
    async function updateGamesList() {
      if (!elements.gamesList) return;
      elements.gamesList.innerHTML = "Loading...";
      const { ok, data } = await getGames();
      if (!ok) {
        elements.gamesList.innerHTML = "Failed to load games. Please log in first.";
        return;
      }
    
      elements.gamesList.innerHTML = "";
      if (data.length === 0) {
        elements.gamesList.innerHTML = "No available games.";
        return;
      }
    
      data.forEach(game => {
        const item = document.createElement("div");
        item.className = "game-item";
        item.innerHTML = `
          <div class="game-meta">
            <span class="players">#${game.id}: ${game.white_player_username || '...'} vs ${game.black_player_username || '...'}</span>
            <span class="status">${game.status}</span>
          </div>
          <div class="row">
            <button class="view-game-btn" data-game-id="${game.id}">View & Play</button>
          </div>
        `;
        elements.gamesList.appendChild(item);
      });
    }
    
    async function updateGameDetails(gameId) {
      const { ok, data: game } = await getGameDetail(gameId);
      if (!ok) {
        alert("Could not fetch game details.");
        return;
      }
    
      if (elements.detailsOutput) {
        elements.detailsOutput.textContent = JSON.stringify(game, null, 2);
      }
    
      if (elements.currentGameId) elements.currentGameId.textContent = game.id;
      activeGameId = game.id; // IMPORTANT: Set the active game
    
      if (elements.currentGameStatus) elements.currentGameStatus.textContent = game.status;
      if (elements.currentTurn) {
        const turn = game.fen.split(" ")[1] === 'w' ? 'White' : 'Black';
        elements.currentTurn.textContent = turn;
      }
    
      if (elements.moveList) {
        elements.moveList.innerHTML = "";
        game.moves.forEach(move => {
          const li = document.createElement("li");
          li.textContent = `${move.move_number}. ${move.notation}`;
          elements.moveList.appendChild(li);
        });
      }
    
      const assetBase = elements.chessboard.dataset.assetBase || "assets";
      renderBoardFromFen(game.fen, assetBase);
      
      console.log("Game loaded:", game.id, "Status:", game.status);
    }
    
    // ================================
    // Event Listeners Setup
    // ================================
    function initializeEventListeners() {
      elements.loginForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const username = elements.loginForm.elements.username.value;
        const password = elements.loginForm.elements.password.value;
        const { ok, data } = await loginUser(username, password);
        if (ok) {
          alert("Login successful!");
          await updateGamesList();
        } else {
          alert(`Login failed: ${JSON.stringify(data)}`);
        }
      });
    
      elements.registerForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const username = elements.registerForm.elements.username.value;
        const email = elements.registerForm.elements.email.value;
        const password = elements.registerForm.elements.password.value;
        const { ok, data } = await registerUser(username, email, password);
        if (ok) {
          alert("Registration successful! Please log in.");
        } else {
          alert(`Registration failed: ${JSON.stringify(data)}`);
        }
      });
    
      elements.btnLogout?.addEventListener("click", logoutUser);
    
      elements.btnRefresh?.addEventListener("click", async () => {
        const success = await refreshAccessToken();
        alert(success ? "Token refreshed." : "Failed to refresh token.");
      });
    
      elements.btnCreate?.addEventListener("click", async () => {
        const { ok, data } = await createGame();
        if (ok) {
          alert(`Game #${data.id} created!`);
          await updateGamesList();
          await updateGameDetails(data.id); // auto-open created game
        } else {
          alert(`Failed to create game: ${JSON.stringify(data)}`);
        }
      });
    
      elements.joinForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const gameId = elements.joinForm.elements.gameId.value;
        const { ok, data } = await joinGame(gameId);
        if (ok) {
          alert(`Successfully joined game #${data.id}`);
          await updateGamesList();
          await updateGameDetails(data.id); // open joined game
        } else {
          alert(`Failed to join game: ${JSON.stringify(data)}`);
        }
      });
    
      elements.moveForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const gameId = elements.moveForm.elements.gameId.value;
        const from = elements.moveForm.elements.from.value;
        const to = elements.moveForm.elements.to.value;
        const promotion = elements.moveForm.elements.promotion.value || null;
    
        const { ok, data } = await makeMove(gameId || activeGameId, from, to, promotion);
        if (ok) {
          alert("Move successful!");
          await updateGameDetails(gameId || activeGameId);
        } else {
          alert(`Invalid move: ${JSON.stringify(data)}`);
        }
      });
    
      elements.detailsForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const gameId = elements.detailsForm.elements.gameId.value;
        if (gameId) {
          await updateGameDetails(gameId);
        }
      });
    
      elements.gamesList?.addEventListener("click", (e) => {
        if (e.target.classList.contains("view-game-btn")) {
          const gameId = e.target.dataset.gameId;
          updateGameDetails(gameId);
        }
      });
    }
    
    // ================================
    // Initial Page Load
    // ================================
    document.addEventListener("DOMContentLoaded", () => {
      elements = {
        authStatus: document.getElementById("auth-status"),
        loginForm: document.getElementById("loginForm"),
        registerForm: document.getElementById("registerForm"),
        btnLogout: document.getElementById("btn-logout"),
        btnRefresh: document.getElementById("btn-refresh"),
        btnCreate: document.getElementById("btn-create"),
        joinForm: document.getElementById("joinForm"),
        moveForm: document.getElementById("moveForm"),
        detailsForm: document.getElementById("detailsForm"),
        gamesList: document.getElementById("games-list"),
        detailsOutput: document.getElementById("details-output"),
        chessboard: document.getElementById("chessboard"),
        currentGameId: document.getElementById("current-game-id"),
        currentGameStatus: document.getElementById("current-game-status"),
        currentTurn: document.getElementById("current-turn"),
        moveList: document.getElementById("move-list"),
      };
    
      initializeEventListeners();
      updateAuthUI();
    
      // Render a default board on load
      const startFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
      const assetBase = elements.chessboard?.dataset.assetBase || "assets";
      renderBoardFromFen(startFen, assetBase);
    
      // Load available games if logged in
      if (accessToken) {
        updateGamesList();
      }
    });
  </script>
</body>
</html>
===== chess-platform/frontend/script.js =====
// ================================
// Globals & API Configuration
// ================================
const API_BASE = "http://127.0.0.1:8000/api";
let accessToken = localStorage.getItem("access");
let refreshToken = localStorage.getItem("refresh");
let activeGameId = null; // track current game globally

// ================================
// DOM Element References
// ================================
let elements = {};

// ================================
// Authentication & Token Helpers
// ================================
function saveTokens(access, refresh) {
  accessToken = access;
  refreshToken = refresh;
  localStorage.setItem("access", access);
  localStorage.setItem("refresh", refresh);
  updateAuthUI();
}

function clearTokens() {
  accessToken = null;
  refreshToken = null;
  localStorage.removeItem("access");
  localStorage.removeItem("refresh");
  updateAuthUI();
}

function updateAuthUI() {
  if (elements.authStatus) {
    elements.authStatus.textContent = accessToken ? "Signed in" : "Signed out";
  }
}

// Generic fetch with JWT auth & auto-refresh
async function apiFetch(url, options = {}) {
  options.headers = options.headers || {};
  if (accessToken) {
    options.headers["Authorization"] = `Bearer ${accessToken}`;
  }

  let response = await fetch(url, options);

  if (response.status === 401 && refreshToken) {
    const refreshed = await refreshAccessToken();
    if (refreshed) {
      options.headers["Authorization"] = `Bearer ${accessToken}`;
      response = await fetch(url, options);
    }
  }

  return response;
}

// ================================
// API Functions
// ================================
async function registerUser(username, email, password) {
  const res = await fetch(`${API_BASE}/auth/register/`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username, email, password }),
  });
  return { ok: res.ok, data: await res.json() };
}

async function loginUser(username, password) {
  const res = await fetch(`${API_BASE}/auth/login/`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username, password }),
  });
  const data = await res.json();
  if (res.ok) {
    saveTokens(data.access, data.refresh);
  }
  return { ok: res.ok, data };
}

async function refreshAccessToken() {
  if (!refreshToken) return false;
  const res = await fetch(`${API_BASE}/auth/refresh/`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ refresh: refreshToken }),
  });
  if (res.ok) {
    const data = await res.json();
    saveTokens(data.access, refreshToken);
    return true;
  }
  clearTokens();
  return false;
}

async function logoutUser() {
  if (refreshToken) {
    await apiFetch(`${API_BASE}/auth/logout/`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ refresh: refreshToken }),
    });
  }
  clearTokens();
  alert("You have been logged out.");
}

async function createGame() {
  const res = await apiFetch(`${API_BASE}/games/create/`, { method: "POST" });
  return { ok: res.ok, data: await res.json() };
}

async function joinGame(gameId) {
  const res = await apiFetch(`${API_BASE}/games/${gameId}/join/`, { method: "POST" });
  return { ok: res.ok, data: await res.json() };
}
// Add this debug version to your script.js or replace the makeMove function

async function makeMove(gameId, from, to, promotion = null) {
  console.log("=== MAKING MOVE ===");
  console.log("Game ID:", gameId);
  console.log("From:", from, "To:", to);
  console.log("Promotion:", promotion);
  console.log("Access Token:", accessToken ? "Present" : "Missing");

  if (!gameId) {
    console.error("No active game selected.");
    alert("No active game selected. Please create or join a game first!");
    return { ok: false, data: { detail: "No active game selected" } };
  }

  const payload = { from_square: from, to_square: to };
  if (promotion) payload.promotion = promotion;
  
  console.log("Payload:", JSON.stringify(payload));
  
  const url = `${API_BASE}/games/${gameId}/move/`;
  console.log("URL:", url);

  try {
    const headers = {
      "Content-Type": "application/json",
    };
    
    if (accessToken) {
      headers["Authorization"] = `Bearer ${accessToken}`;
    }
    
    console.log("Headers:", headers);
    
    const res = await fetch(url, {
      method: "POST",
      headers: headers,
      body: JSON.stringify(payload),
    });

    console.log("Response status:", res.status);
    console.log("Response headers:", res.headers);
    
    const data = await res.json();
    console.log("Response data:", data);

    if (!res.ok) {
      console.error("Move failed:", data);
      return { ok: false, data };
    }

    console.log("Move successful!");
    return { ok: true, data };
  } catch (err) {
    console.error("Network/move error:", err);
    return { ok: false, data: { detail: "Network error: " + err.message } };
  }
}

// Also add this debug function to test moves manually
function testMove() {
  console.log("Testing move e2 to e4...");
  makeMove(activeGameId, "e2", "e4").then(result => {
    console.log("Test move result:", result);
  });
}

// Add this to window for manual testing in console
window.testMove = testMove;
window.debugMakeMove = makeMove;
async function getGames() {
  const res = await apiFetch(`${API_BASE}/games/`);
  return { ok: res.ok, data: await res.json() };
}

async function getGameDetail(gameId) {
  const res = await apiFetch(`${API_BASE}/games/${gameId}/`);
  return { ok: res.ok, data: await res.json() };
}

// ================================
// Chessboard Rendering
// ================================
function fenCharToAssetChar(ch) {
  const mapping = {
    p: "bP", r: "bR", n: "bN", b: "bB", q: "bQ", k: "bK",
    P: "wP", R: "wR", N: "wN", B: "wB", Q: "wQ", K: "wK",
  };
  return mapping[ch] || "";
}

function renderBoardFromFen(fen, assetBase = "./assets") {
  if (!elements.chessboard) return;
  elements.chessboard.innerHTML = "";

  const placement = fen.split(" ")[0];
  const ranks = placement.split("/");

  for (let rankIndex = 0; rankIndex < 8; rankIndex++) {
    const rankStr = ranks[rankIndex];
    let fileIndex = 0;
    for (const char of rankStr) {
      if (/\d/.test(char)) {
        const emptySquares = parseInt(char, 10);
        for (let i = 0; i < emptySquares; i++) {
          const square = document.createElement("div");
          const isLight = (rankIndex + fileIndex) % 2 === 0;
          square.className = `square ${isLight ? 'light' : 'dark'}`;
          square.dataset.coord = String.fromCharCode(97 + fileIndex) + (8 - rankIndex);
          elements.chessboard.appendChild(square);
          fileIndex++;
        }
      } else {
        const square = document.createElement("div");
        const isLight = (rankIndex + fileIndex) % 2 === 0;
        square.className = `square ${isLight ? 'light' : 'dark'}`;
        square.dataset.coord = String.fromCharCode(97 + fileIndex) + (8 - rankIndex);

        const assetName = fenCharToAssetChar(char);
        if (assetName) {
          const img = document.createElement("img");
          img.src = `${assetBase}/${assetName}.png`;
          img.alt = assetName;
          img.draggable = false;
          square.appendChild(img);
        }
        elements.chessboard.appendChild(square);
        fileIndex++;
      }
    }
  }

  // Enable click-to-move after rendering
  enableClickToMove();
}

// ================================
// Click-to-Move Support
// ================================
let selectedSquare = null;

function enableClickToMove() {
  if (!elements.chessboard) return;

  const squares = elements.chessboard.querySelectorAll(".square");
  squares.forEach(square => {
    square.addEventListener("click", async () => {
      const coord = square.dataset.coord;

      if (!activeGameId) {
        alert("No active game selected.");
        return;
      }

      if (!selectedSquare) {
        // First click: select source
        selectedSquare = coord;
        square.classList.add("selected");
      } else {
        // Second click: make move
        const from = selectedSquare;
        const to = coord;

        // Remove selection highlight
        const prevSquare = [...squares].find(sq => sq.dataset.coord === from);
        prevSquare?.classList.remove("selected");
        selectedSquare = null;

        // (optional) quick promotion prompt if pawn moves to last rank
        let promotion = null;
        const fromRank = parseInt(from[1], 10);
        const toRank = parseInt(to[1], 10);
        if (fromRank === 7 && toRank === 8) {
          // white pawn promotion
          promotion = prompt("Promote to (q/r/b/n)? Leave empty for queen.", "q") || "q";
        }
        if (fromRank === 2 && toRank === 1) {
          // black pawn promotion
          promotion = prompt("Promote to (q/r/b/n)? Leave empty for queen.", "q") || "q";
        }

        const { ok, data } = await makeMove(activeGameId, from, to, promotion);
        if (ok) {
          // refresh full game (ensures FEN, move list, turn)
          await updateGameDetails(activeGameId);
        } else {
          alert(`Invalid move: ${JSON.stringify(data)}`);
        }
      }
    });
  });
}

// ================================
// UI Update Functions
// ================================
async function updateGamesList() {
  if (!elements.gamesList) return;
  elements.gamesList.innerHTML = "Loading...";
  const { ok, data } = await getGames();
  if (!ok) {
    elements.gamesList.innerHTML = "Failed to load games. Are you logged in?";
    return;
  }

  elements.gamesList.innerHTML = "";
  if (data.length === 0) {
    elements.gamesList.innerHTML = "No available games.";
    return;
  }

  data.forEach(game => {
    const item = document.createElement("div");
    item.className = "game-item";
    item.innerHTML = `
      <div class="game-meta">
        <span class="players">#${game.id}: ${game.white_player_username || '...'} vs ${game.black_player_username || '...'}</span>
        <span class="status">${game.status}</span>
      </div>
      <div class="row">
        <button class="view-game-btn" data-game-id="${game.id}">View</button>
      </div>
    `;
    elements.gamesList.appendChild(item);
  });
}

// kept (as requested) but now delegates to makeMove()
async function sendMove(from, to, promotion = null) {
  if (!activeGameId) {
    alert("No active game selected.");
    return;
  }

  const result = await makeMove(activeGameId, from, to, promotion);
  if (!result.ok) {
    alert("Invalid move: " + JSON.stringify(result.data));
    return;
  }
  await updateGameDetails(activeGameId);
}

async function updateGameDetails(gameId) {
  const { ok, data: game } = await getGameDetail(gameId);
  if (!ok) {
    alert("Could not fetch game details.");
    return;
  }

  if (elements.detailsOutput) {
    elements.detailsOutput.textContent = JSON.stringify(game, null, 2);
  }

  if (elements.currentGameId) elements.currentGameId.textContent = game.id;
  activeGameId = game.id; // track current active game

  if (elements.currentGameStatus) elements.currentGameStatus.textContent = game.status;
  if (elements.currentTurn) elements.currentTurn.textContent = game.fen.split(" ")[1] === 'w' ? 'White' : 'Black';

  if (elements.moveList) {
    elements.moveList.innerHTML = "";
    game.moves.forEach(move => {
      const li = document.createElement("li");
      li.textContent = `${move.move_number}. ${move.notation}`;
      elements.moveList.appendChild(li);
    });
  }

  const assetBase = elements.chessboard.dataset.assetBase || "./assets";
  renderBoardFromFen(game.fen, assetBase);
}

// ================================
// Event Listeners Setup
// ================================
function initializeEventListeners() {
  elements.loginForm?.addEventListener("submit", async (e) => {
    e.preventDefault();
    const username = elements.loginForm.elements.username.value;
    const password = elements.loginForm.elements.password.value;
    const { ok, data } = await loginUser(username, password);
    if (ok) {
      alert("Login successful!");
      await updateGamesList();
    } else {
      alert(`Login failed: ${JSON.stringify(data)}`);
    }
  });

  elements.registerForm?.addEventListener("submit", async (e) => {
    e.preventDefault();
    const username = elements.registerForm.elements.username.value;
    const email = elements.registerForm.elements.email.value;
    const password = elements.registerForm.elements.password.value;
    const { ok, data } = await registerUser(username, email, password);
    if (ok) {
      alert("Registration successful! Please log in.");
    } else {
      alert(`Registration failed: ${JSON.stringify(data)}`);
    }
  });

  elements.btnLogout?.addEventListener("click", logoutUser);

  elements.btnRefresh?.addEventListener("click", async () => {
    const success = await refreshAccessToken();
    alert(success ? "Token refreshed." : "Failed to refresh token.");
  });

  elements.btnCreate?.addEventListener("click", async () => {
    const { ok, data } = await createGame();
    if (ok) {
      alert(`Game #${data.id} created!`);
      await updateGamesList();
      await updateGameDetails(data.id); // auto-open created game
    } else {
      alert(`Failed to create game: ${JSON.stringify(data)}`);
    }
  });

  elements.joinForm?.addEventListener("submit", async (e) => {
    e.preventDefault();
    const gameId = elements.joinForm.elements.gameId.value;
    const { ok, data } = await joinGame(gameId);
    if (ok) {
      alert(`Successfully joined game #${data.id}`);
      await updateGamesList();
      await updateGameDetails(data.id); // open joined game
    } else {
      alert(`Failed to join game: ${JSON.stringify(data)}`);
    }
  });

  elements.moveForm?.addEventListener("submit", async (e) => {
    e.preventDefault();
    const gameId = elements.moveForm.elements.gameId.value;
    const from = elements.moveForm.elements.from.value;
    const to = elements.moveForm.elements.to.value;
    const promotion = elements.moveForm.elements.promotion.value || null;

    const { ok, data } = await makeMove(gameId || activeGameId, from, to, promotion);
    if (ok) {
      alert("Move successful!");
      await updateGameDetails(gameId || activeGameId);
    } else {
      alert(`Invalid move: ${JSON.stringify(data)}`);
    }
  });

  elements.detailsForm?.addEventListener("submit", async (e) => {
    e.preventDefault();
    const gameId = elements.detailsForm.elements.gameId.value;
    if (gameId) {
      await updateGameDetails(gameId);
    }
  });

  elements.gamesList?.addEventListener("click", (e) => {
    if (e.target.classList.contains("view-game-btn")) {
      const gameId = e.target.dataset.gameId;
      updateGameDetails(gameId); // set activeGameId as well
    }
  });
}

// ================================
// Initial Page Load
// ================================
document.addEventListener("DOMContentLoaded", () => {
  elements = {
    authStatus: document.getElementById("auth-status"),
    loginForm: document.getElementById("loginForm"),
    registerForm: document.getElementById("registerForm"),
    btnLogout: document.getElementById("btn-logout"),
    btnRefresh: document.getElementById("btn-refresh"),
    btnCreate: document.getElementById("btn-create"),
    joinForm: document.getElementById("joinForm"),
    moveForm: document.getElementById("moveForm"),
    detailsForm: document.getElementById("detailsForm"),
    gamesList: document.getElementById("games-list"),
    detailsOutput: document.getElementById("details-output"),
    chessboard: document.getElementById("chessboard"),
    currentGameId: document.getElementById("current-game-id"),
    currentGameStatus: document.getElementById("current-game-status"),
    currentTurn: document.getElementById("current-turn"),
    moveList: document.getElementById("move-list"),
  };

  initializeEventListeners();
  updateAuthUI();

  // Render a default board on load
  const startFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
  const assetBase = elements.chessboard?.dataset.assetBase || "./assets";
  renderBoardFromFen(startFen, assetBase);

  // Load available games (requires login)
  updateGamesList();
});
===== chess-platform/frontend/style.css =====
/* style.css — Clean professional UI for Chess Platform */

/* ========================
   Variables & Reset
   ======================== */
:root{
  --bg: #0b1220;
  --bg-2: #0f172a;
  --card: #0f172a;
  --muted: #94a3b8;
  --text: #e6eef8;
  --accent: #60a5fa;       /* primary accent (blue) */
  --accent-strong: #3b82f6;
  --glass: rgba(255,255,255,0.03);
  --card-border: rgba(255,255,255,0.04);
  --shadow: 0 8px 30px rgba(2,6,23,0.7);
  --radius-lg: 16px;
  --radius-md: 10px;
  --radius-sm: 8px;
  --gap: 1rem;
  --max-width: 1100px;
  --board-max: 560px;
  --muted-2: #64748b;
}

*,
*::before,
*::after { box-sizing: border-box; }

html,body{
  height: 100%;
  margin: 0;
  background: linear-gradient(180deg, var(--bg) 0%, var(--bg-2) 100%);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  font-size: 16px;
  line-height: 1.4;
}

/* ========================
   Layout / Container
   ======================== */
.container{
  max-width: var(--max-width);
  margin: 0 auto;
  padding: 1.25rem;
}

header.container {
  padding-top: 1.5rem;
  padding-bottom: 0.5rem;
}

header h1 {
  margin: 0;
  font-size: 1.5rem;
  letter-spacing: -0.5px;
  color: var(--text);
}

.note {
  color: var(--muted);
  margin-top: 0.25rem;
  font-size: 0.95rem;
}

/* Main grid */
.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 1rem;
  align-items: start;
  margin-top: 1rem;
}

/* Collapse to single column on small screens */
@media (max-width: 980px) {
  .grid { grid-template-columns: 1fr 1fr; }
}
@media (max-width: 720px) {
  .grid { grid-template-columns: 1fr; }
}

/* ========================
   Cards / UI primitives
   ======================== */
.card {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border: 1px solid var(--card-border);
  border-radius: var(--radius-lg);
  padding: 1rem;
  box-shadow: var(--shadow);
}

h2 { margin: 0 0 0.5rem 0; font-size: 1.05rem; }
h3 { margin: 0; font-size: 0.95rem; color: var(--muted-2); }
hr { border: none; border-top: 1px solid rgba(255,255,255,0.03); margin: 0.8rem 0; }
.stack > * + * { margin-top: 0.6rem; }
.row { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }

/* forms */
label { display: block; font-size: 0.95rem; color: var(--muted); }
input[type="text"],
input[type="password"],
input[type="email"],
input[type="number"] {
  width: 100%;
  padding: 0.55rem 0.7rem;
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255,255,255,0.04);
  background: rgba(255,255,255,0.02);
  color: var(--text);
  outline: none;
  transition: box-shadow .12s ease, border-color .12s ease;
  font-size: 0.95rem;
}
input:focus {
  box-shadow: 0 4px 18px rgba(59,130,246,0.12);
  border-color: var(--accent-strong);
}

/* buttons */
button {
  display: inline-flex;
  gap: .5rem;
  align-items: center;
  justify-content: center;
  padding: 0.55rem 0.9rem;
  border-radius: 10px;
  font-weight: 600;
  font-size: 0.95rem;
  color: white;
  background: linear-gradient(180deg, var(--accent), var(--accent-strong));
  border: 1px solid rgba(255,255,255,0.06);
  cursor: pointer;
  transition: transform .06s ease, box-shadow .08s ease, opacity .08s ease;
  box-shadow: 0 8px 20px rgba(59,130,246,0.08);
}
button:hover { transform: translateY(-1px); }
button:active { transform: translateY(0); }
button[disabled] { opacity: .6; cursor: default; transform: none; }
#auth-status { font-weight: 600; color: var(--muted); }

/* ========================
   Games list / details
   ======================== */
.list { display: grid; gap: 0.5rem; }
.game-item {
  display: flex;
  justify-content: space-between;
  gap: 0.5rem;
  align-items: center;
  padding: 0.6rem;
  border-radius: var(--radius-sm);
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));
  border: 1px solid rgba(255,255,255,0.02);
}
.game-meta { display: flex; gap: 0.6rem; align-items: baseline; }
.game-meta .players { font-size: 0.95rem; color: var(--text); }
.game-meta .status { font-size: 0.84rem; color: var(--muted); }
.pre {
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.03);
  padding: 0.75rem;
  border-radius: 8px;
  overflow: auto;
  color: var(--muted);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
}

/* ========================
   Board + Sidebar
   ======================== */
#board-wrapper {
  display: grid;
  grid-template-columns: minmax(0, 1fr) 240px; /* Adjusted sidebar width */
  gap: 1rem;
  align-items: start;
}
@media (max-width: 980px) {
  #board-wrapper { grid-template-columns: 1fr; }
}

#chessboard {
  width: min(var(--board-max), 86vw);
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  border-radius: 10px;
  overflow: hidden;
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
  box-shadow: 0 12px 30px rgba(2,6,23,0.6);
  border: 1px solid rgba(255,255,255,0.03);
  /* >>> ADDED: This is the key fix to make the board visible */
  aspect-ratio: 1 / 1;
  /* <<< ADDED */
}
.square.selected {
  outline: 3px solid yellow;
}

.square {
  position: relative;
  aspect-ratio: 1 / 1; /* Each square is also a square */
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}
.square.light { background-color: #f0d9b5; }
.square.dark  { background-color: #b58863; }
.square img {
  width: 78%;
  height: 78%;
  object-fit: contain;
  pointer-events: none;
  -webkit-user-drag: none;
  user-select: none;
}

/* ========================
   Sidebar: current game + moves
   ======================== */
#sidebar {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 0.5rem;
  border-radius: var(--radius-md);
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
  border: 1px solid rgba(255,255,255,0.03);
  max-height: calc(var(--board-max) + 20px); /* Syncs with board height */
  overflow: auto;
}
.move-list {
  list-style: none;
  margin: 0;
  padding: 0;
  color: var(--muted);
  display: grid;
  gap: 0.35rem;
}
.move-list li {
  padding: 0.35rem 0.5rem;
  border-radius: 8px;
  background: rgba(255,255,255,0.01);
  font-family: ui-monospace, SFMono-Regular, Menlo, "Roboto Mono", monospace;
  font-size: 0.92rem;
}
.move-list li:nth-child(odd) { background: rgba(255,255,255,0.008); }

/* ========================
   Footer
   ======================== */
footer.container {
  margin-top: 1.2rem;
  text-align: center;
  color: var(--muted);
  font-size: 0.9rem;
}
===== chess-platform/frontend/public/index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Professional Chess Platform - Play chess online with rating system">
  <meta name="keywords" content="chess, online chess, chess platform, chess games, rating">
  <title>Chess Platform</title>
  
  <!-- Preload critical resources -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="../src/assets/images/favicon.png">
  
  <!-- Global Styles -->
  <link rel="stylesheet" href="../src/styles/global.css">
  
  <style>
    /* App container styles */
    #app {
      min-height: 100vh;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    
    #app.loaded {
      opacity: 1;
    }
    
    /* Initial loading screen */
    .initial-loader {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      transition: opacity 0.5s ease-out;
    }
    
    .initial-loader.hide {
      opacity: 0;
      pointer-events: none;
    }
    
    .loader-logo {
      font-size: var(--font-size-4xl);
      font-weight: var(--font-weight-bold);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--space-xl);
      animation: pulse 2s ease-in-out infinite;
    }
    
    .loader-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(118, 150, 86, 0.2);
      border-top: 3px solid var(--color-accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: var(--space-lg);
    }
    
    .loader-text {
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
      text-align: center;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Page loader (for navigation) */
    .page-loader {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease-in-out;
    }
    
    .page-loader.show {
      opacity: 1;
      visibility: visible;
    }
    
    .page-loader .loader-spinner {
      width: 32px;
      height: 32px;
      border-width: 2px;
    }
    
    /* Error state */
    .error-page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: var(--space-lg);
    }
    
    .error-icon {
      font-size: 4rem;
      color: var(--color-error);
      margin-bottom: var(--space-lg);
    }
    
    .error-title {
      font-size: var(--font-size-2xl);
      margin-bottom: var(--space-md);
    }
    
    .error-message {
      color: var(--color-text-muted);
      margin-bottom: var(--space-xl);
    }
    
    /* Offline indicator */
    .offline-indicator {
      position: fixed;
      bottom: var(--space-lg);
      left: 50%;
      transform: translateX(-50%);
      background: var(--color-error);
      color: white;
      padding: var(--space-sm) var(--space-lg);
      border-radius: var(--radius-full);
      font-size: var(--font-size-sm);
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease-in-out;
    }
    
    .offline-indicator.show {
      opacity: 1;
      visibility: visible;
    }
    
    /* Responsive adjustments */
    @media (max-width: 480px) {
      .loader-logo {
        font-size: var(--font-size-3xl);
      }
    }
  </style>
</head>
<body>
  <!-- Initial Loading Screen -->
  <div id="initialLoader" class="initial-loader">
    <h1 class="loader-logo">Chess Platform</h1>
    <div class="loader-spinner"></div>
    <p class="loader-text">Loading your chess experience...</p>
  </div>
  
  <!-- Page Navigation Loader -->
  <div id="pageLoader" class="page-loader">
    <div class="loader-spinner"></div>
  </div>
  
  <!-- Offline Indicator -->
  <div id="offlineIndicator" class="offline-indicator">
    You're currently offline. Some features may not work.
  </div>
  
  <!-- Main Application Container -->
  <div id="app" role="main">
    <!-- Content will be dynamically loaded here -->
    <div class="error-page">
      <div class="error-icon">⚠️</div>
      <h1 class="error-title">Loading...</h1>
      <p class="error-message">Please wait while we set up your chess platform.</p>
    </div>
  </div>

  <!-- Core Scripts -->
  <script src="../src/utils/router.js"></script>
  <script src="../src/utils/api.js"></script>
  
  <script>
    // Application initialization
    class ChessApp {
      constructor() {
        this.initialized = false;
        this.routes = {};
        this.init();
      }
      
      async init() {
        try {
          // Show initial loader
          this.showInitialLoader();
          
          // Register routes
          this.registerRoutes();
          
          // Check browser compatibility
          if (!this.checkCompatibility()) {
            this.showError('Your browser is not supported. Please use a modern browser.');
            return;
          }
          
          // Set up offline detection
          this.setupOfflineDetection();
          
          // Initialize router
          await this.initializeRouter();
          
          // Mark as initialized
          this.initialized = true;
          
          // Hide initial loader and show app
          this.hideInitialLoader();
          
          console.log('Chess Platform initialized successfully');
          
        } catch (error) {
          console.error('Failed to initialize Chess Platform:', error);
          this.showError('Failed to load the application. Please refresh the page.');
        }
      }
      
      registerRoutes() {
        // Authentication routes
        router.addRoute('/login', {
          title: 'Login - Chess Platform',
          template: '../src/pages/auth/login.html',
          controller: this.loginController,
          public: true
        });
        
        router.addRoute('/register', {
          title: 'Register - Chess Platform', 
          template: '../src/pages/auth/register.html',
          controller: this.registerController,
          public: true
        });
        
        // Main application routes
        router.addRoute('/lobby', {
          title: 'Lobby - Chess Platform',
          template: '../src/pages/dashboard/lobby.html',
          controller: this.lobbyController,
          requiresAuth: true
        });
        
        router.addRoute('/game/:id', {
          title: 'Game - Chess Platform',
          template: '../src/pages/game/play.html',
          controller: this.gameController,
          requiresAuth: true
        });
        
        router.addRoute('/profile', {
          title: 'Profile - Chess Platform',
          template: '../src/pages/profile/profile.html',
          controller: this.profileController,
          requiresAuth: true
        });
        
        // Future routes
        router.addRoute('/puzzles', {
          title: 'Puzzles - Chess Platform',
          template: '../src/pages/puzzles/puzzles.html',
          controller: this.puzzlesController,
          requiresAuth: true
        });
      }
      
      async initializeRouter() {
        // Override router's loadPage method to integrate with our app
        const originalLoadPage = router.loadPage.bind(router);
        
        router.loadPage = async (route) => {
          try {
            this.showPageLoader();
            await originalLoadPage(route);
            this.hidePageLoader();
          } catch (error) {
            this.hidePageLoader();
            throw error;
          }
        };
        
        // Set up router event handlers
        router.showLoading = () => this.showPageLoader();
        router.hideLoading = () => this.hidePageLoader();
      }
      
      // Route Controllers
      async loginController() {
        // Login page specific initialization
        const script = document.createElement('script');
        script.src = '../src/pages/auth/login.js';
        document.head.appendChild(script);
      }
      
      async registerController() {
        // Register page specific initialization  
        const script = document.createElement('script');
        script.src = '../src/pages/auth/register.js';
        document.head.appendChild(script);
      }
      
      async lobbyController() {
        // Lobby page specific initialization
        const script = document.createElement('script');
        script.src = '../src/pages/dashboard/lobby.js';
        document.head.appendChild(script);
      }
      
      async gameController() {
        // Game page specific initialization
        const script = document.createElement('script');
        script.src = '../src/pages/game/game.js';
        document.head.appendChild(script);
      }
      
      async profileController() {
        // Profile page specific initialization
        const script = document.createElement('script');
        script.src = '../src/pages/profile/profile.js';
        document.head.appendChild(script);
      }
      
      async puzzlesController() {
        // Puzzles page specific initialization
        const script = document.createElement('script');
        script.src = '../src/pages/puzzles/puzzles.js';
        document.head.appendChild(script);
      }
      
      checkCompatibility() {
        // Check for required features
        const required = [
          'fetch',
          'Promise',
          'localStorage',
          'addEventListener'
        ];
        
        return required.every(feature => {
          return feature in window || feature in window.constructor.prototype;
        });
      }
      
      setupOfflineDetection() {
        const offlineIndicator = document.getElementById('offlineIndicator');
        
        const showOffline = () => {
          offlineIndicator.classList.add('show');
        };
        
        const hideOffline = () => {
          offlineIndicator.classList.remove('show');
        };
        
        window.addEventListener('online', hideOffline);
        window.addEventListener('offline', showOffline);
        
        // Check initial state
        if (!navigator.onLine) {
          showOffline();
        }
      }
      
      showInitialLoader() {
        const loader = document.getElementById('initialLoader');
        if (loader) {
          loader.classList.remove('hide');
        }
      }
      
      hideInitialLoader() {
        const loader = document.getElementById('initialLoader');
        const app = document.getElementById('app');
        
        if (loader && app) {
          loader.classList.add('hide');
          app.classList.add('loaded');
          
          // Remove loader after animation
          setTimeout(() => {
            loader.style.display = 'none';
          }, 500);
        }
      }
      
      showPageLoader() {
        const loader = document.getElementById('pageLoader');
        if (loader) {
          loader.classList.add('show');
        }
      }
      
      hidePageLoader() {
        const loader = document.getElementById('pageLoader');
        if (loader) {
          loader.classList.remove('show');
        }
      }
      
      showError(message) {
        const app = document.getElementById('app');
        if (app) {
          app.innerHTML = `
            <div class="error-page">
              <div class="error-icon">⚠️</div>
              <h1 class="error-title">Oops! Something went wrong</h1>
              <p class="error-message">${message}</p>
              <button class="btn btn-primary" onclick="location.reload()">
                Refresh Page
              </button>
            </div>
          `;
          app.classList.add('loaded');
        }
        this.hideInitialLoader();
      }
      
      // Public methods for external access
      isInitialized() {
        return this.initialized;
      }
      
      // Global error handler
      setupGlobalErrorHandling() {
        window.addEventListener('error', (event) => {
          console.error('Global error:', event.error);
          api.showError('An unexpected error occurred');
        });
        
        window.addEventListener('unhandledrejection', (event) => {
          console.error('Unhandled promise rejection:', event.reason);
          api.showError('An unexpected error occurred');
        });
      }
    }
    
    // Global app instance
    let app;
    
    // Initialize app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        app = new ChessApp();
      });
    } else {
      app = new ChessApp();
    }
    
    // Make app available globally
    window.chessApp = app;
    
    // Service worker registration (for future PWA features)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('ServiceWorker registration successful');
          })
          .catch(error => {
            console.log('ServiceWorker registration failed');
          });
      });
    }
  </script>
</body>
</html>
===== chess-platform/frontend/public/manifest.json =====

===== chess-platform/frontend/src/components/chess-board/animations.css =====

===== chess-platform/frontend/src/components/chess-board/board.css =====

===== chess-platform/frontend/src/components/chess-board/board.js =====

===== chess-platform/frontend/src/components/chess-board/pieces.js =====

===== chess-platform/frontend/src/components/game-timer/timer.css =====

===== chess-platform/frontend/src/components/game-timer/timer.js =====

===== chess-platform/frontend/src/components/sidebar/sidebar.css =====

===== chess-platform/frontend/src/components/sidebar/sidebar.html =====

===== chess-platform/frontend/src/components/sidebar/sidebar.js =====

===== chess-platform/frontend/src/components/user-card/user-card.css =====

===== chess-platform/frontend/src/components/user-card/user-card.js =====

===== chess-platform/frontend/src/pages/auth/auth.css =====

===== chess-platform/frontend/src/pages/auth/forgot-password.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forgot Password - Chess Platform</title>
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Page-specific styles for forgot password */
    .auth-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: 
        radial-gradient(ellipse at top, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      padding: var(--space-lg);
    }

    .auth-card {
      width: 100%;
      max-width: 400px;
      padding: var(--space-2xl);
      position: relative;
      overflow: hidden;
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-xl);
    }

    .auth-header {
      text-align: center;
      margin-bottom: var(--space-xl);
    }

    .auth-logo {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-primary);
      margin-bottom: var(--space-md);
    }

    .auth-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }

    .auth-subtitle {
      font-size: var(--font-size-md);
      color: var(--color-text-secondary);
      line-height: 1.5;
      margin-bottom: var(--space-lg);
    }

    .form-group {
      margin-bottom: var(--space-lg);
    }

    .form-group label {
      display: block;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-primary);
      margin-bottom: var(--space-xs);
    }

    .form-group input {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-base);
      color: var(--color-text-primary);
      background: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      outline: none;
      transition: all 0.2s ease;
    }

    .form-group input:focus {
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(118, 150, 86, 0.1);
    }

    .btn-primary {
      width: 100%;
      padding: var(--space-md) var(--space-lg);
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
      color: white;
      background: var(--color-primary);
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .btn-primary:hover {
      background: var(--color-primary-dark);
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-primary:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .auth-links {
      text-align: center;
      margin-top: var(--space-lg);
    }

    .auth-links a {
      color: var(--color-primary);
      text-decoration: none;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      transition: color 0.2s ease;
    }

    .auth-links a:hover {
      color: var(--color-primary-dark);
      text-decoration: underline;
    }

    .success-message {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: var(--color-success);
      padding: var(--space-md);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-lg);
      font-size: var(--font-size-sm);
      text-align: center;
    }

    .error-message {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--color-error);
      padding: var(--space-md);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-lg);
      font-size: var(--font-size-sm);
      text-align: center;
    }

    .btn-spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top: 2px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .auth-container {
      padding: var(--space-md);
      min-height: 100vh;
      min-height: 100dvh; /* Dynamic viewport height for mobile */
    }
    
    .auth-card {
      padding: var(--space-lg);
      max-width: 100%;
      width: 100%;
      margin: 0;
      border-radius: var(--radius-lg);
    }

    .auth-logo {
      font-size: var(--font-size-xl);
      margin-bottom: var(--space-md);
    }

    .auth-title {
      font-size: var(--font-size-lg);
      margin-bottom: var(--space-sm);
    }

    .auth-subtitle {
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-lg);
    }

    .form-group {
      margin-bottom: var(--space-md);
    }

    .form-group label {
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-xs);
    }

    .form-group input {
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
    }

    .btn-primary {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
      margin: var(--space-lg) 0;
    }

    .auth-links {
      text-align: center;
      font-size: var(--font-size-sm);
    }

    .auth-links a {
      color: var(--color-primary);
      padding: var(--space-sm);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .auth-container {
        padding: var(--space-lg);
      }
      
      .auth-card {
        padding: var(--space-xl);
        max-width: 450px;
      }

      .auth-logo {
        font-size: var(--font-size-2xl);
      }

      .auth-title {
        font-size: var(--font-size-xl);
      }

      .auth-subtitle {
        font-size: var(--font-size-md);
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .auth-container {
        padding: var(--space-xl);
      }
      
      .auth-card {
        padding: var(--space-2xl);
        max-width: 500px;
      }
    }

    /* Desktop styles (1025px and up) */
    @media (min-width: 1025px) {
      .auth-card {
        max-width: 400px;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .form-group input {
        padding: var(--space-lg);
        font-size: 16px; /* Prevent zoom on iOS */
      }

      .btn-primary {
        padding: var(--space-lg);
      }

      .auth-links a {
        padding: var(--space-md);
        margin: var(--space-xs);
      }

      /* Enhanced focus states for touch */
      .form-group input:focus {
        border-width: 2px;
        outline: 2px solid var(--color-primary);
        outline-offset: 2px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="auth-container">
      <div class="auth-card glass-card fade-in">
        <div class="auth-header">
          <h1 class="auth-logo">Chess Platform</h1>
          <h2 class="auth-title">Forgot Password?</h2>
          <p class="auth-subtitle">No worries! Enter your email address and we'll send you a reset link.</p>
        </div>

        <div id="successMessage" class="success-message" style="display: none;">
          We've sent a password reset link to your email address. Please check your inbox and follow the instructions.
        </div>

        <div id="errorMessage" class="error-message" style="display: none;">
          <!-- Error message will be displayed here -->
        </div>

        <form id="forgotPasswordForm">
          <div class="form-group">
            <label for="email">Email Address</label>
            <input type="email" id="email" name="email" required placeholder="Enter your email address">
          </div>

          <button type="submit" class="btn-primary" id="submitBtn">
            <span id="submitText">Send Reset Link</span>
            <div class="btn-spinner" id="submitSpinner"></div>
          </button>
        </form>

        <div class="auth-links">
          <p>Remember your password? <a href="#" data-route="/auth/login">Back to Login</a></p>
        </div>
      </div>
    </div>
  </div>

  <script src="../../utils/router.js"></script>
  <script src="../../utils/api.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const form = document.getElementById('forgotPasswordForm');
      const submitBtn = document.getElementById('submitBtn');
      const submitText = document.getElementById('submitText');
      const submitSpinner = document.getElementById('submitSpinner');
      const errorMessage = document.getElementById('errorMessage');
      const successMessage = document.getElementById('successMessage');

      form.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const email = document.getElementById('email').value.trim();
        
        // Basic validation
        if (!email) {
          showError('Please enter your email address.');
          return;
        }

        if (!isValidEmail(email)) {
          showError('Please enter a valid email address.');
          return;
        }

        try {
          // Show loading state
          setLoading(true);
          hideMessages();

          // Make API call (implement this endpoint in your backend)
          const response = await fetch('/api/auth/forgot-password/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ email })
          });

          const data = await response.json();

          if (response.ok) {
            showSuccess();
            form.reset();
          } else {
            showError(data.error || 'Failed to send reset link. Please try again.');
          }
        } catch (error) {
          console.error('Forgot password error:', error);
          showError('Network error. Please check your connection and try again.');
        } finally {
          setLoading(false);
        }
      });

      function setLoading(isLoading) {
        submitBtn.disabled = isLoading;
        if (isLoading) {
          submitText.style.opacity = '0';
          submitSpinner.style.display = 'block';
        } else {
          submitText.style.opacity = '1';
          submitSpinner.style.display = 'none';
        }
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';
        successMessage.style.display = 'none';
      }

      function showSuccess() {
        successMessage.style.display = 'block';
        errorMessage.style.display = 'none';
      }

      function hideMessages() {
        errorMessage.style.display = 'none';
        successMessage.style.display = 'none';
      }

      function isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }

      // Initialize router for navigation
      initializeRouter();
    });
  </script>
</body>
</html>

===== chess-platform/frontend/src/pages/auth/login.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Login - Chess Platform</title>
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Page-specific styles for login */
    .auth-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: 
        radial-gradient(ellipse at top, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      padding: var(--space-lg);
    }

    .auth-card {
      width: 100%;
      max-width: 400px;
      padding: var(--space-2xl);
      position: relative;
      overflow: hidden;
    }

    .auth-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--color-accent-primary), transparent);
    }

    .auth-header {
      text-align: center;
      margin-bottom: var(--space-2xl);
    }

    .auth-logo {
      font-size: var(--font-size-4xl);
      font-weight: var(--font-weight-bold);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--space-sm);
      display: block;
    }

    .auth-subtitle {
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
      margin-bottom: 0;
    }

    .auth-form {
      gap: var(--space-lg) 0;
    }

    .form-group {
      position: relative;
      margin-bottom: var(--space-lg);
    }

    .form-input {
      width: 100%;
      padding: var(--space-md) var(--space-md);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      transition: all var(--transition-normal);
      position: relative;
    }

    .form-input:focus {
      border-color: var(--color-accent-primary);
      box-shadow: 0 0 0 3px rgba(118, 150, 86, 0.1);
      background: rgba(255, 255, 255, 0.05);
    }

    .form-input::placeholder {
      color: var(--color-text-muted);
      transition: opacity var(--transition-normal);
    }

    .form-input:focus::placeholder {
      opacity: 0.7;
    }

    .auth-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      margin-top: var(--space-xl);
    }

    .login-btn {
      position: relative;
      overflow: hidden;
    }

    .login-btn:hover::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: shine 0.6s ease-in-out;
    }

    @keyframes shine {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .auth-divider {
      display: flex;
      align-items: center;
      margin: var(--space-xl) 0;
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
    }

    .auth-divider::before,
    .auth-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--color-border);
    }

    .auth-divider span {
      padding: 0 var(--space-md);
    }

    .auth-link {
      text-align: center;
      margin-top: var(--space-lg);
    }

    .auth-link a {
      color: var(--color-accent-primary);
      text-decoration: none;
      font-weight: var(--font-weight-medium);
      transition: color var(--transition-fast);
    }

    .auth-link a:hover {
      color: var(--color-accent-light);
      text-decoration: underline;
    }

    .error-message {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--color-error);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-md);
      display: none;
    }

    .error-message.show {
      display: block;
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Loading state */
    .loading .login-btn {
      pointer-events: none;
    }

    .loading .btn-text {
      opacity: 0;
    }

    .loading .btn-spinner {
      display: block;
    }

    .btn-spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* Chess piece decorations */
    .chess-decoration {
      position: absolute;
      opacity: 0.1;
      font-size: 120px;
      color: var(--color-accent-primary);
      pointer-events: none;
      user-select: none;
    }

    .chess-decoration.king {
      top: 10%;
      right: 10%;
      animation: float 6s ease-in-out infinite;
    }

    .chess-decoration.queen {
      bottom: 15%;
      left: 15%;
      animation: float 8s ease-in-out infinite reverse;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .auth-container {
      padding: var(--space-md);
      min-height: 100vh;
      min-height: 100dvh; /* Dynamic viewport height for mobile */
    }
    
    .auth-card {
      padding: var(--space-lg);
      max-width: 100%;
      width: 100%;
      margin: 0;
      border-radius: var(--radius-lg);
    }

    .auth-logo {
      font-size: var(--font-size-xl);
      margin-bottom: var(--space-md);
    }

    .auth-title {
      font-size: var(--font-size-lg);
      margin-bottom: var(--space-sm);
    }

    .auth-subtitle {
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-lg);
    }

    .form-group {
      margin-bottom: var(--space-md);
    }

    .form-group label {
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-xs);
    }

    .form-group input {
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
    }

    .btn-primary {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
      margin: var(--space-lg) 0;
    }

    .auth-links {
      text-align: center;
      font-size: var(--font-size-sm);
    }

    .auth-links a {
      color: var(--color-primary);
      padding: var(--space-sm);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .chess-decoration {
      display: none; /* Hide decorations on mobile */
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .auth-container {
        padding: var(--space-lg);
      }
      
      .auth-card {
        padding: var(--space-xl);
        max-width: 450px;
      }

      .auth-logo {
        font-size: var(--font-size-2xl);
      }

      .auth-title {
        font-size: var(--font-size-xl);
      }

      .auth-subtitle {
        font-size: var(--font-size-md);
      }

      .chess-decoration {
        display: block;
        opacity: 0.3;
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .auth-container {
        padding: var(--space-xl);
      }
      
      .auth-card {
        padding: var(--space-2xl);
        max-width: 500px;
      }

      .chess-decoration {
        opacity: 0.5;
      }
    }

    /* Desktop styles (1025px and up) */
    @media (min-width: 1025px) {
      .auth-card {
        max-width: 400px;
      }

      .chess-decoration {
        opacity: 0.7;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .form-group input {
        padding: var(--space-lg);
        font-size: 16px; /* Prevent zoom on iOS */
      }

      .btn-primary {
        padding: var(--space-lg);
      }

      .auth-links a {
        padding: var(--space-md);
        margin: var(--space-xs);
      }

      /* Enhanced focus states for touch */
      .form-group input:focus {
        border-width: 2px;
        outline: 2px solid var(--color-primary);
        outline-offset: 2px;
      }
    }
  </style>
</head>
<body>
  <!-- Page Loader -->
  <div id="page-loader" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 10, 10, 0.9); display: flex; align-items: center; justify-content: center; z-index: 9999;">
    <div class="btn-spinner" style="display: block; position: static; transform: none; width: 40px; height: 40px; border-width: 3px;"></div>
  </div>

  <!-- Main App Container -->
  <div id="app">
    <div class="auth-container">
      <!-- Chess Decorations -->
      <div class="chess-decoration king">♔</div>
      <div class="chess-decoration queen">♕</div>

      <div class="auth-card glass-card fade-in">
        <div class="auth-header">
          <h1 class="auth-logo">Chess Platform</h1>
          <p class="auth-subtitle">Welcome back! Please sign in to continue.</p>
        </div>

        <div id="error-container" class="error-message">
          <span id="error-text"></span>
        </div>

        <form id="loginForm" class="auth-form">
          <div class="form-group">
            <input 
              type="text" 
              id="username" 
              name="username" 
              class="form-input" 
              placeholder="Username" 
              required 
              autocomplete="username"
              autofocus
            >
          </div>

          <div class="form-group">
            <input 
              type="password" 
              id="password" 
              name="password" 
              class="form-input" 
              placeholder="Password" 
              required 
              autocomplete="current-password"
            >
          </div>

          <div class="auth-actions">
            <button type="submit" class="btn btn-primary btn-full login-btn">
              <span class="btn-text">Sign In</span>
              <div class="btn-spinner"></div>
            </button>
          </div>
        </form>

        <div class="auth-divider">
          <span>New to Chess Platform?</span>
        </div>

        <div class="auth-link">
          <a href="/register/">Create an account</a>
        </div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="../../utils/router.js"></script>
  <script src="../../utils/api.js"></script>
  
  <script>
    // Login page controller
    function initLoginPage() {
      const form = document.getElementById('loginForm');
      const errorContainer = document.getElementById('error-container');
      const errorText = document.getElementById('error-text');
      const loginBtn = document.querySelector('.login-btn');
      
      // Clear any existing errors
      hideError();

      // Handle form submission
      form.addEventListener('submit', handleLogin);

      // Handle input changes (clear errors)
      const inputs = form.querySelectorAll('input');
      inputs.forEach(input => {
        input.addEventListener('input', hideError);
      });

      async function handleLogin(e) {
        e.preventDefault();
        
        const formData = new FormData(form);
        const username = formData.get('username').trim();
        const password = formData.get('password');

        // Validate inputs
        if (!username || !password) {
          showError('Please fill in all fields');
          return;
        }

        // Show loading state
        setLoading(true);
        hideError();

        try {
          const response = await api.login(username, password);
          
          if (response.ok) {
            // Login successful
            api.showSuccess('Welcome back!');
            
            // Redirect to lobby after short delay
            setTimeout(() => {
              window.location.href = '/lobby/';
            }, 500);
          } else {
            // Login failed
            showError(api.formatError(response));
          }
        } catch (error) {
          console.error('Login error:', error);
          showError('Connection failed. Please try again.');
        } finally {
          setLoading(false);
        }
      }

      function showError(message) {
        errorText.textContent = message;
        errorContainer.classList.add('show');
      }

      function hideError() {
        errorContainer.classList.remove('show');
      }

      function setLoading(loading) {
        if (loading) {
          document.body.classList.add('loading');
          loginBtn.disabled = true;
        } else {
          document.body.classList.remove('loading');
          loginBtn.disabled = false;
        }
      }

      // Focus first input
      setTimeout(() => {
        document.getElementById('username').focus();
      }, 100);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initLoginPage);
    } else {
      initLoginPage();
    }
  </script>
</body>
</html>
===== chess-platform/frontend/src/pages/auth/register.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Register - Chess Platform</title>
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Page-specific styles for registration - matching login design */
    .auth-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: 
        radial-gradient(ellipse at top, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      padding: var(--space-lg);
    }

    .auth-card {
      width: 100%;
      max-width: 420px;
      padding: var(--space-2xl);
      position: relative;
      overflow: hidden;
    }

    .auth-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--color-accent-primary), transparent);
    }

    .auth-header {
      text-align: center;
      margin-bottom: var(--space-2xl);
    }

    .auth-logo {
      font-size: var(--font-size-4xl);
      font-weight: var(--font-weight-bold);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--space-sm);
      display: block;
    }

    .auth-subtitle {
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
      margin-bottom: 0;
    }

    .auth-form {
      gap: var(--space-lg) 0;
    }

    .form-group {
      position: relative;
      margin-bottom: var(--space-lg);
    }

    .form-input {
      width: 100%;
      padding: var(--space-md) var(--space-md);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      transition: all var(--transition-normal);
      position: relative;
    }

    .form-input:focus {
      border-color: var(--color-accent-primary);
      box-shadow: 0 0 0 3px rgba(118, 150, 86, 0.1);
      background: rgba(255, 255, 255, 0.05);
    }

    .form-input::placeholder {
      color: var(--color-text-muted);
      transition: opacity var(--transition-normal);
    }

    .form-input:focus::placeholder {
      opacity: 0.7;
    }

    .form-input.error {
      border-color: var(--color-error);
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
    }

    .form-input.success {
      border-color: var(--color-success);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
    }

    .field-error {
      color: var(--color-error);
      font-size: var(--font-size-xs);
      margin-top: var(--space-xs);
      display: none;
      opacity: 0;
      transform: translateY(-5px);
      transition: all var(--transition-normal);
    }

    .field-error.show {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }

    .password-strength {
      margin-top: var(--space-xs);
      font-size: var(--font-size-xs);
    }

    .strength-meter {
      height: 4px;
      background: var(--color-border);
      border-radius: 2px;
      margin-top: var(--space-xs);
      overflow: hidden;
    }

    .strength-fill {
      height: 100%;
      border-radius: 2px;
      transition: all var(--transition-normal);
      width: 0%;
    }

    .strength-weak .strength-fill {
      background: var(--color-error);
      width: 25%;
    }

    .strength-fair .strength-fill {
      background: var(--color-warning);
      width: 50%;
    }

    .strength-good .strength-fill {
      background: var(--color-info);
      width: 75%;
    }

    .strength-strong .strength-fill {
      background: var(--color-success);
      width: 100%;
    }

    .strength-text {
      color: var(--color-text-muted);
      margin-top: var(--space-xs);
    }

    .auth-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      margin-top: var(--space-xl);
    }

    .register-btn {
      position: relative;
      overflow: hidden;
    }

    .register-btn:hover::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: shine 0.6s ease-in-out;
    }

    @keyframes shine {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .auth-divider {
      display: flex;
      align-items: center;
      margin: var(--space-xl) 0;
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
    }

    .auth-divider::before,
    .auth-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--color-border);
    }

    .auth-divider span {
      padding: 0 var(--space-md);
    }

    .auth-link {
      text-align: center;
      margin-top: var(--space-lg);
    }

    .auth-link a {
      color: var(--color-accent-primary);
      text-decoration: none;
      font-weight: var(--font-weight-medium);
      transition: color var(--transition-fast);
    }

    .auth-link a:hover {
      color: var(--color-accent-light);
      text-decoration: underline;
    }

    .error-message {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--color-error);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-md);
      display: none;
    }

    .error-message.show {
      display: block;
      animation: slideDown 0.3s ease-out;
    }

    .success-message {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: var(--color-success);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-md);
      display: none;
    }

    .success-message.show {
      display: block;
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Loading state */
    .loading .register-btn {
      pointer-events: none;
    }

    .loading .btn-text {
      opacity: 0;
    }

    .loading .btn-spinner {
      display: block;
    }

    .btn-spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* Chess piece decorations */
    .chess-decoration {
      position: absolute;
      opacity: 0.1;
      font-size: 120px;
      color: var(--color-accent-primary);
      pointer-events: none;
      user-select: none;
    }

    .chess-decoration.knight {
      top: 5%;
      right: 5%;
      animation: float 7s ease-in-out infinite;
    }

    .chess-decoration.bishop {
      bottom: 10%;
      left: 10%;
      animation: float 9s ease-in-out infinite reverse;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
    }

    /* Terms and privacy links */
    .terms-text {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
      text-align: center;
      margin-top: var(--space-md);
      line-height: 1.5;
    }

    .terms-text a {
      color: var(--color-accent-primary);
      text-decoration: none;
    }

    .terms-text a:hover {
      text-decoration: underline;
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .auth-container {
      padding: var(--space-md);
      min-height: 100vh;
      min-height: 100dvh; /* Dynamic viewport height for mobile */
    }
    
    .auth-card {
      padding: var(--space-lg);
      max-width: 100%;
      width: 100%;
      margin: 0;
      border-radius: var(--radius-lg);
    }

    .auth-logo {
      font-size: var(--font-size-xl);
      margin-bottom: var(--space-md);
    }

    .auth-subtitle {
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-lg);
    }

    .form-group {
      margin-bottom: var(--space-md);
    }

    .form-group label {
      font-size: var(--font-size-sm);
      margin-bottom: var(--space-xs);
    }

    .form-group input {
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
    }

    .form-row {
      flex-direction: column;
      gap: var(--space-md);
    }

    .btn-primary {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
      margin: var(--space-lg) 0;
    }

    .auth-links {
      text-align: center;
      font-size: var(--font-size-sm);
    }

    .auth-links a {
      color: var(--color-primary);
      padding: var(--space-sm);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .chess-decoration {
      display: none; /* Hide decorations on mobile */
    }

    .password-requirements {
      margin-top: var(--space-sm);
      padding: var(--space-md);
      border-radius: var(--radius-md);
      font-size: var(--font-size-xs);
    }

    .requirement {
      padding: var(--space-xs) 0;
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .error-message {
      font-size: var(--font-size-xs);
      margin-top: var(--space-xs);
      padding: var(--space-sm);
      border-radius: var(--radius-sm);
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .auth-container {
        padding: var(--space-lg);
      }
      
      .auth-card {
        padding: var(--space-xl);
        max-width: 500px;
      }

      .auth-logo {
        font-size: var(--font-size-2xl);
      }

      .auth-subtitle {
        font-size: var(--font-size-md);
      }

      .form-row {
        flex-direction: row;
        gap: var(--space-md);
      }

      .form-row .form-group {
        flex: 1;
      }

      .chess-decoration {
        display: block;
        opacity: 0.3;
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .auth-container {
        padding: var(--space-xl);
      }
      
      .auth-card {
        padding: var(--space-2xl);
        max-width: 550px;
      }

      .chess-decoration {
        opacity: 0.5;
      }
    }

    /* Desktop styles (1025px and up) */
    @media (min-width: 1025px) {
      .auth-card {
        max-width: 480px;
      }

      .chess-decoration {
        opacity: 0.7;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .form-group input {
        padding: var(--space-lg);
        font-size: 16px; /* Prevent zoom on iOS */
      }

      .btn-primary {
        padding: var(--space-lg);
      }

      .auth-links a {
        padding: var(--space-md);
        margin: var(--space-xs);
      }

      /* Enhanced focus states for touch */
      .form-group input:focus {
        border-width: 2px;
        outline: 2px solid var(--color-primary);
        outline-offset: 2px;
      }

      /* Better visibility for password requirements on touch */
      .password-requirements {
        padding: var(--space-lg);
      }

      .requirement {
        padding: var(--space-sm) 0;
        font-size: var(--font-size-sm);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="auth-container">
      <!-- Chess Decorations -->
      <div class="chess-decoration knight">♘</div>
      <div class="chess-decoration bishop">♗</div>

      <div class="auth-card glass-card fade-in">
        <div class="auth-header">
          <h1 class="auth-logo">Chess Platform</h1>
          <p class="auth-subtitle">Create your account and start playing chess!</p>
        </div>

        <div id="error-container" class="error-message">
          <span id="error-text"></span>
        </div>

        <div id="success-container" class="success-message">
          <span id="success-text"></span>
        </div>

        <form id="registerForm" class="auth-form">
          <div class="form-group">
            <input 
              type="text" 
              id="username" 
              name="username" 
              class="form-input" 
              placeholder="Username (3-20 characters)" 
              required 
              autocomplete="username"
              minlength="3"
              maxlength="20"
              autofocus
            >
            <div class="field-error" id="username-error"></div>
          </div>

          <div class="form-group">
            <input 
              type="email" 
              id="email" 
              name="email" 
              class="form-input" 
              placeholder="Email address" 
              required 
              autocomplete="email"
            >
            <div class="field-error" id="email-error"></div>
          </div>

          <div class="form-group">
            <input 
              type="password" 
              id="password" 
              name="password" 
              class="form-input" 
              placeholder="Password (minimum 8 characters)" 
              required 
              autocomplete="new-password"
              minlength="8"
            >
            <div class="password-strength">
              <div class="strength-meter">
                <div class="strength-fill"></div>
              </div>
              <div class="strength-text">Password strength: <span id="strength-label">Enter password</span></div>
            </div>
            <div class="field-error" id="password-error"></div>
          </div>

          <div class="form-group">
            <input 
              type="password" 
              id="confirmPassword" 
              name="confirmPassword" 
              class="form-input" 
              placeholder="Confirm password" 
              required 
              autocomplete="new-password"
            >
            <div class="field-error" id="confirm-password-error"></div>
          </div>

          <div class="auth-actions">
            <button type="submit" class="btn btn-primary btn-full register-btn">
              <span class="btn-text">Create Account</span>
              <div class="btn-spinner"></div>
            </button>
          </div>

          <div class="terms-text">
            By creating an account, you agree to our 
            <a href="#" data-route="/terms">Terms of Service</a> and 
            <a href="#" data-route="/privacy">Privacy Policy</a>.
          </div>
        </form>

        <div class="auth-divider">
          <span>Already have an account?</span>
        </div>

        <div class="auth-link">
          <a href="../auth/login.html">Sign in here</a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Registration page controller
    function initRegisterPage() {
      const form = document.getElementById('registerForm');
      const errorContainer = document.getElementById('error-container');
      const successContainer = document.getElementById('success-container');
      const errorText = document.getElementById('error-text');
      const successText = document.getElementById('success-text');
      const registerBtn = document.querySelector('.register-btn');
      
      // Form inputs
      const usernameInput = document.getElementById('username');
      const emailInput = document.getElementById('email');
      const passwordInput = document.getElementById('password');
      const confirmPasswordInput = document.getElementById('confirmPassword');
      
      // Error elements
      const usernameError = document.getElementById('username-error');
      const emailError = document.getElementById('email-error');
      const passwordError = document.getElementById('password-error');
      const confirmPasswordError = document.getElementById('confirm-password-error');
      
      // Password strength elements
      const strengthMeter = document.querySelector('.strength-meter');
      const strengthLabel = document.getElementById('strength-label');
      
      // Clear any existing messages
      hideError();
      hideSuccess();

      // Set up form validation
      setupValidation();
      
      // Handle form submission
      form.addEventListener('submit', handleRegister);

      function setupValidation() {
        // Username validation
        usernameInput.addEventListener('input', validateUsername);
        usernameInput.addEventListener('blur', validateUsername);
        
        // Email validation
        emailInput.addEventListener('input', validateEmail);
        emailInput.addEventListener('blur', validateEmail);
        
        // Password validation and strength meter
        passwordInput.addEventListener('input', () => {
          validatePassword();
          checkPasswordStrength();
        });
        passwordInput.addEventListener('blur', validatePassword);
        
        // Confirm password validation
        confirmPasswordInput.addEventListener('input', validateConfirmPassword);
        confirmPasswordInput.addEventListener('blur', validateConfirmPassword);
        
        // Clear global errors on input
        const inputs = [usernameInput, emailInput, passwordInput, confirmPasswordInput];
        inputs.forEach(input => {
          input.addEventListener('input', () => {
            hideError();
            hideSuccess();
          });
        });
      }

      function validateUsername() {
        const username = usernameInput.value.trim();
        const isValid = username.length >= 3 && username.length <= 20 && /^[a-zA-Z0-9_]+$/.test(username);
        
        if (!username) {
          showFieldError(usernameInput, usernameError, '');
          return false;
        } else if (!isValid) {
          showFieldError(usernameInput, usernameError, 'Username must be 3-20 characters and contain only letters, numbers, and underscores');
          return false;
        } else {
          showFieldSuccess(usernameInput, usernameError);
          return true;
        }
      }

      function validateEmail() {
        const email = emailInput.value.trim();
        const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        
        if (!email) {
          showFieldError(emailInput, emailError, '');
          return false;
        } else if (!isValid) {
          showFieldError(emailInput, emailError, 'Please enter a valid email address');
          return false;
        } else {
          showFieldSuccess(emailInput, emailError);
          return true;
        }
      }

      function validatePassword() {
        const password = passwordInput.value;
        
        if (!password) {
          showFieldError(passwordInput, passwordError, '');
          return false;
        } else if (password.length < 8) {
          showFieldError(passwordInput, passwordError, 'Password must be at least 8 characters long');
          return false;
        } else {
          showFieldSuccess(passwordInput, passwordError);
          return true;
        }
      }

      function validateConfirmPassword() {
        const password = passwordInput.value;
        const confirmPassword = confirmPasswordInput.value;
        
        if (!confirmPassword) {
          showFieldError(confirmPasswordInput, confirmPasswordError, '');
          return false;
        } else if (password !== confirmPassword) {
          showFieldError(confirmPasswordInput, confirmPasswordError, 'Passwords do not match');
          return false;
        } else {
          showFieldSuccess(confirmPasswordInput, confirmPasswordError);
          return true;
        }
      }

      function checkPasswordStrength() {
        const password = passwordInput.value;
        let score = 0;
        let label = 'Enter password';
        
        if (password.length === 0) {
          strengthMeter.className = 'strength-meter';
        } else {
          // Calculate strength score
          if (password.length >= 8) score += 1;
          if (password.length >= 12) score += 1;
          if (/[a-z]/.test(password) && /[A-Z]/.test(password)) score += 1;
          if (/\d/.test(password)) score += 1;
          if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) score += 1;
          
          // Update UI based on score
          if (score <= 2) {
            strengthMeter.className = 'strength-meter strength-weak';
            label = 'Weak';
          } else if (score <= 3) {
            strengthMeter.className = 'strength-meter strength-fair';
            label = 'Fair';
          } else if (score <= 4) {
            strengthMeter.className = 'strength-meter strength-good';
            label = 'Good';
          } else {
            strengthMeter.className = 'strength-meter strength-strong';
            label = 'Strong';
          }
        }
        
        strengthLabel.textContent = label;
      }

      function showFieldError(input, errorElement, message) {
        input.classList.remove('success');
        input.classList.add('error');
        errorElement.textContent = message;
        if (message) {
          errorElement.classList.add('show');
        } else {
          errorElement.classList.remove('show');
        }
      }

      function showFieldSuccess(input, errorElement) {
        input.classList.remove('error');
        input.classList.add('success');
        errorElement.classList.remove('show');
      }

      async function handleRegister(e) {
        e.preventDefault();
        
        // Validate all fields
        const isUsernameValid = validateUsername();
        const isEmailValid = validateEmail();
        const isPasswordValid = validatePassword();
        const isConfirmPasswordValid = validateConfirmPassword();
        
        if (!isUsernameValid || !isEmailValid || !isPasswordValid || !isConfirmPasswordValid) {
          showError('Please fix the errors above');
          return;
        }

        const formData = new FormData(form);
        const userData = {
          username: formData.get('username').trim(),
          email: formData.get('email').trim(),
          password: formData.get('password')
        };

        // Show loading state
        setLoading(true);
        hideError();
        hideSuccess();

        try {
          const response = await api.register(userData);
          
          if (response.ok) {
            // Registration successful
            showSuccess('Account created successfully! You can now sign in.');
            form.reset();
            
            // Clear field states
            const inputs = [usernameInput, emailInput, passwordInput, confirmPasswordInput];
            inputs.forEach(input => {
              input.classList.remove('success', 'error');
            });
            
            // Reset password strength meter
            strengthMeter.className = 'strength-meter';
            strengthLabel.textContent = 'Enter password';
            
            // Redirect to login after delay
            setTimeout(() => {
              window.location.href = '../auth/login.html';
            }, 2000);
          } else {
            // Registration failed
            showError(api.formatError(response));
          }
        } catch (error) {
          console.error('Registration error:', error);
          showError('Connection failed. Please try again.');
        } finally {
          setLoading(false);
        }
      }

      function showError(message) {
        errorText.textContent = message;
        errorContainer.classList.add('show');
      }

      function hideError() {
        errorContainer.classList.remove('show');
      }

      function showSuccess(message) {
        successText.textContent = message;
        successContainer.classList.add('show');
      }

      function hideSuccess() {
        successContainer.classList.remove('show');
      }

      function setLoading(loading) {
        if (loading) {
          document.body.classList.add('loading');
          registerBtn.disabled = true;
        } else {
          document.body.classList.remove('loading');
          registerBtn.disabled = false;
        }
      }

      // Focus first input
      setTimeout(() => {
        usernameInput.focus();
      }, 100);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initRegisterPage);
    } else {
      initRegisterPage();
    }
  </script>
</body>
</html>
===== chess-platform/frontend/src/pages/dashboard/lobby.css =====

===== chess-platform/frontend/src/pages/dashboard/lobby.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lobby - Chess Platform</title>
  <link rel="stylesheet" href="../../styles/global.css">
  <script src="../../utils/api.js"></script>
  <script src="../../utils/router.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Lobby-specific styles maintaining design consistency with login/register */
    .lobby-container {
      display: flex;
      min-height: 100vh;
      background: 
        radial-gradient(ellipse at top left, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
    }

    /* Sidebar Navigation - Matching our design system */
    .sidebar {
      width: var(--sidebar-width);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-right: 1px solid var(--glass-border);
      display: flex;
      flex-direction: column;
      position: fixed;
      height: 100vh;
      left: 0;
      top: 0;
      z-index: 100;
      overflow-y: auto;
    }

    .sidebar-header {
      padding: var(--space-xl) var(--space-lg);
      border-bottom: 1px solid var(--glass-border);
    }

    .sidebar-logo {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--space-xs);
    }

    .sidebar-subtitle {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
    }

    .sidebar-nav {
      flex: 1;
      padding: var(--space-lg);
    }

    .nav-section {
      margin-bottom: var(--space-xl);
    }

    .nav-section-title {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-sm);
    }

    .nav-items {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      transition: all var(--transition-normal);
      cursor: pointer;
    }

    .nav-item:hover {
      background: rgba(118, 150, 86, 0.1);
      color: var(--color-accent-primary);
      transform: translateX(2px);
    }

    .nav-item.active {
      background: rgba(118, 150, 86, 0.15);
      color: var(--color-accent-primary);
      border: 1px solid rgba(118, 150, 86, 0.2);
    }

    .nav-icon {
      font-size: var(--font-size-lg);
      width: 20px;
      text-align: center;
    }

    /* User Profile in Sidebar */
    .sidebar-footer {
      padding: var(--space-lg);
      border-top: 1px solid var(--glass-border);
    }

    .user-profile {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-md);
      border-radius: var(--radius-lg);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .user-profile:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
    }

    .user-info {
      flex: 1;
      min-width: 0;
    }

    .user-name {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-sm);
      color: var(--color-text-primary);
      margin-bottom: var(--space-xs);
    }

    .user-rating {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
    }

    .rating-badge {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
      font-weight: var(--font-weight-medium);
    }

    /* Main Content */
    .main-content {
      flex: 1;
      margin-left: var(--sidebar-width);
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      height: var(--header-height);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-xl);
      position: sticky;
      top: 0;
      z-index: 90;
    }

    .header-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
    }

    .header-subtitle {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      margin-top: var(--space-xs);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: var(--radius-full);
      background: var(--color-success);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Content Area */
    .content {
      flex: 1;
      padding: var(--space-xl);
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: var(--space-xl);
      align-items: start;
    }

    .content-main {
      display: flex;
      flex-direction: column;
      gap: var(--space-xl);
    }

    .content-sidebar {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    /* Quick Actions Section */
    .quick-actions {
      padding: var(--space-xl);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
    }

    .section-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-lg);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .section-icon {
      font-size: var(--font-size-xl);
    }

    .action-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-lg);
    }

    .action-card {
      padding: var(--space-xl);
      border-radius: var(--radius-lg);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      text-align: center;
      cursor: pointer;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }

    .action-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      border-color: var(--color-accent-primary);
      background: rgba(255, 255, 255, 0.05);
    }

    .action-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--color-accent-primary), var(--color-accent-light));
      opacity: 0;
      transition: opacity var(--transition-normal);
    }

    .action-card:hover::before {
      opacity: 1;
    }

    .action-icon {
      font-size: 2.5rem;
      margin-bottom: var(--space-md);
      display: block;
    }

    .action-card.quick-play .action-icon {
      color: var(--color-accent-primary);
    }

    .action-card.create-game .action-icon {
      color: var(--color-info);
    }

    .action-card.join-game .action-icon {
      color: var(--color-warning);
    }

    .action-card.puzzles .action-icon {
      color: #8b5cf6;
    }

    .action-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }

    .action-description {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      line-height: 1.4;
    }

    /* Active Games Section */
    .games-section {
      padding: var(--space-xl);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
    }

    .games-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .game-card {
      display: flex;
      align-items: center;
      gap: var(--space-lg);
      padding: var(--space-lg);
      border-radius: var(--radius-lg);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all var(--transition-normal);
      cursor: pointer;
    }

    .game-card:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
      border-color: rgba(118, 150, 86, 0.3);
      background: rgba(255, 255, 255, 0.04);
    }

    .game-players {
      flex: 1;
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .player-info {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .player-avatar {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-sm);
    }

    .player-name {
      font-weight: var(--font-weight-medium);
      color: var(--color-text-primary);
    }

    .player-rating {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
      background: rgba(118, 150, 86, 0.1);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
    }

    .vs-divider {
      color: var(--color-text-muted);
      font-weight: var(--font-weight-bold);
    }

    .game-status {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-xs);
    }

    .status-badge {
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
    }

    .status-waiting {
      background: rgba(251, 191, 36, 0.2);
      color: #f59e0b;
    }

    .status-active {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .status-finished {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .game-time {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
    }

    /* Statistics Panel */
    .stats-panel {
      padding: var(--space-lg);
      border-radius: var(--radius-lg);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-md);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-lg);
      margin-top: var(--space-md);
    }

    .stat-item {
      text-align: center;
      padding: var(--space-md);
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-value {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-accent-primary);
      margin-bottom: var(--space-xs);
    }

    .stat-label {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Online Players Panel */
    .online-players {
      padding: var(--space-lg);
      border-radius: var(--radius-lg);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-md);
    }

    .players-list {
      max-height: 300px;
      overflow-y: auto;
      margin-top: var(--space-md);
    }

    .player-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm);
      border-radius: var(--radius-md);
      transition: background var(--transition-fast);
    }

    .player-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .player-status {
      width: 8px;
      height: 8px;
      border-radius: var(--radius-full);
      background: var(--color-success);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: var(--space-3xl) var(--space-xl);
      color: var(--color-text-muted);
    }

    .empty-icon {
      font-size: 3rem;
      margin-bottom: var(--space-lg);
      opacity: 0.5;
    }

    .empty-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-sm);
      color: var(--color-text-secondary);
    }

    .empty-description {
      font-size: var(--font-size-sm);
      line-height: 1.5;
    }

    /* Loading States */
    .loading-skeleton {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.03) 25%, rgba(255, 255, 255, 0.08) 50%, rgba(255, 255, 255, 0.03) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: var(--radius-md);
      height: 60px;
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    /* ================================
       Mobile Menu Button
       ================================ */
    .mobile-menu-btn {
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 44px;
      height: 44px;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: var(--radius-md);
      transition: all var(--transition-normal);
    }

    .hamburger-line {
      width: 22px;
      height: 2px;
      background: var(--color-text-primary);
      margin: 2px 0;
      border-radius: 2px;
      transition: all var(--transition-normal);
    }

    .mobile-menu-btn:hover {
      background: var(--color-bg-hover);
    }

    .mobile-menu-btn.active .hamburger-line:nth-child(1) {
      transform: rotate(45deg) translate(5px, 5px);
    }

    .mobile-menu-btn.active .hamburger-line:nth-child(2) {
      opacity: 0;
    }

    .mobile-menu-btn.active .hamburger-line:nth-child(3) {
      transform: rotate(-45deg) translate(7px, -6px);
    }

    /* Mobile Overlay */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.5);
      z-index: 99;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .mobile-overlay.active {
      display: block;
    }

    /* ================================
       Responsive Design - Mobile First
       ================================ */

    /* Large screens (desktops) */
    @media (min-width: 1024px) {
      .content {
        grid-template-columns: 2fr 1fr;
        gap: var(--space-2xl);
      }
    }

    /* Medium screens (tablets) */
    @media (max-width: 1023px) and (min-width: 768px) {
      .content {
        grid-template-columns: 1fr;
        gap: var(--space-xl);
      }
      
      .content-sidebar {
        order: -1;
      }

      .action-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Small screens (mobile) */
    @media (max-width: 767px) {
      .mobile-menu-btn {
        display: flex;
      }

      .sidebar {
        transform: translateX(-100%);
        transition: transform var(--transition-normal);
        z-index: 100;
        width: 100vw;
        max-width: 320px;
      }
      
      .sidebar.open {
        transform: translateX(0);
      }
      
      .main-content {
        margin-left: 0;
        width: 100%;
      }

      .header {
        padding: var(--space-md) var(--space-lg);
        align-items: center;
        gap: var(--space-md);
      }

      .header-title {
        font-size: var(--font-size-lg);
      }

      .header-subtitle {
        font-size: var(--font-size-xs);
      }

      .content {
        padding: var(--space-md);
        gap: var(--space-lg);
        grid-template-columns: 1fr;
      }
      
      .action-grid {
        grid-template-columns: 1fr;
        gap: var(--space-md);
      }
      
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: var(--space-sm);
      }
      
      .game-card {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--space-md);
        padding: var(--space-lg);
      }

      .game-players {
        width: 100%;
        justify-content: space-between;
      }

      .game-info {
        width: 100%;
        text-align: left;
      }

      .game-actions {
        width: 100%;
        justify-content: center;
      }

      .quick-actions,
      .games-section {
        padding: var(--space-md);
      }

      .section-title {
        font-size: var(--font-size-lg);
        margin-bottom: var(--space-md);
      }

      /* Mobile-specific user profile adjustments */
      .user-profile {
        padding: var(--space-md);
        flex-direction: row;
        align-items: center;
        gap: var(--space-md);
      }

      .user-avatar {
        width: 48px;
        height: 48px;
        font-size: var(--font-size-lg);
      }

      .user-info {
        flex: 1;
      }

      .user-name {
        font-size: var(--font-size-base);
        margin-bottom: var(--space-xs);
      }

      .user-rating {
        font-size: var(--font-size-sm);
      }
    }

    /* Extra small screens */
    @media (max-width: 480px) {
      .header {
        padding: var(--space-sm) var(--space-md);
      }
      
      .content {
        padding: var(--space-sm);
        gap: var(--space-md);
      }
      
      .quick-actions,
      .games-section {
        padding: var(--space-sm);
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
        gap: var(--space-sm);
      }

      .action-btn {
        padding: var(--space-md);
        font-size: var(--font-size-sm);
      }

      .stat-card {
        padding: var(--space-md);
      }

      .stat-value {
        font-size: var(--font-size-xl);
      }

      .sidebar {
        max-width: 280px;
      }

      .sidebar-header {
        padding: var(--space-lg) var(--space-md);
      }

      .sidebar-nav {
        padding: var(--space-md);
      }
    }

    /* Touch device optimizations */
    @media (pointer: coarse) {
      .nav-item {
        min-height: 48px;
        padding: var(--space-md) var(--space-lg);
      }

      .action-btn {
        min-height: 48px;
      }

      .game-card {
        padding: var(--space-lg);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="lobby-container fade-in">
      <!-- Sidebar Navigation -->
      <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h1 class="sidebar-logo">Chess Platform</h1>
          <p class="sidebar-subtitle">Professional Chess</p>
        </div>
        
        <div class="sidebar-nav">
          <div class="nav-section">
            <div class="nav-section-title">Play</div>
            <div class="nav-items">
              <a href="#" class="nav-item active" data-route="/lobby">
                <span class="nav-icon">🏠</span>
                <span>Lobby</span>
              </a>
              <a href="#" class="nav-item" data-route="/game/new">
                <span class="nav-icon">⚡</span>
                <span>Quick Play</span>
              </a>
              <a href="#" class="nav-item" data-route="/puzzles">
                <span class="nav-icon">🧩</span>
                <span>Puzzles</span>
              </a>
            </div>
          </div>
          
          <div class="nav-section">
            <div class="nav-section-title">Account</div>
            <div class="nav-items">
              <a href="#" class="nav-item" data-route="/profile">
                <span class="nav-icon">👤</span>
                <span>Profile</span>
              </a>
              <a href="#" class="nav-item" data-route="/settings">
                <span class="nav-icon">⚙️</span>
                <span>Settings</span>
              </a>
              <a href="#" class="nav-item" id="logout-btn">
                <span class="nav-icon">🚪</span>
                <span>Logout</span>
              </a>
            </div>
          </div>
        </div>
        
        <div class="sidebar-footer">
          <div class="user-profile" data-route="/profile">
            <div class="user-avatar" id="userAvatar">?</div>
            <div class="user-info">
              <div class="user-name" id="userName">Loading...</div>
              <div class="user-rating">
                Rating: <span class="rating-badge" id="userRating">----</span>
              </div>
            </div>
          </div>
        </div>
      </nav>

      <!-- Main Content -->
      <main class="main-content">
        <!-- Header -->
        <header class="header">
          <!-- Mobile Menu Button -->
          <button class="mobile-menu-btn" id="mobileMenuBtn" aria-label="Toggle Menu">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
          </button>
          
          <div>
            <div class="header-title">Chess Lobby</div>
            <div class="header-subtitle">Welcome back! Ready for your next game?</div>
          </div>
          <div class="header-actions">
            <div class="status-indicator">
              <div class="status-dot"></div>
              <span>Online</span>
            </div>
          </div>
        </header>

        <!-- Content Area -->
        <div class="content">
          <div class="content-main">
            <!-- Quick Actions -->
            <section class="quick-actions">
              <h2 class="section-title">
                <span class="section-icon">⚡</span>
                Quick Actions
              </h2>
              
              <div class="action-grid">
                <div class="action-card quick-play" id="quickPlayBtn">
                  <span class="action-icon">⚡</span>
                  <h3 class="action-title">Quick Play</h3>
                  <p class="action-description">Get matched with a player of similar rating instantly</p>
                </div>
                
                <div class="action-card create-game" id="createGameBtn">
                  <span class="action-icon">➕</span>
                  <h3 class="action-title">Create Game</h3>
                  <p class="action-description">Set up a custom game and wait for opponents</p>
                </div>
                
                <div class="action-card play-computer" id="playComputerBtn">
                  <span class="action-icon">🤖</span>
                  <h3 class="action-title">Play vs Computer</h3>
                  <p class="action-description">Challenge our AI opponent with adjustable difficulty</p>
                </div>
                
                <div class="action-card join-game" id="joinGameBtn">
                  <span class="action-icon">🔍</span>
                  <h3 class="action-title">Browse Games</h3>
                  <p class="action-description">Join existing games or spectate ongoing matches</p>
                </div>
                
                <div class="action-card puzzles" data-route="/puzzles">
                  <span class="action-icon">🧩</span>
                  <h3 class="action-title">Solve Puzzles</h3>
                  <p class="action-description">Improve your tactical skills with chess puzzles</p>
                </div>
              </div>
            </section>

            <!-- Active Games -->
            <section class="games-section">
              <h2 class="section-title">
                <span class="section-icon">♟️</span>
                Active Games
              </h2>
              
              <div class="games-list" id="gamesList">
                <!-- Games will be loaded here -->
                <div class="loading-skeleton"></div>
                <div class="loading-skeleton"></div>
                <div class="loading-skeleton"></div>
              </div>
            </section>
          </div>

          <div class="content-sidebar">
            <!-- User Statistics -->
            <div class="stats-panel">
              <h3 class="section-title">
                <span class="section-icon">📊</span>
                Your Stats
              </h3>
              
              <div class="stats-grid">
                <div class="stat-item">
                  <div class="stat-value" id="gamesPlayed">--</div>
                  <div class="stat-label">Games Played</div>
                </div>
                <div class="stat-item">
                  <div class="stat-value" id="winRate">--%</div>
                  <div class="stat-label">Win Rate</div>
                </div>
                <div class="stat-item">
                  <div class="stat-value" id="currentStreak">--</div>
                  <div class="stat-label">Win Streak</div>
                </div>
                <div class="stat-item">
                  <div class="stat-value" id="bestRating">----</div>
                  <div class="stat-label">Best Rating</div>
                </div>
              </div>
            </div>

            <!-- Online Players -->
            <div class="online-players">
              <h3 class="section-title">
                <span class="section-icon">🟢</span>
                Online Players
              </h3>
              
              <div class="players-list" id="onlinePlayersList">
                <!-- Online players will be loaded here -->
                <div class="empty-state">
                  <div class="empty-icon">👥</div>
                  <div class="empty-title">Loading players...</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <script>
    // Lobby page controller - Matching our API system
    function initLobbyPage() {
      // Check authentication first
      if (!localStorage.getItem('access')) {
        window.location.href = '/login/';
        return;
      }
      
      let currentUser = null;
      let games = [];
      let onlinePlayers = [];
      
      // Initialize lobby
      initializeLobby();
      
      async function initializeLobby() {
        try {
          // Load user profile
          await loadUserProfile();
          
          // Load games list
          await loadGames();
          
          // Load online players (mock for now)
          loadOnlinePlayers();
          
          // Set up event listeners
          setupEventListeners();
          
          // Set up periodic updates
          setupPeriodicUpdates();
          
        } catch (error) {
          console.error('Failed to initialize lobby:', error);
          api.showError('Failed to load lobby data');
        }
      }
      
      async function loadUserProfile() {
        try {
          console.log('Loading user profile...');
          const response = await api.getUserProfile();
          console.log('Profile response:', response);
          
          if (response.ok) {
            currentUser = response.data;
            console.log('User profile loaded:', currentUser);
            updateUserDisplay();
          } else {
            console.error('Profile API failed:', response);
            // If unauthorized, redirect to login
            if (response.status === 401) {
              window.location.href = '/login/';
              return;
            }
            throw new Error(`Profile API failed: ${response.status}`);
          }
        } catch (error) {
          console.error('Failed to load user profile:', error);
          // Check if user is authenticated
          if (!localStorage.getItem('access')) {
            window.location.href = '/login/';
            return;
          }
          // Use fallback data
          currentUser = {
            username: 'Player',
            rating: 1200,
            games_played: 0,
            games_won: 0
          };
          updateUserDisplay();
        }
      }
      
      function updateUserDisplay() {
        const userNameEl = document.getElementById('userName');
        const userRatingEl = document.getElementById('userRating');
        const userAvatarEl = document.getElementById('userAvatar');
        
        if (currentUser) {
          userNameEl.textContent = currentUser.username;
          userRatingEl.textContent = currentUser.rating || 1200;
          
          // Update avatar - show image if available, otherwise show first letter
          if (currentUser.avatar && currentUser.avatar.trim() !== '') {
            userAvatarEl.style.backgroundImage = `url(${currentUser.avatar})`;
            userAvatarEl.style.backgroundSize = 'cover';
            userAvatarEl.style.backgroundPosition = 'center';
            userAvatarEl.textContent = '';
          } else {
            userAvatarEl.style.backgroundImage = '';
            userAvatarEl.textContent = currentUser.username.charAt(0).toUpperCase();
          }
          
          // Update stats
          document.getElementById('gamesPlayed').textContent = currentUser.games_played || 0;
          const winRate = currentUser.games_played > 0 
            ? Math.round((currentUser.games_won / currentUser.games_played) * 100)
            : 0;
          document.getElementById('winRate').textContent = winRate + '%';
          document.getElementById('currentStreak').textContent = currentUser.current_streak || 0;
          document.getElementById('bestRating').textContent = currentUser.best_rating || currentUser.rating || 1200;
        }
      }
      
      async function loadGames() {
        try {
          const response = await api.getGames();
          if (response.ok) {
            games = response.data;
            updateGamesDisplay();
          }
        } catch (error) {
          console.error('Failed to load games:', error);
          showEmptyGames();
        }
      }
      
      function updateGamesDisplay() {
        const gamesListEl = document.getElementById('gamesList');
        
        if (!games || games.length === 0) {
          showEmptyGames();
          return;
        }
        
        gamesListEl.innerHTML = games.map(game => `
          <div class="game-card" data-game-id="${game.id}">
            <div class="game-players">
              <div class="player-info">
                <div class="player-avatar">${game.white_player_username.charAt(0).toUpperCase()}</div>
                <div>
                  <div class="player-name">${game.white_player_username}</div>
                  <div class="player-rating">${game.white_player_rating || 1200}</div>
                </div>
              </div>
              
              <div class="vs-divider">vs</div>
              
              <div class="player-info">
                <div class="player-avatar">${game.black_player_username ? game.black_player_username.charAt(0).toUpperCase() : '?'}</div>
                <div>
                  <div class="player-name">${game.black_player_username || 'Waiting...'}</div>
                  <div class="player-rating">${game.black_player_rating || '----'}</div>
                </div>
              </div>
            </div>
            
            <div class="game-status">
              <div class="status-badge status-${game.status}">${getStatusText(game.status)}</div>
              <div class="game-time">${getTimeAgo(game.created_at)}</div>
            </div>
          </div>
        `).join('');
        
        // Add click handlers to game cards
        document.querySelectorAll('.game-card').forEach(card => {
          card.addEventListener('click', () => {
            const gameId = card.dataset.gameId;
            window.location.href = `/play/?game=${gameId}`;
          });
        });
      }
      
      function showEmptyGames() {
        const gamesListEl = document.getElementById('gamesList');
        gamesListEl.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">♟️</div>
            <div class="empty-title">No Active Games</div>
            <div class="empty-description">Create a new game or browse available games to get started!</div>
          </div>
        `;
      }
      
      function loadOnlinePlayers() {
        // Mock online players for now - replace with real API call later
        onlinePlayers = [
          { username: 'ChessMaster', rating: 1650, status: 'online' },
          { username: 'KnightRider', rating: 1420, status: 'playing' },
          { username: 'QueenGambit', rating: 1580, status: 'online' },
          { username: 'PawnStorm', rating: 1350, status: 'online' },
          { username: 'CastleKing', rating: 1720, status: 'playing' }
        ];
        
        updateOnlinePlayersDisplay();
      }
      
      function updateOnlinePlayersDisplay() {
        const playersListEl = document.getElementById('onlinePlayersList');
        
        if (!onlinePlayers || onlinePlayers.length === 0) {
          playersListEl.innerHTML = `
            <div class="empty-state">
              <div class="empty-icon">👥</div>
              <div class="empty-title">No players online</div>
            </div>
          `;
          return;
        }
        
        playersListEl.innerHTML = onlinePlayers.map(player => `
          <div class="player-item" data-username="${player.username}">
            <div class="player-status"></div>
            <div class="player-avatar">${player.username.charAt(0).toUpperCase()}</div>
            <div>
              <div class="player-name">${player.username}</div>
              <div class="player-rating">${player.rating}</div>
            </div>
          </div>
        `).join('');
      }
      
      function setupEventListeners() {
        // Quick Play
        document.getElementById('quickPlayBtn').addEventListener('click', async () => {
          api.showToast('Quick Play feature coming soon!', 'info');
        });
        
        // Create Game
        document.getElementById('createGameBtn').addEventListener('click', async () => {
          try {
            api.showToast('Creating game...', 'info');
            const response = await api.createGame();
            if (response.ok) {
              api.showSuccess('Game created successfully!');
              setTimeout(() => {
                window.location.href = `/play/?game=${response.data.id}`;
              }, 1000);
            } else {
              api.showError(api.formatError(response));
            }
          } catch (error) {
            console.error('Create game error:', error);
            api.showError('Failed to create game. Please try again.');
          }
        });
        
        // Browse Games
        document.getElementById('joinGameBtn').addEventListener('click', () => {
          // Scroll to games section smoothly
          document.querySelector('.games-section').scrollIntoView({ 
            behavior: 'smooth' 
          });
          api.showToast('Browse games below and click to join!', 'info');
        });
        
        // Puzzles
        document.querySelector('.action-card.puzzles').addEventListener('click', () => {
          window.location.href = '/puzzles/';
        });
        
        // Logout
        document.getElementById('logout-btn').addEventListener('click', async (e) => {
          e.preventDefault();
          if (confirm('Are you sure you want to logout?')) {
            try {
              await api.logout();
              api.showSuccess('Logged out successfully!');
            } catch (error) {
              console.error('Logout error:', error);
            }
          }
        });
        
        // Navigation items - Use direct navigation for reliability
        document.querySelectorAll('.nav-item[data-route]').forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();
            const route = item.dataset.route;
            console.log('Nav item clicked (router method):', route);
            
            // Update active state
            document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
            item.classList.add('active');
            
            // Use direct navigation instead of router
            console.log('Navigating to:', route + '/');
            window.location.href = route + '/';
          });
        });
        
        // User profile click
        document.querySelector('.user-profile[data-route]').addEventListener('click', () => {
          console.log('User profile clicked, navigating to /profile/');
          window.location.href = '/profile/';
        });
        
        // Navigation items click handlers
        document.querySelectorAll('.nav-item[data-route]').forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();
            const route = item.getAttribute('data-route');
            console.log('Nav item clicked:', route);
            if (route) {
              console.log('Navigating to:', route + '/');
              window.location.href = route + '/';
            } else {
              console.log('No route found for nav item');
            }
          });
        });
      }
      
      function setupPeriodicUpdates() {
        // Refresh games list every 30 seconds
        const gamesInterval = setInterval(() => {
          if (document.visibilityState === 'visible') {
            loadGames();
          }
        }, 30000);
        
        // Refresh online players every 60 seconds
        const playersInterval = setInterval(() => {
          if (document.visibilityState === 'visible') {
            loadOnlinePlayers();
          }
        }, 60000);
        
        // Clean up intervals when page is unloaded
        window.addEventListener('beforeunload', () => {
          clearInterval(gamesInterval);
          clearInterval(playersInterval);
        });
      }
      
      // Utility functions
      function getStatusText(status) {
        const statusMap = {
          waiting: 'Waiting',
          active: 'Active',
          finished: 'Finished'
        };
        return statusMap[status] || status;
      }
      
      function getTimeAgo(dateString) {
        const now = new Date();
        const date = new Date(dateString);
        const diffInMs = now - date;
        const diffInMins = Math.floor(diffInMs / 60000);
        
        if (diffInMins < 1) return 'Just now';
        if (diffInMins < 60) return `${diffInMins}m ago`;
        
        const diffInHours = Math.floor(diffInMins / 60);
        if (diffInHours < 24) return `${diffInHours}h ago`;
        
        const diffInDays = Math.floor(diffInHours / 24);
        return `${diffInDays}d ago`;
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initLobbyPage);
    } else {
      initLobbyPage();
    }

    // ================================
    // Mobile Menu Functionality
    // ================================
    function initMobileMenu() {
      const mobileMenuBtn = document.getElementById('mobileMenuBtn');
      const sidebar = document.querySelector('.sidebar');
      const mobileOverlay = document.createElement('div');
      
      // Create mobile overlay
      mobileOverlay.className = 'mobile-overlay';
      mobileOverlay.id = 'mobileOverlay';
      document.body.appendChild(mobileOverlay);

      function toggleMobileMenu() {
        const isOpen = sidebar.classList.contains('open');
        
        if (isOpen) {
          closeMobileMenu();
        } else {
          openMobileMenu();
        }
      }

      function openMobileMenu() {
        sidebar.classList.add('open');
        mobileOverlay.classList.add('active');
        mobileMenuBtn.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevent scroll
      }

      function closeMobileMenu() {
        sidebar.classList.remove('open');
        mobileOverlay.classList.remove('active');
        mobileMenuBtn.classList.remove('active');
        document.body.style.overflow = ''; // Restore scroll
      }

      // Event listeners
      mobileMenuBtn.addEventListener('click', toggleMobileMenu);
      mobileOverlay.addEventListener('click', closeMobileMenu);

      // Close menu on navigation item click (mobile)
      const navItems = sidebar.querySelectorAll('.nav-item');
      navItems.forEach(item => {
        item.addEventListener('click', () => {
          if (window.innerWidth <= 767) {
            closeMobileMenu();
          }
        });
      });

      // Close menu on escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
          closeMobileMenu();
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (window.innerWidth > 767 && sidebar.classList.contains('open')) {
          closeMobileMenu();
        }
      });
    }

    // Initialize mobile menu
    initMobileMenu();
  </script>
</body>
</html>
===== chess-platform/frontend/src/pages/dashboard/lobby.js =====

===== chess-platform/frontend/src/pages/game/play.css =====

===== chess-platform/frontend/src/pages/game/play.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game - Chess Platform</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>♛</text></svg>">
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Game-specific styles maintaining design consistency */
    .game-container {
      min-height: 100vh;
      background: 
        radial-gradient(ellipse at top left, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      display: flex;
      flex-direction: column;
    }

    /* Game Header */
    .game-header {
      height: var(--header-height);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-xl);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .game-title {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .game-id {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
    }

    .current-user-info {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      background: rgba(255, 255, 255, 0.05);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
    }

    .current-user-info strong {
      color: var(--color-accent-primary);
    }

    .game-status-badge {
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
    }

    .status-active {
      background: rgba(34, 197, 94, 0.2);
      color: var(--color-success);
    }

    .status-waiting {
      background: rgba(251, 191, 36, 0.2);
      color: var(--color-warning);
    }

    .status-finished {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .game-actions {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .back-btn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: var(--font-size-sm);
      transition: all var(--transition-normal);
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-accent-primary);
      transform: translateX(-2px);
    }

    /* Game Content */
    .game-content {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr auto 320px;
      gap: var(--space-xl);
      padding: var(--space-xl);
      align-items: start;
    }

    /* Player Info */
    .players-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .player-card {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-lg);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      transition: all var(--transition-normal);
    }

    .player-card.current-turn {
      border-color: var(--color-accent-primary);
      box-shadow: 0 0 0 1px rgba(118, 150, 86, 0.2), var(--shadow-md);
      background: rgba(118, 150, 86, 0.03);
    }

    .player-card.black {
      order: -1; /* Black player on top */
    }

    .player-avatar {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
      position: relative;
    }

    .player-avatar.black {
      background: linear-gradient(135deg, var(--color-bg-tertiary) 0%, #1f2937 100%);
      color: var(--color-text-primary);
    }

    .player-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .player-name {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
    }

    .player-rating {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .rating-badge {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
      font-weight: var(--font-weight-medium);
    }

    .player-timer {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      font-family: var(--font-family-mono);
      min-width: 80px;
      text-align: right;
    }

    .player-timer.low-time {
      color: var(--color-error);
      animation: pulse-timer 1s ease-in-out infinite;
    }

    @keyframes pulse-timer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .turn-indicator {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 12px;
      height: 12px;
      border-radius: var(--radius-full);
      background: var(--color-accent-primary);
      border: 2px solid var(--color-bg-primary);
      animation: pulse 2s ease-in-out infinite;
    }

    /* Chess Board */
    .board-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 500px;
      padding: var(--space-md);
    }

    .chess-board {
      width: min(70vh, 500px);
      height: min(70vh, 500px);
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      border: 2px solid var(--glass-border);
      position: relative;
    }

    .chess-square {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all var(--transition-fast);
      user-select: none;
    }

    .chess-square.light {
      background-color: var(--color-board-light);
    }

    .chess-square.dark {
      background-color: var(--color-board-dark);
    }

    .chess-square:hover {
      background-color: rgba(118, 150, 86, 0.3) !important;
    }

    .chess-square.selected {
      background-color: rgba(255, 235, 59, 0.7) !important;
      box-shadow: inset 0 0 0 3px #ffd700;
    }

    .chess-square.possible-move {
      background-color: rgba(34, 197, 94, 0.3) !important;
    }

    .chess-square.possible-move::after {
      content: '';
      width: 30%;
      height: 30%;
      border-radius: var(--radius-full);
      background: rgba(34, 197, 94, 0.6);
    }

    .chess-square.possible-capture {
      background-color: rgba(239, 68, 68, 0.3) !important;
    }

    .chess-square.possible-capture::after {
      content: '';
      width: 100%;
      height: 100%;
      border: 3px solid rgba(239, 68, 68, 0.7);
      border-radius: var(--radius-sm);
      position: absolute;
      box-sizing: border-box;
    }

    .chess-square.last-move {
      background-color: rgba(59, 130, 246, 0.4) !important;
    }

    .chess-square.in-check {
      background-color: rgba(239, 68, 68, 0.5) !important;
      animation: check-flash 0.5s ease-in-out;
    }

    @keyframes check-flash {
      0%, 100% { background-color: rgba(239, 68, 68, 0.5) !important; }
      50% { background-color: rgba(239, 68, 68, 0.8) !important; }
    }

    .chess-piece {
      font-size: 2.5rem;
      user-select: none;
      pointer-events: none;
      transition: transform var(--transition-fast);
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .chess-piece.white-piece {
      color: #f8f9fa;
      text-shadow: 
        1px 1px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .chess-piece.black-piece {
      color: #1a1a1a;
      text-shadow: 
        1px 1px 0 #fff,
        -1px -1px 0 #fff,
        1px -1px 0 #fff,
        -1px 1px 0 #fff,
        2px 2px 4px rgba(255, 255, 255, 0.3);
    }

    .chess-square:hover .chess-piece {
      transform: scale(1.05);
    }

    /* Coordinate Labels */
    .coord-label {
      position: absolute;
      font-size: 0.7rem;
      font-weight: var(--font-weight-medium);
      color: rgba(0, 0, 0, 0.6);
      pointer-events: none;
    }

    .coord-file {
      bottom: 2px;
      right: 4px;
    }

    .coord-rank {
      top: 2px;
      left: 4px;
    }

    /* Game Sidebar */
    .game-sidebar {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
      min-width: 320px;
    }

    .sidebar-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
    }

    .panel-header {
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: between;
      gap: var(--space-sm);
    }

    .panel-title {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .panel-content {
      padding: var(--space-lg);
    }

    /* Game Controls */
    .game-controls {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .control-group {
      display: flex;
      gap: var(--space-sm);
    }

    .control-btn {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      transition: all var(--transition-normal);
      cursor: pointer;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--color-accent-primary);
      color: var(--color-accent-primary);
    }

    .control-btn.danger:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: var(--color-error);
      color: var(--color-error);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Move History */
    .move-history {
      max-height: 300px;
      overflow-y: auto;
      padding: var(--space-sm) 0;
    }

    .move-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .move-pair {
      display: grid;
      grid-template-columns: auto 1fr 1fr;
      gap: var(--space-sm);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-family: var(--font-family-mono);
      font-size: var(--font-size-sm);
      transition: background var(--transition-fast);
    }

    .move-pair:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .move-number {
      color: var(--color-text-muted);
      font-weight: var(--font-weight-medium);
      min-width: 20px;
    }

    .move-white,
    .move-black {
      color: var(--color-text-secondary);
      cursor: pointer;
      padding: 2px var(--space-xs);
      border-radius: var(--radius-xs);
      transition: all var(--transition-fast);
    }

    .move-white:hover,
    .move-black:hover {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
    }

    .move-current {
      background: rgba(118, 150, 86, 0.3) !important;
      color: var(--color-accent-primary) !important;
    }

    /* Game Status */
    .game-status {
      text-align: center;
      padding: var(--space-lg);
    }

    .status-message {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }

    .status-details {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
    }

    /* Captured Pieces */
    .captured-pieces {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
      justify-content: center;
    }

    .captured-piece {
      font-size: 1.2rem;
      opacity: 0.7;
      filter: grayscale(50%);
    }

    /* Promotion Dialog */
    .promotion-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .promotion-dialog.show {
      opacity: 1;
      visibility: visible;
    }

    .promotion-content {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-xl);
      text-align: center;
    }

    .promotion-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-lg);
    }

    .promotion-pieces {
      display: flex;
      gap: var(--space-md);
      justify-content: center;
    }

    .promotion-piece {
      width: 60px;
      height: 60px;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .promotion-piece:hover {
      background: rgba(118, 150, 86, 0.2);
      border-color: var(--color-accent-primary);
      transform: scale(1.1);
    }

    /* Loading States */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-lg);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .loading-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(118, 150, 86, 0.2);
      border-top: 3px solid var(--color-accent-primary);
      border-radius: var(--radius-full);
      animation: spin 1s linear infinite;
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .game-header {
      height: var(--header-height-mobile);
      padding: 0 var(--space-md);
      flex-wrap: wrap;
      gap: var(--space-sm);
    }

    .game-title h1 {
      font-size: var(--font-size-lg);
    }

    .game-controls {
      gap: var(--space-sm);
    }

    .game-controls .btn {
      padding: var(--space-sm) var(--space-md);
      font-size: var(--font-size-xs);
      min-height: var(--touch-target-min);
      min-width: var(--touch-target-min);
    }

    /* Base styles for all screen sizes */
    .game-content {
      display: grid !important;
      grid-template-columns: 1fr auto 320px !important;
      gap: var(--space-xl);
      padding: var(--space-xl);
      max-width: 1400px;
      margin: 0 auto;
    }

    .chess-board {
      width: min(70vh, 500px);
      height: min(70vh, 500px);
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      border: 2px solid var(--glass-border);
      position: relative;
    }

    .chess-square {
      border-radius: 2px;
    }

    .chess-piece {
      font-size: 2.5rem;
      user-select: none;
      pointer-events: none;
      transition: transform var(--transition-fast);
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .players-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      margin-bottom: var(--space-lg);
    }

    .player-card.black {
      order: -1;
    }

    .player-card {
      padding: var(--space-md);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .player-avatar {
      width: 36px;
      height: 36px;
      font-size: var(--font-size-sm);
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      min-width: 0;
    }

    .player-name {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-rating {
      font-size: var(--font-size-xs);
      opacity: 0.8;
    }

    .player-timer {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      font-family: 'Courier New', monospace;
      min-width: 80px;
      text-align: right;
    }

    .player-timer.warning {
      color: var(--color-warning);
      animation: pulse 1s infinite;
    }

    .player-timer.critical {
      color: var(--color-error);
      animation: pulse 0.5s infinite;
    }

    .game-sidebar {
      min-width: 320px;
      width: 320px;
    }

    .panel-content {
      padding: var(--space-md);
      max-height: 300px;
      overflow-y: auto;
    }

    .move-list {
      font-family: 'Courier New', monospace;
      font-size: var(--font-size-sm);
      line-height: 1.4;
    }

    .chat-messages {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: var(--space-md);
    }

    .chat-input {
      display: flex;
      gap: var(--space-sm);
    }

    .chat-input input {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      font-size: var(--font-size-sm);
    }

    .chat-input button {
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      min-width: var(--touch-target-min);
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .game-header {
        height: var(--header-height);
        padding: 0 var(--space-lg);
      }

      .game-title h1 {
        font-size: var(--font-size-xl);
      }

      .game-content {
        padding: var(--space-lg);
        gap: var(--space-lg);
      }

      .chess-board {
        width: min(70vw, 70vh, 500px);
        height: min(70vw, 70vh, 500px);
      }

      .chess-piece {
        font-size: 2rem;
      }

      .players-section {
        flex-direction: row;
        justify-content: space-between;
      }

      .player-card {
        flex: 1;
        max-width: 300px;
      }

      .player-avatar {
        width: 44px;
        height: 44px;
        font-size: var(--font-size-base);
      }

      .player-name {
        font-size: var(--font-size-base);
      }

      .player-timer {
        font-size: var(--font-size-xl);
      }

      .panel-content {
        max-height: 400px;
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .chess-board {
        width: min(75vw, 75vh);
        height: min(75vw, 75vh);
      }

      .chess-piece {
        font-size: 2.2rem;
      }

      .panel-content {
        max-height: 500px;
      }

      .chat-messages {
        max-height: 250px;
      }
    }

    /* Desktop styles (1025px to 1280px) */
    @media (min-width: 1025px) {
      .game-content {
        grid-template-columns: 1fr auto 320px !important;
        gap: var(--space-xl);
        padding: var(--space-xl);
      }

      .players-section {
        order: 0;
        flex-direction: column;
        gap: var(--space-md);
        margin-bottom: 0;
      }

      .player-card.black {
        order: -1;
      }

      .chess-board {
        width: min(65vw, 65vh);
        height: min(65vw, 65vh);
      }

      .chess-piece {
        font-size: 2.5rem;
      }

      .game-sidebar {
        min-width: 300px;
        width: 300px;
      }

      .panel-content {
        max-height: 600px;
      }

      .chat-messages {
        max-height: 300px;
      }
    }

    /* Large desktop styles (1281px and up) */
    @media (min-width: 1281px) {
      .game-content {
        grid-template-columns: 1fr auto 350px !important;
        gap: var(--space-2xl);
        padding: var(--space-2xl);
        max-width: 1400px;
        margin: 0 auto;
      }

      .game-sidebar {
        min-width: 350px;
        width: 350px;
      }

      .chess-board {
        width: min(60vw, 60vh);
        height: min(60vw, 60vh);
      }

      .chess-piece {
        font-size: 3rem;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .chess-square {
        position: relative;
      }

      .chess-square::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: transparent;
        z-index: 1;
      }

      .chess-piece {
        position: relative;
        z-index: 2;
        touch-action: none;
        font-size: 2rem;
      }

      .game-controls .btn {
        min-height: var(--touch-target-min);
        min-width: var(--touch-target-min);
        padding: var(--space-md);
      }

      .chat-input input,
      .chat-input button {
        min-height: var(--touch-target-min);
      }

      /* Enhanced highlighting for touch */
      .chess-square.selected {
        box-shadow: inset 0 0 0 3px var(--color-primary);
      }

      .chess-square.valid-move {
        box-shadow: inset 0 0 0 2px var(--color-success);
      }

      .chess-square.last-move {
        box-shadow: inset 0 0 0 2px var(--color-accent);
      }

      /* Prevent text selection during drag */
      .chess-board {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
    }

    /* Landscape orientation adjustments for mobile */
    /* Mobile layout */
    @media (max-width: 768px) {
      .game-content {
        grid-template-columns: 1fr !important;
        gap: 1rem;
      }
      
      .game-sidebar {
        order: 2;
        min-width: auto;
        width: 100%;
      }
      
      .chess-board {
        width: 90vw;
        height: 90vw;
        max-width: 400px;
        max-height: 400px;
      }
      
      .chess-piece {
        font-size: 1.5rem;
      }
      
      .players-section {
        flex-direction: column;
        text-align: center;
      }
    }

    @media (max-width: 768px) and (orientation: landscape) {
      .game-content {
        grid-template-columns: 1fr 250px;
        gap: var(--space-md);
      }

      .chess-board {
        width: min(60vh, 60vw);
        height: min(60vh, 60vw);
      }

      .players-section {
        flex-direction: row;
        justify-content: space-between;
      }

      .game-sidebar {
        width: 250px;
        min-width: 250px;
      }

      .panel-content {
        max-height: 200px;
      }

      .chat-messages {
        max-height: 120px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="game-container fade-in">
      <!-- Game Header -->
      <header class="game-header">
        <div class="game-title">
          <span class="game-id" id="gameId">Game #---</span>
          <div class="game-status-badge" id="gameStatus">Loading...</div>
        </div>
        
        <div class="current-user-info" id="currentUserInfo" style="display: none;">
          <span>Playing as: </span>
          <strong id="currentUserName">---</strong>
          <span>(</span><span id="currentUserRating">----</span><span>)</span>
        </div>
        
        <div class="game-actions">
          <a href="#" class="back-btn" data-route="/lobby">
            <span>←</span>
            <span>Back to Lobby</span>
          </a>
        </div>
      </header>

      <!-- Game Content -->
      <div class="game-content">
        <!-- Player Info -->
        <div class="players-section">
          <div class="player-card white" id="whitePlayer">
            <div class="player-avatar">
              <span id="whiteAvatar">?</span>
            </div>
            <div class="player-info">
              <div class="player-name" id="whiteName">Loading...</div>
              <div class="player-rating">
                Rating: <span class="rating-badge" id="whiteRating">----</span>
              </div>
            </div>
            <div class="player-timer" id="whiteTimer">∞</div>
          </div>

          <div class="player-card black" id="blackPlayer">
            <div class="player-avatar black">
              <span id="blackAvatar">?</span>
            </div>
            <div class="player-info">
              <div class="player-name" id="blackName">Waiting...</div>
              <div class="player-rating">
                Rating: <span class="rating-badge" id="blackRating">----</span>
              </div>
            </div>
            <div class="player-timer" id="blackTimer">∞</div>
          </div>
        </div>

        <!-- Chess Board -->
        <div class="board-container">
          <div class="chess-board" id="chessBoard">
            <!-- Board squares will be generated here -->
            <div class="loading-overlay" id="boardLoading">
              <div class="loading-spinner"></div>
            </div>
          </div>
        </div>

        <!-- Game Sidebar -->
        <div class="game-sidebar">
          <!-- Game Controls -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>⚙️</span>
                Game Controls
              </h3>
            </div>
            <div class="panel-content">
              <div class="game-controls">
                <div class="control-group">
                  <button class="control-btn" id="offerDrawBtn">
                    🤝 Offer Draw
                  </button>
                  <button class="control-btn danger" id="resignBtn">
                    🏳️ Resign
                  </button>
                </div>
                <div class="control-group">
                  <button class="control-btn" id="flipBoardBtn">
                    🔄 Flip Board
                  </button>
                  <button class="control-btn" id="analysisBtn">
                    📊 Analysis
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Move History -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>📜</span>
                Move History
              </h3>
            </div>
            <div class="panel-content">
              <div class="move-history" id="moveHistory">
                <div class="move-list" id="moveList">
                  <!-- Moves will be populated here -->
                  <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
                    No moves yet. Game starting...
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Game Status -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>📋</span>
                Game Info
              </h3>
            </div>
            <div class="panel-content">
              <div class="game-status">
                <div class="status-message" id="statusMessage">Game in progress</div>
                <div class="status-details" id="statusDetails">White to move</div>
              </div>
            </div>
          </div>

          <!-- Captured Pieces -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>🏴‍☠️</span>
                Captured Pieces
              </h3>
            </div>
            <div class="panel-content">
              <div class="captured-pieces" id="capturedPieces">
                <!-- Captured pieces will be shown here -->
                <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
                  No captures yet
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Promotion Dialog -->
      <div class="promotion-dialog" id="promotionDialog">
        <div class="promotion-content">
          <h3 class="promotion-title">Choose promotion piece:</h3>
          <div class="promotion-pieces">
            <div class="promotion-piece" data-piece="q">♕</div>
            <div class="promotion-piece" data-piece="r">♖</div>
            <div class="promotion-piece" data-piece="b">♗</div>
            <div class="promotion-piece" data-piece="n">♘</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="../../utils/api.js"></script>
  <script src="../../utils/router.js"></script>
  
  <script>
    // Set up router routes for game page
    function setupRoutes() {
      console.log('Setting up routes for game page...');
      
      // Add route for lobby
      router.addRoute('/lobby', {
        title: 'Lobby - Chess Platform',
        controller: () => {
          window.location.href = '/lobby/';
        },
        requiresAuth: true
      });
      
      // Add route for profile
      router.addRoute('/profile', {
        title: 'Profile - Chess Platform',
        controller: () => {
          window.location.href = '/profile/';
        },
        requiresAuth: true
      });
      
      // Add route for puzzles
      router.addRoute('/puzzles', {
        title: 'Puzzles - Chess Platform',
        controller: () => {
          window.location.href = '/puzzles/';
        },
        requiresAuth: true
      });
      
      console.log('Routes configured for game page');
    }
    
    // Set up navigation click handlers
    function setupNavigation() {
      console.log('Setting up navigation for game page...');
      
      document.querySelectorAll('a[data-route]').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          console.log('Navigating to:', route);
          
          // Use direct navigation for reliability
          window.location.href = route + '/';
        });
      });
    }
    
    // Game page controller
    function initGamePage() {
      // Set up router routes
      setupRoutes();
      
      // Set up navigation click handlers
      setupNavigation();
      
      let gameData = null;
      let selectedSquare = null;
      let possibleMoves = [];
      let gameId = null;
      let currentUser = null;
      let moveHistory = [];
      let api;
      
      // Timer management
      let timerInterval = null;
      let gameTimerData = null;
      let lastTimerUpdate = null;
      
      // Timer Functions
      function formatTime(seconds) {
        if (seconds === null || seconds === undefined) return '∞';
        if (seconds < 0) return '0:00';
        
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }
      
      function updateTimerDisplay() {
        if (!gameTimerData) return;
        
        const whiteTimer = document.getElementById('whiteTimer');
        const blackTimer = document.getElementById('blackTimer');
        
        if (!whiteTimer || !blackTimer) return;
        
        // Calculate current time for display
        let whiteTime = gameTimerData.white_time;
        let blackTime = gameTimerData.black_time;
        
        // If game is active and we have a last update timestamp, calculate elapsed time
        if (gameTimerData.game_status === 'active' && lastTimerUpdate) {
          const elapsed = Math.floor((Date.now() - lastTimerUpdate) / 1000);
          
          if (gameTimerData.current_turn === 'white') {
            whiteTime = Math.max(0, whiteTime - elapsed);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
          }
        }
        
        // Update display
        whiteTimer.textContent = formatTime(whiteTime);
        blackTimer.textContent = formatTime(blackTime);
        
        // Add warning classes for low time
        whiteTimer.classList.toggle('low-time', whiteTime <= 30);
        blackTimer.classList.toggle('low-time', blackTime <= 30);
        
        // Update turn indicators
        const whiteCard = whiteTimer.closest('.player-card');
        const blackCard = blackTimer.closest('.player-card');
        
        if (whiteCard && blackCard) {
          whiteCard.classList.toggle('current-turn', gameTimerData.current_turn === 'white');
          blackCard.classList.toggle('current-turn', gameTimerData.current_turn === 'black');
        }
        
        // Check for timeout
        if (whiteTime <= 0 || blackTime <= 0) {
          handleTimeout(whiteTime <= 0 ? 'white' : 'black');
        }
      }
      
      function handleTimeout(timeoutPlayer) {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        
        api.showError(`${timeoutPlayer === 'white' ? 'White' : 'Black'} player ran out of time!`);
        
        // Refresh game data to get the final state
        setTimeout(() => {
          loadGameData();
        }, 1000);
      }
      
      async function fetchTimerData() {
        try {
          const response = await api.getGameTimer(gameId);
          if (response.ok) {
            gameTimerData = response.data;
            lastTimerUpdate = Date.now();
            updateTimerDisplay();
          }
        } catch (error) {
          console.error('Failed to fetch timer data:', error);
        }
      }
      
      function startTimerUpdates() {
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        // Update timer display every second
        timerInterval = setInterval(() => {
          updateTimerDisplay();
        }, 1000);
        
        // Fetch fresh timer data every 10 seconds
        setInterval(() => {
          fetchTimerData();
        }, 10000);
      }
      
      function stopTimerUpdates() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }
      
      // Initialize game
      initializeGame();
      
      async function initializeGame() {
        try {
          // Initialize API
          api = new ChessAPI();
          window.api = api;
          
          // Check authentication - for demo purposes, auto-login testuser
          await ensureAuthentication();
          
          // Get game ID from URL
          gameId = getGameIdFromUrl();
          if (!gameId) {
            api.showError('Invalid game URL');
            navigateToRoute('/lobby');
            return;
          }
          
          // Load current user
          await loadCurrentUser();
          
          // Load game data
          await loadGameData();
          
          // Set up event listeners
          setupEventListeners();
          
          // Start periodic updates
          setupPeriodicUpdates();
          
        } catch (error) {
          console.error('Failed to initialize game:', error);
          api.showError('Failed to load game');
        }
      }
      
      function getGameIdFromUrl() {
        // Check URL parameters first (e.g., ?game=123)
        const urlParams = new URLSearchParams(window.location.search);
        const gameIdParam = urlParams.get('game');
        if (gameIdParam) {
          return parseInt(gameIdParam);
        }
        
        // Fallback to path-based extraction
        const path = window.location.pathname;
        const matches = path.match(/\/game\/(\d+)/);
        return matches ? parseInt(matches[1]) : null;
      }
      
      async function loadCurrentUser() {
        try {
          const response = await api.getUserProfile();
          if (response.ok) {
            currentUser = response.data;
            updateCurrentUserDisplay();
          }
        } catch (error) {
          console.error('Failed to load current user:', error);
        }
      }
      
      function updateCurrentUserDisplay() {
        if (currentUser) {
          document.getElementById('currentUserName').textContent = currentUser.username;
          document.getElementById('currentUserRating').textContent = currentUser.rating || 1200;
          document.getElementById('currentUserInfo').style.display = 'block';
        }
      }
      
      async function ensureAuthentication() {
        console.log('🔐 Checking authentication status...');
        
        // Check if already authenticated
        if (api.isAuthenticated()) {
          console.log('✅ User is already authenticated');
          return true;
        }
        
        console.log('❌ User not authenticated');
        
        // Professional implementation: redirect to login
        console.log('🔄 Redirecting to login page...');
        api.showError('Please log in to view games');
        
        // Redirect to login with return URL
        const returnUrl = encodeURIComponent(window.location.pathname + window.location.search);
        window.location.href = `/login/?next=${returnUrl}`;
        
        return false;
      }
      
      // Professional navigation helper function with proper Django URL support
      function navigateToRoute(path) {
        console.log('🧭 Navigating to route:', path);
        
        // Use Django URLs for proper backend integration
        const djangoUrlMap = {
          '/lobby': '/lobby/',           // Django serves lobby.html
          '/login': '/login/',           // Django serves login.html  
          '/register': '/register/',     // Django serves register.html
          '/profile': '/profile/',       // Django serves profile page
          '/': '/'                       // Django serves home/login
        };
        
        // Check if we have a Django URL mapping
        if (djangoUrlMap[path]) {
          console.log('✅ Using Django URL:', djangoUrlMap[path]);
          window.location.href = djangoUrlMap[path];
          return;
        }
        
        // Fallback to router if available
        if (window.router) {
          console.log('🔄 Using router navigation');
          window.router.navigate(path);
        } else {
          // Last resort: relative path mapping (deprecated)
          console.warn('⚠️ Using deprecated relative path mapping for:', path);
          const pathMap = {
            '/lobby': '../dashboard/lobby.html',
            '/login': '../auth/login.html',
            '/profile': '../profile/index.html'
          };
          
          if (pathMap[path]) {
            window.location.href = pathMap[path];
          } else {
            console.error('❌ No route mapping found for:', path);
            // Default to lobby as safe fallback
            window.location.href = '/lobby/';
          }
        }
      }
      
      async function loadGameData() {
        try {
          showBoardLoading(true);
          const response = await api.getGameDetail(gameId);
          
          if (response.ok) {
            gameData = response.data;
            console.log('Game data loaded:', gameData);
            
            // Ensure we have a valid FEN
            if (!gameData.fen || gameData.fen === 'startpos') {
              gameData.fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
            }
            
            console.log('Using FEN:', gameData.fen);
            
            updateGameDisplay();
            renderBoard();
            
            // Load timer data (non-blocking)
            fetchTimerData().catch(err => {
              console.warn('Timer data not available:', err);
            });
            
            // Start timer updates if game is active
            if (gameData.status === 'active') {
              startTimerUpdates();
            } else {
              stopTimerUpdates();
            }
          } else {
            throw new Error(api.formatError(response));
          }
        } catch (error) {
          console.error('Failed to load game data:', error);
          api.showError('Failed to load game data');
        } finally {
          showBoardLoading(false);
        }
      }
      
      function updateGameDisplay() {
        if (!gameData) return;
        
        // Update game header
        document.getElementById('gameId').textContent = `Game #${gameData.id}`;
        const statusEl = document.getElementById('gameStatus');
        statusEl.textContent = getStatusText(gameData.status);
        statusEl.className = `game-status-badge status-${gameData.status}`;
        
        // Update player info
        updatePlayerInfo('white', gameData.white_player_username, gameData.white_player_rating);
        updatePlayerInfo('black', gameData.black_player_username, gameData.black_player_rating);
        
        // Update turn indicator
        updateTurnIndicator();
        
        // Update move history
        updateMoveHistory();
        
        // Update game status
        updateGameStatus();
      }
      
      function updatePlayerInfo(color, username, rating) {
        const nameEl = document.getElementById(`${color}Name`);
        const avatarEl = document.getElementById(`${color}Avatar`);
        const ratingEl = document.getElementById(`${color}Rating`);
        
        if (username) {
          nameEl.textContent = username;
          avatarEl.textContent = username.charAt(0).toUpperCase();
          ratingEl.textContent = rating || 1200;
        } else {
          nameEl.textContent = color === 'white' ? 'White Player' : 'Waiting...';
          avatarEl.textContent = '?';
          ratingEl.textContent = '----';
        }
      }
      
      function updateTurnIndicator() {
        const whiteCard = document.getElementById('whitePlayer');
        const blackCard = document.getElementById('blackPlayer');
        
        // Remove current turn indicators
        whiteCard.classList.remove('current-turn');
        blackCard.classList.remove('current-turn');
        whiteCard.querySelector('.turn-indicator')?.remove();
        blackCard.querySelector('.turn-indicator')?.remove();
        
        if (gameData.status === 'active') {
          const currentTurn = getCurrentTurn();
          const currentPlayerCard = document.getElementById(`${currentTurn}Player`);
          currentPlayerCard.classList.add('current-turn');
          
          // Add turn indicator dot
          const indicator = document.createElement('div');
          indicator.className = 'turn-indicator';
          currentPlayerCard.querySelector('.player-avatar').appendChild(indicator);
        }
      }
      
      function getCurrentTurn() {
        // Parse FEN to get current turn
        const fenParts = gameData.fen.split(' ');
        return fenParts[1] === 'w' ? 'white' : 'black';
      }
      
      function updateMoveHistory() {
        const moveListEl = document.getElementById('moveList');
        const moves = gameData.moves || [];
        
        if (moves.length === 0) {
          moveListEl.innerHTML = `
            <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
              No moves yet. Game starting...
            </div>
          `;
          return;
        }
        
        let html = '';
        for (let i = 0; i < moves.length; i += 2) {
          const moveNumber = Math.floor(i / 2) + 1;
          const whiteMove = moves[i];
          const blackMove = moves[i + 1];
          
          html += `
            <div class="move-pair">
              <span class="move-number">${moveNumber}.</span>
              <span class="move-white" data-move-index="${i}">${whiteMove.notation}</span>
              <span class="move-black" data-move-index="${i + 1}">
                ${blackMove ? blackMove.notation : ''}
              </span>
            </div>
          `;
        }
        
        moveListEl.innerHTML = html;
        
        // Scroll to bottom
        const historyEl = document.getElementById('moveHistory');
        historyEl.scrollTop = historyEl.scrollHeight;
      }
      
      function updateGameStatus() {
        const statusMessageEl = document.getElementById('statusMessage');
        const statusDetailsEl = document.getElementById('statusDetails');
        
        if (gameData.status === 'waiting') {
          statusMessageEl.textContent = 'Waiting for opponent';
          statusDetailsEl.textContent = 'Game will start when black player joins';
        } else if (gameData.status === 'active') {
          const currentTurn = getCurrentTurn();
          statusMessageEl.textContent = 'Game in progress';
          statusDetailsEl.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)} to move`;
        } else if (gameData.status === 'finished') {
          if (gameData.winner) {
            const winnerColor = gameData.winner === gameData.white_player ? 'White' : 'Black';
            statusMessageEl.textContent = `${winnerColor} wins!`;
            statusDetailsEl.textContent = 'Game completed';
          } else {
            statusMessageEl.textContent = 'Game drawn';
            statusDetailsEl.textContent = 'Game ended in a draw';
          }
        }
      }
      
      function renderBoard() {
        const boardEl = document.getElementById('chessBoard');
        if (!boardEl) {
          console.error('Chess board element not found!');
          return;
        }
        
        console.log('Rendering board with FEN:', gameData?.fen);
        boardEl.innerHTML = '';
        
        // Create squares
        for (let rank = 8; rank >= 1; rank--) {
          for (let file = 1; file <= 8; file++) {
            const square = document.createElement('div');
            const fileChar = String.fromCharCode(96 + file); // a-h
            const squareName = fileChar + rank;
            
            square.className = `chess-square ${(rank + file) % 2 === 0 ? 'dark' : 'light'}`;
            square.dataset.square = squareName;
            
            // Add coordinate labels
            if (rank === 1) {
              const fileLabel = document.createElement('div');
              fileLabel.className = 'coord-label coord-file';
              fileLabel.textContent = fileChar;
              square.appendChild(fileLabel);
            }
            
            if (file === 1) {
              const rankLabel = document.createElement('div');
              rankLabel.className = 'coord-label coord-rank';
              rankLabel.textContent = rank;
              square.appendChild(rankLabel);
            }
            
            // Add piece if present
            const piece = getPieceAtSquare(squareName);
            if (piece) {
              console.log(`Placing piece ${piece} at ${squareName}`);
              const pieceEl = document.createElement('div');
              const isWhitePiece = piece === piece.toUpperCase();
              pieceEl.className = `chess-piece ${isWhitePiece ? 'white-piece' : 'black-piece'}`;
              pieceEl.textContent = getPieceUnicode(piece);
              pieceEl.dataset.piece = piece;
              square.appendChild(pieceEl);
            }
            
            boardEl.appendChild(square);
          }
        }
        
        console.log('Board rendered, total squares:', boardEl.children.length);
        setupBoardEventListeners();
      }
      
      function getPieceAtSquare(squareName) {
        // Parse FEN to get piece at specific square
        if (!gameData || !gameData.fen) {
          console.warn('No game data or FEN available');
          return null;
        }
        
        const fenParts = gameData.fen.split(' ');
        const placement = fenParts[0];
        const ranks = placement.split('/');
        
        const file = squareName.charCodeAt(0) - 97; // a=0, b=1, etc.
        const rank = parseInt(squareName[1]) - 1; // 1-8 to 0-7
        const rankString = ranks[7 - rank]; // FEN ranks are from 8 to 1
        
        let currentFile = 0;
        for (const char of rankString) {
          if (/\d/.test(char)) {
            currentFile += parseInt(char);
          } else {
            if (currentFile === file) {
              return char;
            }
            currentFile++;
          }
        }
        
        return null;
      }
      
      function getPieceUnicode(piece) {
        const pieces = {
          'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
          'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
        return pieces[piece] || '';
      }

      function getPieceImageName(piece) {
        // Convert piece notation to image filename
        const color = piece === piece.toUpperCase() ? 'w' : 'b';
        const pieceType = piece.toLowerCase();
        
        const pieceMap = {
          'k': 'K', 'q': 'Q', 'r': 'R', 'b': 'B', 'n': 'N', 'p': 'P'
        };
        
        return `${color}${pieceMap[pieceType]}.png`;
      }
      
      function setupBoardEventListeners() {
        const squares = document.querySelectorAll('.chess-square');
        console.log('🎯 Setting up board event listeners for', squares.length, 'squares');
        
        squares.forEach(square => {
          square.addEventListener('click', handleSquareClick);
        });
        
        console.log('✅ Board event listeners set up');
      }
      
      async function handleSquareClick(event) {
        console.log('🎯 Square clicked!', event.currentTarget.dataset.square);
        const square = event.currentTarget;
        const squareName = square.dataset.square;
        
        console.log('🎮 Current game state:', {
          gameData: gameData?.status,
          currentUser: currentUser?.id,
          whitePlayer: gameData?.white_player,
          blackPlayer: gameData?.black_player
        });
        
        // Check if it's the player's turn
        if (!isPlayerTurn()) {
          console.log('❌ Not player turn');
          api.showToast("It's not your turn!", 'info');
          return;
        }
        
        console.log('✅ Player turn confirmed');
        
        if (!selectedSquare) {
          // First click - select piece
          const piece = getPieceAtSquare(squareName);
          console.log('🎯 First click - piece at square:', piece);
          if (piece && isOwnPiece(piece)) {
            console.log('✅ Valid piece selected');
            selectSquare(squareName);
            highlightPossibleMoves(squareName);
          } else {
            console.log('❌ Invalid piece or not own piece');
          }
        } else {
          // Second click - make move or select different piece
          console.log('🎯 Second click - selected square:', selectedSquare, 'target:', squareName);
          if (squareName === selectedSquare) {
            // Deselect
            console.log('🔄 Deselecting piece');
            clearSelection();
          } else if (isPossibleMove(squareName)) {
            // Make move
            console.log('✅ Making move from', selectedSquare, 'to', squareName);
            await makeMove(selectedSquare, squareName);
          } else {
            // Select different piece
            const piece = getPieceAtSquare(squareName);
            console.log('🎯 Attempting to select different piece:', piece);
            if (piece && isOwnPiece(piece)) {
              console.log('✅ Selecting different piece');
              clearSelection();
              selectSquare(squareName);
              highlightPossibleMoves(squareName);
            } else {
              console.log('🔄 Clearing selection');
              clearSelection();
            }
          }
        }
      }
      
      function isPlayerTurn() {
        if (!gameData || gameData.status !== 'active') {
          console.log('❌ Game not active or no game data:', gameData?.status);
          return false;
        }
        
        const currentTurn = getCurrentTurn();
        const isWhitePlayer = currentUser && currentUser.id === gameData.white_player;
        const isBlackPlayer = currentUser && currentUser.id === gameData.black_player;
        
        console.log('🔍 Turn check:', {
          currentTurn,
          currentUserId: currentUser?.id,
          whitePlayerId: gameData.white_player,
          blackPlayerId: gameData.black_player,
          isWhitePlayer,
          isBlackPlayer,
          result: (currentTurn === 'white' && isWhitePlayer) || (currentTurn === 'black' && isBlackPlayer)
        });
        
        return (currentTurn === 'white' && isWhitePlayer) || 
               (currentTurn === 'black' && isBlackPlayer);
      }
      
      function isOwnPiece(piece) {
        if (!currentUser) {
          console.log('❌ No current user');
          return false;
        }
        
        const isWhitePlayer = currentUser.id === gameData.white_player;
        const isWhitePiece = piece === piece.toUpperCase();
        
        console.log('🔍 Piece ownership check:', {
          piece,
          currentUserId: currentUser.id,
          whitePlayerId: gameData.white_player,
          isWhitePlayer,
          isWhitePiece,
          result: (isWhitePlayer && isWhitePiece) || (!isWhitePlayer && !isWhitePiece)
        });
        
        return (isWhitePlayer && isWhitePiece) || (!isWhitePlayer && !isWhitePiece);
      }
      
      function selectSquare(squareName) {
        selectedSquare = squareName;
        const square = document.querySelector(`[data-square="${squareName}"]`);
        square.classList.add('selected');
      }
      
      function clearSelection() {
        if (selectedSquare) {
          const square = document.querySelector(`[data-square="${selectedSquare}"]`);
          square?.classList.remove('selected');
          selectedSquare = null;
        }
        
        // Clear all move highlights
        document.querySelectorAll('.possible-move, .possible-capture').forEach(square => {
          square.classList.remove('possible-move', 'possible-capture');
        });
        possibleMoves = [];
      }
      
      async function highlightPossibleMoves(squareName) {
        try {
          // Get legal moves from backend
          const response = await api.getLegalMoves(gameId, squareName);
          if (response.ok) {
            possibleMoves = response.data.moves.map(move => ({
              to: move.to,
              capture: move.capture || false
            }));
            
            possibleMoves.forEach(move => {
              const square = document.querySelector(`[data-square="${move.to}"]`);
              if (square) {
                square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
              }
            });
          } else {
            // Fallback to basic move highlighting
            possibleMoves = calculateBasicMoves(squareName);
            possibleMoves.forEach(move => {
              const square = document.querySelector(`[data-square="${move.to}"]`);
              if (square) {
                square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
              }
            });
          }
        } catch (error) {
          console.warn('Failed to get legal moves from backend, using fallback');
          possibleMoves = calculateBasicMoves(squareName);
          possibleMoves.forEach(move => {
            const square = document.querySelector(`[data-square="${move.to}"]`);
            if (square) {
              square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
            }
          });
        }
      }
      
      function calculateBasicMoves(squareName) {
        // Simplified move calculation - fallback only
        const moves = [];
        const piece = getPieceAtSquare(squareName);
        
        if (!piece) return moves;
        
        const file = squareName.charCodeAt(0) - 97;
        const rank = parseInt(squareName[1]) - 1;
        
        // Basic pawn moves only
        if (piece.toLowerCase() === 'p') {
          const direction = piece === 'P' ? 1 : -1;
          const newRank = rank + direction;
          
          if (newRank >= 0 && newRank < 8) {
            const newSquare = String.fromCharCode(97 + file) + (newRank + 1);
            if (!getPieceAtSquare(newSquare)) {
              moves.push({ to: newSquare, capture: false });
              
              // Double pawn move from starting position
              const startingRank = piece === 'P' ? 1 : 6;
              if (rank === startingRank) {
                const doubleRank = rank + (direction * 2);
                if (doubleRank >= 0 && doubleRank < 8) {
                  const doubleSquare = String.fromCharCode(97 + file) + (doubleRank + 1);
                  if (!getPieceAtSquare(doubleSquare)) {
                    moves.push({ to: doubleSquare, capture: false });
                  }
                }
              }
            }
          }
        }
        
        return moves;
      }
      
      function isPossibleMove(squareName) {
        return possibleMoves.some(move => move.to === squareName);
      }
      
      async function makeMove(from, to) {
        try {
          clearSelection();
          showBoardLoading(true);
          
          // Check if move requires promotion
          const piece = getPieceAtSquare(from);
          const isPromotion = piece && piece.toLowerCase() === 'p' && 
                             (to[1] === '8' || to[1] === '1');
          
          let promotion = null;
          if (isPromotion) {
            promotion = await showPromotionDialog();
            if (!promotion) {
              showBoardLoading(false);
              return;
            }
          }
          
          const response = await api.makeMove(gameId, from, to, promotion);
          
          if (response.ok) {
            gameData = response.data.game;
            
            // Update timer data if provided in response
            if (response.data.timer) {
              gameTimerData = response.data.timer;
              lastTimerUpdate = Date.now();
            }
            
            updateGameDisplay();
            renderBoard();
            updateTimerDisplay();
            
            // Restart timer updates if game is still active
            if (gameData.status === 'active') {
              startTimerUpdates();
            } else {
              stopTimerUpdates();
            }
            
            api.showSuccess('Move made successfully!');
            
            // Check if it's a computer game and it's the computer's turn
            await handleComputerTurn();
          } else {
            api.showError(api.formatError(response));
          }
        } catch (error) {
          console.error('Move error:', error);
          api.showError('Failed to make move');
        } finally {
          showBoardLoading(false);
        }
      }
      
      // Computer Chess Functions
      async function handleComputerTurn() {
        try {
          if (!isComputerGame() || !isComputerTurn()) {
            return;
          }
          
          // Small delay for better UX
          setTimeout(async () => {
            await makeComputerMove();
          }, 1000);
          
        } catch (error) {
          console.error('Error handling computer turn:', error);
        }
      }
      
      function isComputerGame() {
        if (!gameData) return false;
        
        // Check if either player is a computer
        const isWhiteComputer = gameData.white_player && 
          (gameData.white_player.username === 'computer_white' || 
           gameData.white_player.first_name === 'Computer');
        const isBlackComputer = gameData.black_player && 
          (gameData.black_player.username === 'computer_black' || 
           gameData.black_player.first_name === 'Computer');
        
        return isWhiteComputer || isBlackComputer;
      }
      
      function isComputerTurn() {
        if (!gameData || !currentUser) return false;
        
        const currentTurn = getCurrentTurn();
        
        if (currentTurn === 'white') {
          return gameData.white_player && 
            gameData.white_player.username !== currentUser.username &&
            (gameData.white_player.username === 'computer_white' || 
             gameData.white_player.first_name === 'Computer');
        } else {
          return gameData.black_player && 
            gameData.black_player.username !== currentUser.username &&
            (gameData.black_player.username === 'computer_black' || 
             gameData.black_player.first_name === 'Computer');
        }
      }
      
      async function makeComputerMove() {
        try {
          showBoardLoading(true);
          
          // Get difficulty from URL params or use default
          const urlParams = new URLSearchParams(window.location.search);
          const difficulty = urlParams.get('difficulty') || 'medium';
          
          console.log(`Making computer move with difficulty: ${difficulty}`);
          
          const response = await api.makeComputerMove(gameId, difficulty);
          
          if (response.ok) {
            gameData = response.data.game;
            
            // Update timer data if provided
            if (response.data.timer) {
              gameTimerData = response.data.timer;
              lastTimerUpdate = Date.now();
            }
            
            updateGameDisplay();
            renderBoard();
            updateTimerDisplay();
            
            // Show computer move info
            const moveInfo = response.data.computer_move;
            const engineInfo = response.data.engine_info;
            
            console.log('Computer move:', moveInfo);
            console.log('Engine info:', engineInfo);
            
            api.showSuccess(
              `Computer moved: ${moveInfo.from_square} → ${moveInfo.to_square} (${moveInfo.notation})`,
              3000
            );
            
            // Continue timer updates if game is still active
            if (gameData.status === 'active') {
              startTimerUpdates();
            } else {
              stopTimerUpdates();
              
              // Show game over message
              if (response.data.game_status && response.data.game_status.is_game_over) {
                if (response.data.game_status.is_checkmate) {
                  const winner = getCurrentTurn() === 'white' ? 'Black' : 'White';
                  api.showSuccess(`Checkmate! ${winner} wins!`, 5000);
                } else if (response.data.game_status.is_stalemate) {
                  api.showSuccess('Stalemate! The game is a draw.', 5000);
                }
              }
            }
            
          } else {
            api.showError(`Computer move failed: ${api.formatError(response)}`);
          }
          
        } catch (error) {
          console.error('Error making computer move:', error);
          api.showError('Failed to make computer move');
        } finally {
          showBoardLoading(false);
        }
      }
      
      function getCurrentTurn() {
        if (!gameTimerData) return 'white';
        return gameTimerData.current_turn;
      }
      
      function showPromotionDialog() {
        return new Promise((resolve) => {
          const dialog = document.getElementById('promotionDialog');
          dialog.classList.add('show');
          
          const pieces = dialog.querySelectorAll('.promotion-piece');
          pieces.forEach(piece => {
            piece.onclick = () => {
              dialog.classList.remove('show');
              resolve(piece.dataset.piece);
            };
          });
        });
      }
      
      function setupEventListeners() {
        // Back button navigation
        document.querySelector('.back-btn').addEventListener('click', (e) => {
          e.preventDefault();
          const route = e.currentTarget.dataset.route;
          navigateToRoute(route);
        });
        
        // Game controls
        document.getElementById('offerDrawBtn').addEventListener('click', () => {
          api.showToast('Draw offer feature coming soon!', 'info');
        });
        
        document.getElementById('resignBtn').addEventListener('click', () => {
          if (confirm('Are you sure you want to resign?')) {
            api.showToast('Resignation feature coming soon!', 'info');
          }
        });
        
        document.getElementById('flipBoardBtn').addEventListener('click', () => {
          api.showToast('Board flip feature coming soon!', 'info');
        });
        
        document.getElementById('analysisBtn').addEventListener('click', () => {
          api.showToast('Analysis feature coming soon!', 'info');
        });
        
        // Move history clicks
        document.addEventListener('click', (e) => {
          if (e.target.classList.contains('move-white') || e.target.classList.contains('move-black')) {
            api.showToast('Move navigation coming soon!', 'info');
          }
        });
      }
      
      function setupPeriodicUpdates() {
        // Refresh game state every 3 seconds
        const gameInterval = setInterval(async () => {
          if (document.visibilityState === 'visible' && gameData?.status === 'active') {
            try {
              const response = await api.getGameDetail(gameId);
              if (response.ok && response.data.moves.length !== gameData.moves.length) {
                gameData = response.data;
                updateGameDisplay();
                renderBoard();
              }
            } catch (error) {
              console.error('Failed to refresh game:', error);
            }
          }
        }, 3000);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
          clearInterval(gameInterval);
        });
      }
      
      function showBoardLoading(show) {
        const loadingEl = document.getElementById('boardLoading');
        if (!loadingEl) {
          console.warn('boardLoading element not found');
          return;
        }
        if (show) {
          loadingEl.classList.add('show');
        } else {
          loadingEl.classList.remove('show');
        }
      }
      
      function getStatusText(status) {
        const statusMap = {
          waiting: 'Waiting',
          active: 'Active',
          finished: 'Finished'
        };
        return statusMap[status] || status;
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initGamePage);
    } else {
      initGamePage();
    }
  </script>
</body>
</html>
===== chess-platform/frontend/src/pages/game/play.js =====

===== chess-platform/frontend/src/pages/profile/profile.css =====

===== chess-platform/frontend/src/pages/profile/profile.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Profile - Chess Platform</title>
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Profile-specific styles maintaining design consistency */
    .profile-container {
      min-height: 100vh;
      background: 
        radial-gradient(ellipse at top left, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      display: flex;
      flex-direction: column;
    }

    /* Profile Header */
    .profile-header {
      height: var(--header-height);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-xl);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .profile-title {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .profile-title h1 {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin: 0;
    }

    .back-btn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: var(--font-size-sm);
      transition: all var(--transition-normal);
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-accent-primary);
      transform: translateX(-2px);
    }

    /* Profile Content */
    .profile-content {
      flex: 1;
      padding: var(--space-xl);
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: var(--space-xl);
      align-items: start;
    }

    /* Profile Card */
    .profile-card {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      overflow: hidden;
      position: sticky;
      top: calc(var(--header-height) + var(--space-xl));
    }

    .profile-banner {
      height: 120px;
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      position: relative;
    }

    .profile-info {
      padding: var(--space-xl);
      text-align: center;
      position: relative;
      margin-top: -40px;
    }

    .profile-avatar {
      width: 80px;
      height: 80px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-bold);
      font-size: 2rem;
      margin: 0 auto var(--space-md);
      border: 4px solid var(--color-bg-primary);
      box-shadow: var(--shadow-lg);
      position: relative;
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .profile-avatar:hover {
      transform: scale(1.05);
      box-shadow: var(--shadow-xl);
    }

    .avatar-upload-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      border-radius: var(--radius-full);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity var(--transition-normal);
      font-size: var(--font-size-xs);
      color: white;
      gap: var(--space-xs);
    }

    .avatar-action {
      padding: var(--space-xs) var(--space-sm);
      background: rgba(255, 255, 255, 0.2);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background var(--transition-fast);
    }

    .avatar-action:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .profile-avatar:hover .avatar-upload-overlay {
      opacity: 1;
    }

    .profile-username {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }

    .profile-rating {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-lg);
    }

    .rating-value {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-accent-primary);
    }

    .rating-change {
      font-size: var(--font-size-sm);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
      font-weight: var(--font-weight-medium);
    }

    .rating-change.positive {
      background: rgba(34, 197, 94, 0.2);
      color: var(--color-success);
    }

    .rating-change.negative {
      background: rgba(239, 68, 68, 0.2);
      color: var(--color-error);
    }

    .profile-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-md);
      margin-bottom: var(--space-lg);
    }

    .stat-item {
      text-align: center;
      padding: var(--space-md);
      background: rgba(255, 255, 255, 0.03);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-value {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-xs);
    }

    .stat-label {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .edit-profile-btn {
      width: 100%;
      padding: var(--space-md);
      background: rgba(118, 150, 86, 0.1);
      border: 1px solid var(--color-accent-primary);
      border-radius: var(--radius-md);
      color: var(--color-accent-primary);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .edit-profile-btn:hover {
      background: rgba(118, 150, 86, 0.2);
      transform: translateY(-1px);
    }

    /* Profile Content */
    .profile-main {
      display: flex;
      flex-direction: column;
      gap: var(--space-xl);
    }

    .section-card {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      overflow: hidden;
    }

    .section-header {
      padding: var(--space-lg) var(--space-xl);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .section-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .section-icon {
      font-size: var(--font-size-xl);
    }

    .section-content {
      padding: var(--space-xl);
    }

    /* Rating History Chart */
    .rating-chart {
      height: 200px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
    }

    /* Recent Games */
    .games-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .game-item {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-lg);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-md);
      transition: all var(--transition-normal);
      cursor: pointer;
    }

    .game-item:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: var(--color-accent-primary);
      transform: translateX(2px);
    }

    .game-result {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      border-radius: var(--radius-md);
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
    }

    .game-result.win {
      background: rgba(34, 197, 94, 0.2);
      color: var(--color-success);
    }

    .game-result.loss {
      background: rgba(239, 68, 68, 0.2);
      color: var(--color-error);
    }

    .game-result.draw {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .game-details {
      flex: 1;
    }

    .game-opponent {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-primary);
      margin-bottom: var(--space-xs);
    }

    .game-meta {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      display: flex;
      gap: var(--space-md);
    }

    .game-rating-change {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
    }

    .rating-up {
      background: rgba(34, 197, 94, 0.2);
      color: var(--color-success);
    }

    .rating-down {
      background: rgba(239, 68, 68, 0.2);
      color: var(--color-error);
    }

    /* Achievements */
    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: var(--space-md);
    }

    .achievement-item {
      text-align: center;
      padding: var(--space-lg);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-md);
      transition: all var(--transition-normal);
    }

    .achievement-item:hover {
      background: rgba(255, 255, 255, 0.05);
      transform: translateY(-2px);
    }

    .achievement-item.unlocked {
      border-color: var(--color-accent-primary);
      background: rgba(118, 150, 86, 0.05);
    }

    .achievement-icon {
      font-size: 2rem;
      margin-bottom: var(--space-sm);
      display: block;
    }

    .achievement-item.unlocked .achievement-icon {
      filter: none;
    }

    .achievement-item:not(.unlocked) .achievement-icon {
      filter: grayscale(100%);
      opacity: 0.3;
    }

    .achievement-title {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-xs);
    }

    .achievement-description {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
    }

    /* Edit Profile Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      width: 90%;
      max-width: 500px;
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      overflow: hidden;
      transform: scale(0.9);
      transition: transform var(--transition-normal);
    }

    .modal-overlay.show .modal-content {
      transform: scale(1);
    }

    .modal-header {
      padding: var(--space-lg) var(--space-xl);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin: 0;
    }

    .modal-close {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-full);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--color-text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-normal);
    }

    .modal-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-text-primary);
    }

    .modal-body {
      padding: var(--space-xl);
    }

    .edit-form {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .form-label {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-secondary);
    }

    .form-input {
      width: 100%;
      padding: var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      transition: all var(--transition-normal);
    }

    .form-input:focus {
      border-color: var(--color-accent-primary);
      box-shadow: 0 0 0 3px rgba(118, 150, 86, 0.1);
      background: rgba(255, 255, 255, 0.08);
    }

    .form-textarea {
      resize: vertical;
      min-height: 100px;
    }

    .modal-actions {
      display: flex;
      gap: var(--space-md);
      justify-content: flex-end;
      margin-top: var(--space-lg);
    }

    .btn-cancel {
      padding: var(--space-md) var(--space-lg);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .btn-cancel:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .btn-save {
      padding: var(--space-md) var(--space-lg);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-secondary) 100%);
      border: none;
      border-radius: var(--radius-md);
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .btn-save:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    /* Loading States */
    .loading-skeleton {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.03) 25%, rgba(255, 255, 255, 0.08) 50%, rgba(255, 255, 255, 0.03) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: var(--radius-md);
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    .skeleton-text {
      height: 1rem;
      margin-bottom: var(--space-sm);
    }

    .skeleton-title {
      height: 1.5rem;
      margin-bottom: var(--space-md);
    }

    /* Empty States */
    .empty-state {
      text-align: center;
      padding: var(--space-3xl) var(--space-xl);
      color: var(--color-text-muted);
    }

    .empty-icon {
      font-size: 3rem;
      margin-bottom: var(--space-lg);
      opacity: 0.5;
    }

    .empty-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-sm);
      color: var(--color-text-secondary);
    }

    .empty-description {
      font-size: var(--font-size-sm);
      line-height: 1.5;
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .profile-header {
      height: var(--header-height-mobile);
      padding: 0 var(--space-md);
      flex-wrap: wrap;
      gap: var(--space-sm);
    }

    .profile-title h1 {
      font-size: var(--font-size-lg);
    }

    .back-btn {
      padding: var(--space-sm) var(--space-md);
      font-size: var(--font-size-sm);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      min-width: var(--touch-target-min);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .profile-content {
      grid-template-columns: 1fr;
      gap: var(--space-md);
      padding: var(--space-md);
    }

    .profile-card {
      position: static;
      width: 100%;
      order: -1; /* Move profile card to top on mobile */
    }

    .profile-banner {
      height: 120px; /* Smaller banner on mobile */
    }

    .profile-avatar {
      width: 80px;
      height: 80px;
      font-size: var(--font-size-xl);
      border-width: 3px;
      margin-top: -40px; /* Adjust for smaller banner */
    }

    .profile-username {
      font-size: var(--font-size-lg);
      margin: var(--space-sm) 0;
    }

    .profile-rating {
      margin-bottom: var(--space-md);
    }

    .rating-value {
      font-size: var(--font-size-xl);
    }

    .profile-stats {
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .stat-item {
      text-align: center;
      padding: var(--space-sm);
    }

    .stat-value {
      font-size: var(--font-size-md);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-xs);
    }

    .stat-label {
      font-size: var(--font-size-xs);
      color: var(--color-text-secondary);
    }

    .edit-profile-btn {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
    }

    .section-card {
      margin-bottom: var(--space-md);
      border-radius: var(--radius-md);
    }

    .section-header {
      padding: var(--space-md);
      border-bottom: 1px solid var(--glass-border);
    }

    .section-title {
      font-size: var(--font-size-md);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .section-content {
      padding: var(--space-md);
    }

    .rating-chart {
      height: 200px; /* Smaller chart on mobile */
      margin-bottom: var(--space-md);
    }

    .game-row {
      padding: var(--space-md);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-sm);
    }

    .game-meta {
      flex-direction: column;
      gap: var(--space-xs);
      margin-bottom: var(--space-sm);
    }

    .game-players {
      flex-direction: column;
      gap: var(--space-sm);
      text-align: center;
    }

    .game-result {
      margin-top: var(--space-sm);
      text-align: center;
    }

    .achievements-grid {
      grid-template-columns: 1fr;
      gap: var(--space-sm);
    }

    .achievement-card {
      padding: var(--space-md);
      text-align: center;
    }

    .modal-content {
      width: calc(100vw - var(--space-lg));
      max-width: 500px;
      margin: var(--space-md);
      border-radius: var(--radius-md);
    }

    .modal-header {
      padding: var(--space-md);
    }

    .modal-body {
      padding: var(--space-md);
    }

    .modal-actions {
      padding: var(--space-md);
      gap: var(--space-sm);
    }

    .btn-primary,
    .btn-secondary {
      flex: 1;
      min-height: var(--touch-target-min);
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      border-radius: var(--radius-sm);
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .profile-header {
        height: var(--header-height);
        padding: 0 var(--space-lg);
      }

      .profile-title h1 {
        font-size: var(--font-size-xl);
      }

      .profile-content {
        padding: var(--space-lg);
        gap: var(--space-lg);
      }

      .profile-banner {
        height: 150px;
      }

      .profile-avatar {
        width: 100px;
        height: 100px;
        margin-top: -50px;
      }

      .rating-chart {
        height: 250px;
      }

      .achievements-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .game-players {
        flex-direction: row;
        justify-content: space-between;
      }

      .game-result {
        text-align: right;
        margin-top: 0;
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .profile-content {
        grid-template-columns: 300px 1fr;
        gap: var(--space-xl);
        padding: var(--space-xl);
      }

      .profile-card {
        position: sticky;
        top: calc(var(--header-height) + var(--space-lg));
        order: 0;
      }

      .profile-banner {
        height: 180px;
      }

      .profile-avatar {
        width: 120px;
        height: 120px;
        margin-top: -60px;
      }

      .rating-chart {
        height: 300px;
      }

      .achievements-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Desktop styles (1025px to 1280px) */
    @media (min-width: 1025px) {
      .profile-content {
        grid-template-columns: 350px 1fr;
        gap: var(--space-2xl);
        padding: var(--space-2xl);
      }

      .profile-banner {
        height: 200px;
      }

      .rating-chart {
        height: 350px;
      }

      .achievements-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    /* Large desktop styles (1281px and up) */
    @media (min-width: 1281px) {
      .profile-content {
        max-width: 1400px;
        margin: 0 auto;
        padding: var(--space-2xl);
      }

      .rating-chart {
        height: 400px;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .back-btn,
      .edit-profile-btn,
      .btn-primary,
      .btn-secondary,
      .avatar-action {
        min-height: var(--touch-target-min);
        padding: var(--space-md);
      }

      .game-row {
        padding: var(--space-lg);
      }

      .achievement-card {
        padding: var(--space-lg);
      }

      /* Enhanced touch areas for avatar upload */
      .avatar-upload-overlay {
        opacity: 1;
        background: rgba(0, 0, 0, 0.1);
      }

      .avatar-upload-overlay .avatar-action {
        padding: var(--space-sm) var(--space-md);
        margin: var(--space-xs);
        border-radius: var(--radius-sm);
        font-size: var(--font-size-xs);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="profile-container fade-in">
      <!-- Profile Header -->
      <header class="profile-header">
        <div class="profile-title">
          <h1>Player Profile</h1>
        </div>
        
        <a href="#" class="back-btn" data-route="/lobby">
          <span>←</span>
          <span>Back to Lobby</span>
        </a>
      </header>

      <!-- Profile Content -->
      <div class="profile-content">
        <!-- Profile Card -->
        <div class="profile-card">
          <div class="profile-banner"></div>
          <div class="profile-info">
            <div class="profile-avatar" id="profileAvatar">
              <span id="avatarText">?</span>
              <div class="avatar-upload-overlay">
                <div class="avatar-action" onclick="event.stopPropagation(); document.getElementById('avatarUpload').click()">
                  📷 Upload
                </div>
                <div class="avatar-action" id="deleteAvatarBtn" onclick="event.stopPropagation(); handleAvatarDelete()" style="display: none;">
                  🗑️ Delete
                </div>
              </div>
            </div>
            <h2 class="profile-username" id="profileUsername">Loading...</h2>
            
            <div class="profile-rating">
              <span class="rating-value" id="currentRating">----</span>
              <span class="rating-change positive" id="ratingChange" style="display: none;">
                +24
              </span>
            </div>

            <div class="profile-stats">
              <div class="stat-item">
                <div class="stat-value" id="totalGames">--</div>
                <div class="stat-label">Games</div>
              </div>
              <div class="stat-item">
                <div class="stat-value" id="winRate">--%</div>
                <div class="stat-label">Win Rate</div>
              </div>
              <div class="stat-item">
                <div class="stat-value" id="bestRating">----</div>
                <div class="stat-label">Peak Rating</div>
              </div>
            </div>

            <button class="edit-profile-btn" id="editProfileBtn">
              ✏️ Edit Profile
            </button>
          </div>
        </div>

        <!-- Profile Main Content -->
        <div class="profile-main">
          <!-- Rating History -->
          <div class="section-card">
            <div class="section-header">
              <h3 class="section-title">
                <span class="section-icon">📈</span>
                Rating History
              </h3>
            </div>
            <div class="section-content">
              <div class="rating-chart" id="ratingChart">
                📊 Rating chart will be displayed here
              </div>
              <div class="rating-stats">
                <div class="profile-stats">
                  <div class="stat-item">
                    <div class="stat-value" id="ratingGain">+0</div>
                    <div class="stat-label">This Month</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-value" id="currentStreak">0</div>
                    <div class="stat-label">Win Streak</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-value" id="bestStreak">0</div>
                    <div class="stat-label">Best Streak</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Recent Games -->
          <div class="section-card">
            <div class="section-header">
              <h3 class="section-title">
                <span class="section-icon">🎮</span>
                Recent Games
              </h3>
              <a href="#" class="view-all-link" style="color: var(--color-accent-primary); font-size: var(--font-size-sm);">
                View All
              </a>
            </div>
            <div class="section-content">
              <div class="games-list" id="recentGamesList">
                <!-- Loading skeletons -->
                <div class="loading-skeleton skeleton-text"></div>
                <div class="loading-skeleton skeleton-text"></div>
                <div class="loading-skeleton skeleton-text"></div>
              </div>
            </div>
          </div>

          <!-- Achievements -->
          <div class="section-card">
            <div class="section-header">
              <h3 class="section-title">
                <span class="section-icon">🏆</span>
                Achievements
              </h3>
            </div>
            <div class="section-content">
              <div class="achievements-grid" id="achievementsList">
                <!-- Achievements will be loaded here -->
                <div class="achievement-item unlocked">
                  <span class="achievement-icon">🎯</span>
                  <div class="achievement-title">First Game</div>
                  <div class="achievement-description">Played your first chess game</div>
                </div>
                
                <div class="achievement-item">
                  <span class="achievement-icon">🔥</span>
                  <div class="achievement-title">Hot Streak</div>
                  <div class="achievement-description">Win 5 games in a row</div>
                </div>
                
                <div class="achievement-item">
                  <span class="achievement-icon">⭐</span>
                  <div class="achievement-title">Rising Star</div>
                  <div class="achievement-description">Reach 1400 rating</div>
                </div>
                
                <div class="achievement-item">
                  <span class="achievement-icon">👑</span>
                  <div class="achievement-title">Chess Master</div>
                  <div class="achievement-description">Reach 1800 rating</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Edit Profile Modal -->
      <div class="modal-overlay" id="editProfileModal">
        <div class="modal-content">
          <div class="modal-header">
            <h3 class="modal-title">Edit Profile</h3>
            <button class="modal-close" id="closeModalBtn">×</button>
          </div>
          <div class="modal-body">
            <form class="edit-form" id="editForm">
              <div class="form-group">
                <label class="form-label">Display Name</label>
                <input type="text" class="form-input" id="editUsername" placeholder="Enter your username" required>
              </div>
              
              <div class="form-group">
                <label class="form-label">Bio</label>
                <textarea class="form-input form-textarea" id="editBio" placeholder="Tell us about yourself..."></textarea>
              </div>
              
              <div class="form-group">
                <label class="form-label">Country</label>
                <select class="form-input" id="editCountry">
                  <option value="">Select Country</option>
                  <option value="US">United States</option>
                  <option value="IN">India</option>
                  <option value="UK">United Kingdom</option>
                  <option value="DE">Germany</option>
                  <option value="FR">France</option>
                  <option value="CA">Canada</option>
                  <option value="AU">Australia</option>
                  <!-- Add more countries as needed -->
                </select>
              </div>

              <div class="modal-actions">
                <button type="button" class="btn-cancel" id="cancelEditBtn">Cancel</button>
                <button type="submit" class="btn-save">Save Changes</button>
              </div>
            </form>
          </div>
        </div>
      </div>

      <!-- Hidden file input for avatar upload -->
      <input type="file" id="avatarUpload" accept="image/*" style="display: none;">
    </div>
  </div>

  <script src="../../utils/api.js"></script>
  <script src="../../utils/router.js"></script>
  <script>
    // Profile page controller
    function initProfilePage() {
      let currentUser = null;
      let userStats = null;
      let recentGames = [];
      
      // Initialize profile
      initializeProfile();
      
      async function initializeProfile() {
        try {
          // Load user profile and stats
          await loadUserProfile();
          await loadUserStats();
          await loadRecentGames();
          
          // Set up router routes
          setupRoutes();
          
          // Set up event listeners
          setupEventListeners();
          
        } catch (error) {
          console.error('Failed to initialize profile:', error);
          api.showError('Failed to load profile data');
        }
      }
      
      // Set up router routes
      function setupRoutes() {
        console.log('Setting up routes for profile page...');
        
        // Add route for lobby
        router.addRoute('/lobby', {
          title: 'Lobby - Chess Platform',
          controller: () => {
            window.location.href = '/lobby/';
          },
          requiresAuth: true
        });
        
        // Add route for profile (current page)
        router.addRoute('/profile', {
          title: 'Profile - Chess Platform',
          controller: () => {
            window.location.reload();
          },
          requiresAuth: true
        });
        
        // Add route for puzzles
        router.addRoute('/puzzles', {
          title: 'Puzzles - Chess Platform',
          controller: () => {
            window.location.href = '/puzzles/';
          },
          requiresAuth: true
        });
        
        // Add route for game
        router.addRoute('/game/:id', {
          title: 'Game - Chess Platform',
          controller: () => {
            window.location.href = '/play/';
          },
          requiresAuth: true
        });
        
        console.log('Routes configured for profile page');
      }
      
      async function loadUserProfile() {
        try {
          const response = await api.getUserProfile();
          if (response.ok) {
            currentUser = response.data;
            updateProfileDisplay();
          }
        } catch (error) {
          console.error('Failed to load user profile:', error);
          // Show skeleton/loading state
          showLoadingState();
        }
      }
      
      function updateProfileDisplay() {
        if (!currentUser) return;
        
        // Update profile info
        document.getElementById('profileUsername').textContent = currentUser.username;
        
        // Update avatar display
        const avatarElement = document.getElementById('profileAvatar');
        const avatarText = document.getElementById('avatarText');
        const deleteBtn = document.getElementById('deleteAvatarBtn');
        
        if (currentUser.avatar) {
          // User has an avatar
          if (avatarElement && avatarText) {
            avatarElement.style.backgroundImage = `url(${currentUser.avatar})`;
            avatarElement.style.backgroundSize = 'cover';
            avatarElement.style.backgroundPosition = 'center';
            avatarText.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'block';
          }
        } else {
          // No avatar, show initials
          if (avatarText) {
            avatarText.textContent = currentUser.username.charAt(0).toUpperCase();
            avatarText.style.display = 'block';
            if (deleteBtn) deleteBtn.style.display = 'none';
          }
          if (avatarElement) {
            avatarElement.style.backgroundImage = 'none';
          }
        }
        
        document.getElementById('currentRating').textContent = currentUser.rating || 1200;
        
        // Update stats
        document.getElementById('totalGames').textContent = currentUser.games_played || 0;
        const winRate = currentUser.games_played > 0 
          ? Math.round((currentUser.games_won / currentUser.games_played) * 100)
          : 0;
        document.getElementById('winRate').textContent = winRate + '%';
        document.getElementById('bestRating').textContent = currentUser.best_rating || currentUser.rating || 1200;
      }
      
      async function loadUserStats() {
        try {
          // Mock stats for now - replace with actual API
          userStats = {
            ratingGain: Math.floor(Math.random() * 100) - 50,
            currentStreak: Math.floor(Math.random() * 10),
            bestStreak: Math.floor(Math.random() * 15) + 5
          };
          
          updateStatsDisplay();
        } catch (error) {
          console.error('Failed to load user stats:', error);
        }
      }
      
      function updateStatsDisplay() {
        if (!userStats) return;
        
        const ratingGainEl = document.getElementById('ratingGain');
        ratingGainEl.textContent = userStats.ratingGain >= 0 
          ? `+${userStats.ratingGain}` 
          : `${userStats.ratingGain}`;
        ratingGainEl.style.color = userStats.ratingGain >= 0 
          ? 'var(--color-success)' 
          : 'var(--color-error)';
        
        document.getElementById('currentStreak').textContent = userStats.currentStreak;
        document.getElementById('bestStreak').textContent = userStats.bestStreak;
      }
      
      async function loadRecentGames() {
        try {
          const response = await api.getGames();
          if (response.ok) {
            recentGames = response.data.slice(0, 5); // Last 5 games
            updateRecentGamesDisplay();
          }
        } catch (error) {
          console.error('Failed to load recent games:', error);
          showEmptyGames();
        }
      }
      
      function updateRecentGamesDisplay() {
        const gamesListEl = document.getElementById('recentGamesList');
        
        if (!recentGames || recentGames.length === 0) {
          showEmptyGames();
          return;
        }
        
        gamesListEl.innerHTML = recentGames.map(game => {
          const isWhite = currentUser && currentUser.id === game.white_player;
          const opponent = isWhite ? game.black_player_username : game.white_player_username;
          const opponentRating = isWhite ? game.black_player_rating : game.white_player_rating;
          
          // Determine result
          let result = 'draw';
          let resultSymbol = '½';
          let ratingChange = 0;
          
          if (game.winner) {
            if ((isWhite && game.winner === game.white_player) || 
                (!isWhite && game.winner === game.black_player)) {
              result = 'win';
              resultSymbol = '1';
              ratingChange = Math.floor(Math.random() * 20) + 5;
            } else {
              result = 'loss';
              resultSymbol = '0';
              ratingChange = -(Math.floor(Math.random() * 20) + 5);
            }
          }
          
          return `
            <div class="game-item" data-game-id="${game.id}">
              <div class="game-result ${result}">
                ${resultSymbol}
              </div>
              <div class="game-details">
                <div class="game-opponent">vs ${opponent || 'Anonymous'}</div>
                <div class="game-meta">
                  <span>Rating: ${opponentRating || '----'}</span>
                  <span>${getTimeAgo(game.created_at)}</span>
                  <span>${isWhite ? 'White' : 'Black'}</span>
                </div>
              </div>
              <div class="game-rating-change ${ratingChange >= 0 ? 'rating-up' : 'rating-down'}">
                ${ratingChange >= 0 ? '+' : ''}${ratingChange}
              </div>
            </div>
          `;
        }).join('');
        
        // Add click handlers
        document.querySelectorAll('.game-item').forEach(item => {
          item.addEventListener('click', () => {
            const gameId = item.dataset.gameId;
            router.navigate(`/game/${gameId}`);
          });
        });
      }
      
      function showEmptyGames() {
        const gamesListEl = document.getElementById('recentGamesList');
        gamesListEl.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">🎮</div>
            <div class="empty-title">No Recent Games</div>
            <div class="empty-description">Start playing to see your game history here!</div>
          </div>
        `;
      }
      
      function showLoadingState() {
        // Show skeleton loading states
        document.getElementById('profileUsername').textContent = 'Loading...';
        document.getElementById('currentRating').textContent = '----';
      }
      
      function setupEventListeners() {
        // Back button
        document.querySelector('.back-btn').addEventListener('click', (e) => {
          e.preventDefault();
          window.location.href = '/lobby/';
        });
        
        // Edit profile button
        document.getElementById('editProfileBtn').addEventListener('click', () => {
          openEditModal();
        });
        
        // Modal controls
        document.getElementById('closeModalBtn').addEventListener('click', closeEditModal);
        document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
        
        // Modal overlay click
        document.getElementById('editProfileModal').addEventListener('click', (e) => {
          if (e.target.id === 'editProfileModal') {
            closeEditModal();
          }
        });
        
        // Avatar upload - file input change handler only
        document.getElementById('avatarUpload').addEventListener('change', handleAvatarUpload);
        
        // Edit form submission
        document.getElementById('editForm').addEventListener('submit', handleProfileUpdate);
      }
      
      function openEditModal() {
        const modal = document.getElementById('editProfileModal');
        modal.classList.add('show');
        
        // Populate form with current data
        if (currentUser) {
          document.getElementById('editUsername').value = currentUser.username || '';
          document.getElementById('editBio').value = currentUser.bio || '';
          document.getElementById('editCountry').value = currentUser.country || '';
        }
      }
      
      function closeEditModal() {
        const modal = document.getElementById('editProfileModal');
        modal.classList.remove('show');
      }
      
      async function handleAvatarUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Validate file size (5MB limit)
        if (file.size > 5 * 1024 * 1024) {
          api.showError('File size too large. Maximum size is 5MB.');
          return;
        }

        // Validate file type
        const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];
        if (!allowedTypes.includes(file.type)) {
          api.showError('Invalid file type. Only JPEG, PNG and GIF files are allowed.');
          return;
        }
        
        try {
          api.showToast('Uploading avatar...', 'info');
          
          const response = await api.uploadAvatar(file);
          
          if (response.avatar_url) {
            // Update avatar display
            const avatarElement = document.getElementById('profileAvatar');
            const avatarText = document.getElementById('avatarText');
            const deleteBtn = document.getElementById('deleteAvatarBtn');
            
            if (avatarElement && avatarText) {
              avatarElement.style.backgroundImage = `url(${response.avatar_url})`;
              avatarElement.style.backgroundSize = 'cover';
              avatarElement.style.backgroundPosition = 'center';
              avatarText.style.display = 'none';
              if (deleteBtn) deleteBtn.style.display = 'block';
            }
          }
          
          api.showSuccess('Avatar updated successfully!');
          
        } catch (error) {
          console.error('Avatar upload error:', error);
          api.showError(error.error || 'Failed to upload avatar');
        }
      }

      async function handleAvatarDelete() {
        if (!confirm('Are you sure you want to delete your avatar?')) {
          return;
        }

        try {
          api.showToast('Deleting avatar...', 'info');
          
          await api.deleteAvatar();
          
          // Reset avatar display
          const avatarElement = document.getElementById('profileAvatar');
          const avatarText = document.getElementById('avatarText');
          const deleteBtn = document.getElementById('deleteAvatarBtn');
          
          if (avatarElement && avatarText) {
            avatarElement.style.backgroundImage = 'none';
            avatarText.style.display = 'block';
            avatarText.textContent = currentUser?.username?.charAt(0).toUpperCase() || '?';
            if (deleteBtn) deleteBtn.style.display = 'none';
          }
          
          api.showSuccess('Avatar deleted successfully!');
          
        } catch (error) {
          console.error('Avatar delete error:', error);
          api.showError(error.error || 'Failed to delete avatar');
        }
      }
      
      async function handleProfileUpdate(event) {
        event.preventDefault();
        
        const formData = new FormData(event.target);
        const profileData = {
          username: document.getElementById('editUsername').value,
          bio: document.getElementById('editBio').value,
          country: document.getElementById('editCountry').value
        };
        
        try {
          api.showToast('Updating profile...', 'info');
          
          // Mock update - replace with actual API call
          setTimeout(() => {
            currentUser = { ...currentUser, ...profileData };
            updateProfileDisplay();
            closeEditModal();
            api.showSuccess('Profile updated successfully!');
          }, 1000);
          
        } catch (error) {
          console.error('Profile update error:', error);
          api.showError('Failed to update profile');
        }
      }
      
      // Utility functions
      function getTimeAgo(dateString) {
        const now = new Date();
        const date = new Date(dateString);
        const diffInMs = now - date;
        const diffInMins = Math.floor(diffInMs / 60000);
        
        if (diffInMins < 1) return 'Just now';
        if (diffInMins < 60) return `${diffInMins}m ago`;
        
        const diffInHours = Math.floor(diffInMins / 60);
        if (diffInHours < 24) return `${diffInHours}h ago`;
        
        const diffInDays = Math.floor(diffInHours / 24);
        return `${diffInDays}d ago`;
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initProfilePage);
    } else {
      initProfilePage();
    }
  </script>
</body>
</html>
===== chess-platform/frontend/src/pages/profile/profile.js =====

===== chess-platform/frontend/src/pages/puzzles/puzzles.css =====

===== chess-platform/frontend/src/pages/puzzles/puzzles.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Puzzle | Chess Platform</title>
  <style>
    /* ==== Base Theme ==== */
    :root {
      --bg: #0f0f0f;
      --glass: rgba(255, 255, 255, 0.08);
      --glass-border: rgba(255, 255, 255, 0.15);
      --text: #f1f1f1;
      --text-light: #bdbdbd;
      --accent: #769656;
      --danger: #c23b3b;
      --radius: 1rem;
      --transition: 0.25s ease;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* ==== Glass Elements ==== */
    .glass {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(12px);
      border-radius: var(--radius);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
    }

    /* ==== Header ==== */
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 2rem;
      margin-bottom: 1.5rem;
    }
    .logo {
      font-weight: bold;
      font-size: 1.3rem;
      color: var(--accent);
    }
    .nav-links a {
      margin-left: 1.5rem;
      text-decoration: none;
      color: var(--text-light);
      transition: var(--transition);
    }
    .nav-links a:hover,
    .nav-links a.active {
      color: var(--accent);
    }

    /* ==== Layout ==== */
    .puzzle-layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 2rem;
      padding: 0 2rem;
      flex: 1;
    }
    .puzzle-board {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
    }
    .chessboard {
      width: 100%;
      max-width: 500px;
      aspect-ratio: 1/1;
      background: #1e1e1e;
      border-radius: var(--radius);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .chessboard p {
      font-size: 0.9rem;
      color: var(--text-light);
      text-align: center;
      padding: 1rem;
    }
    .puzzle-status {
      text-align: center;
    }
    .puzzle-status h2 {
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
    }
    .goal-text {
      color: var(--accent);
      font-weight: 600;
    }

    /* ==== Sidebar ==== */
    .puzzle-sidebar {
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .sidebar-title {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
    }
    .sidebar-actions {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 2rem;
    }
    .btn {
      padding: 0.7rem 1rem;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 600;
      transition: var(--transition);
    }
    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-primary:hover { background: #5c7e48; }
    .btn-secondary {
      background: #333;
      color: var(--text);
    }
    .btn-secondary:hover { background: #444; }
    .btn-danger {
      background: var(--danger);
      color: #fff;
    }
    .btn-danger:hover { background: #9d2c2c; }

    .puzzle-info h3 {
      margin-bottom: 0.5rem;
      color: var(--accent);
    }
    .puzzle-info p {
      margin: 0.3rem 0;
      font-size: 0.95rem;
      color: var(--text-light);
    }

    /* ==== Footer ==== */
    .app-footer {
      text-align: center;
      padding: 1rem;
      margin-top: 2rem;
      font-size: 0.9rem;
      color: var(--text-light);
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .app-header {
      height: var(--header-height-mobile);
      padding: 0 var(--space-md);
      flex-wrap: wrap;
      gap: var(--space-sm);
    }

    .logo {
      font-size: var(--font-size-lg);
    }

    .nav-links {
      display: none; /* Hide navigation on mobile, replace with hamburger menu */
    }

    .puzzle-layout {
      grid-template-columns: 1fr;
      gap: var(--space-md);
      padding: var(--space-md);
    }

    .puzzle-board {
      order: 1;
      padding: var(--space-md);
      border-radius: var(--radius-md);
    }

    .chessboard {
      width: min(95vw, 95vh);
      height: min(95vw, 95vh);
      margin: 0 auto;
      border-radius: var(--radius-sm);
    }

    .puzzle-sidebar {
      order: 2;
      margin-top: 0;
      padding: var(--space-md);
      border-radius: var(--radius-md);
    }

    .puzzle-status {
      padding: var(--space-md);
      text-align: center;
      border-radius: var(--radius-sm);
      margin-top: var(--space-md);
    }

    .status-text {
      font-size: var(--font-size-sm);
    }

    .puzzle-info h3 {
      font-size: var(--font-size-md);
      margin-bottom: var(--space-sm);
    }

    .puzzle-info p {
      font-size: var(--font-size-sm);
      line-height: 1.5;
      margin-bottom: var(--space-sm);
    }

    .puzzle-controls {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }

    .puzzle-controls button {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-sm);
      min-height: var(--touch-target-min);
      border-radius: var(--radius-md);
    }

    .puzzle-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-sm);
      margin-top: var(--space-md);
      padding: var(--space-md);
      border-radius: var(--radius-sm);
    }

    .stat-item {
      text-align: center;
      padding: var(--space-sm);
    }

    .stat-value {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      margin-bottom: var(--space-xs);
    }

    .stat-label {
      font-size: var(--font-size-xs);
      opacity: 0.8;
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .app-header {
        height: var(--header-height);
        padding: 0 var(--space-lg);
      }

      .logo {
        font-size: var(--font-size-xl);
      }

      .nav-links {
        display: flex;
        gap: var(--space-lg);
      }

      .nav-links a {
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-sm);
        min-height: var(--touch-target-min);
        display: flex;
        align-items: center;
      }

      .puzzle-layout {
        gap: var(--space-lg);
        padding: var(--space-lg);
      }

      .chessboard {
        width: min(85vw, 85vh);
        height: min(85vw, 85vh);
      }

      .puzzle-controls {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .puzzle-controls button {
        flex: 1;
        min-width: 120px;
      }

      .puzzle-stats {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .puzzle-layout {
        grid-template-columns: 1fr 300px;
        gap: var(--space-xl);
        padding: var(--space-xl);
      }

      .puzzle-board {
        order: 0;
      }

      .puzzle-sidebar {
        order: 1;
        margin-top: 0;
      }

      .chessboard {
        width: min(75vw, 75vh);
        height: min(75vw, 75vh);
      }

      .puzzle-stats {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Desktop styles (1025px to 1280px) */
    @media (min-width: 1025px) {
      .puzzle-layout {
        grid-template-columns: 1fr 350px;
        gap: var(--space-2xl);
        padding: var(--space-2xl);
      }

      .chessboard {
        width: min(65vw, 65vh);
        height: min(65vw, 65vh);
      }
    }

    /* Large desktop styles (1281px and up) */
    @media (min-width: 1281px) {
      .puzzle-layout {
        max-width: 1400px;
        margin: 0 auto;
        padding: var(--space-2xl);
      }

      .chessboard {
        width: min(60vw, 60vh);
        height: min(60vw, 60vh);
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .nav-links a {
        min-height: var(--touch-target-min);
        padding: var(--space-md);
      }

      .puzzle-controls button {
        min-height: var(--touch-target-min);
        padding: var(--space-lg);
      }

      .chessboard {
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      /* Enhanced visual feedback for touch */
      .puzzle-board {
        border: 2px solid transparent;
        transition: border-color 0.2s ease;
      }

      .puzzle-board:focus-within {
        border-color: var(--color-primary);
      }
    }

    /* Mobile navigation menu (if needed) */
    @media (max-width: 640px) {
      .nav-menu-toggle {
        display: block;
        background: none;
        border: none;
        color: var(--color-text-primary);
        font-size: var(--font-size-lg);
        padding: var(--space-sm);
        cursor: pointer;
        min-height: var(--touch-target-min);
        min-width: var(--touch-target-min);
      }

      .nav-links.mobile-menu {
        position: fixed;
        top: var(--header-height-mobile);
        left: 0;
        right: 0;
        background: var(--glass-bg);
        backdrop-filter: blur(16px);
        border-top: 1px solid var(--glass-border);
        padding: var(--space-md);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
      }

      .nav-links.mobile-menu a {
        padding: var(--space-md);
        border-radius: var(--radius-md);
        text-align: center;
        min-height: var(--touch-target-min);
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="app-header glass">
    <div class="logo">♟ Chess Platform</div>
    <nav class="nav-links">
      <a href="#" data-route="/lobby">Lobby</a>
      <a href="#" data-route="/game/new">Play</a>
      <a href="#" data-route="/puzzles" class="active">Puzzles</a>
      <a href="#" data-route="/profile">Profile</a>
    </nav>
  </header>

  <!-- Main Puzzle Layout -->
  <main class="puzzle-layout">
    <!-- Puzzle Board -->
    <section class="puzzle-board glass">
      <div id="chessboard" class="chessboard">
        <p>Board will be rendered here</p>
      </div>
      <div class="puzzle-status">
        <h2 id="puzzle-title">Loading Puzzle...</h2>
        <p id="puzzle-goal" class="goal-text">Goal will appear here</p>
      </div>
    </section>

    <!-- Puzzle Sidebar -->
    <aside class="puzzle-sidebar glass">
      <h2 class="sidebar-title">Puzzle Controls</h2>
      <div class="sidebar-actions">
        <button id="btn-next-puzzle" class="btn btn-primary">Next Puzzle</button>
        <button id="btn-restart-puzzle" class="btn btn-secondary">Restart</button>
        <button id="btn-show-solution" class="btn btn-danger">Show Solution</button>
      </div>
      <div class="puzzle-info">
        <h3>Details</h3>
        <p><strong>Rating:</strong> <span id="puzzle-rating">--</span></p>
        <p><strong>Category:</strong> <span id="puzzle-category">--</span></p>
        <p><strong>Progress:</strong> <span id="puzzle-progress">--</span></p>
      </div>
    </aside>
  </main>

  <!-- Footer -->
  <footer class="app-footer glass">
    <p>♟ Chess Platform — Train your tactics with puzzles</p>
  </footer>

  <!-- Script -->
  <script src="../../utils/api.js"></script>
  <script src="../../utils/router.js"></script>
  <script>
    // Set up router routes for puzzles page
    function setupRoutes() {
      console.log('Setting up routes for puzzles page...');
      
      // Add route for lobby
      router.addRoute('/lobby', {
        title: 'Lobby - Chess Platform',
        controller: () => {
          window.location.href = '/lobby/';
        },
        requiresAuth: true
      });
      
      // Add route for profile
      router.addRoute('/profile', {
        title: 'Profile - Chess Platform',
        controller: () => {
          window.location.href = '/profile/';
        },
        requiresAuth: true
      });
      
      // Add route for puzzles (current page)
      router.addRoute('/puzzles', {
        title: 'Puzzles - Chess Platform',
        controller: () => {
          window.location.reload();
        },
        requiresAuth: true
      });
      
      // Add route for new game
      router.addRoute('/game/new', {
        title: 'New Game - Chess Platform',
        controller: () => {
          window.location.href = '/play/';
        },
        requiresAuth: true
      });
      
      console.log('Routes configured for puzzles page');
    }
    
    // Set up navigation click handlers
    function setupNavigation() {
      console.log('Setting up navigation for puzzles page...');
      
      document.querySelectorAll('a[data-route]').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          console.log('Navigating to:', route);
          
          // Use direct navigation for reliability
          window.location.href = route + '/';
        });
      });
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      // Set up router routes
      setupRoutes();
      
      // Set up navigation click handlers
      setupNavigation();
      
      const titleEl = document.getElementById("puzzle-title");
      const goalEl = document.getElementById("puzzle-goal");
      const ratingEl = document.getElementById("puzzle-rating");
      const categoryEl = document.getElementById("puzzle-category");
      const progressEl = document.getElementById("puzzle-progress");
      const boardEl = document.getElementById("chessboard");

      let currentPuzzle = null;

      async function loadPuzzle() {
        try {
          titleEl.textContent = "Loading Puzzle...";
          goalEl.textContent = "Please wait...";

          // Example API call (replace with real endpoint)
          const puzzle = {
            id: 42,
            fen: "r1bqkbnr/pppppppp/n7/8/1P6/P7/2PPPPPP/RNBQKBNR b KQkq - 0 2",
            goal: "White to move and win material",
            rating: 1450,
            category: "Tactics",
            progress: "Not started"
          };

          currentPuzzle = puzzle;

          titleEl.textContent = `Puzzle #${puzzle.id}`;
          goalEl.textContent = puzzle.goal;
          ratingEl.textContent = puzzle.rating;
          categoryEl.textContent = puzzle.category;
          progressEl.textContent = puzzle.progress;

          renderBoard(puzzle.fen);
        } catch (err) {
          console.error(err);
          titleEl.textContent = "Failed to load puzzle";
          goalEl.textContent = "Try again later.";
        }
      }

      function renderBoard(fen) {
        // TODO: Replace with your actual chessboard renderer
        boardEl.innerHTML = `
          <p>FEN: ${fen}</p>
          <p>[Interactive board goes here]</p>
        `;
      }

      async function showSolution() {
        if (!currentPuzzle) return;
        alert("Solution: Example solution sequence (replace with API)");
      }

      document.getElementById("btn-next-puzzle").addEventListener("click", loadPuzzle);
      document.getElementById("btn-restart-puzzle").addEventListener("click", () => {
        if (currentPuzzle) renderBoard(currentPuzzle.fen);
      });
      document.getElementById("btn-show-solution").addEventListener("click", showSolution);

      loadPuzzle();
    });
  </script>
</body>
</html>

===== chess-platform/frontend/src/pages/puzzles/puzzles.js =====

===== chess-platform/frontend/src/styles/global.css =====
/* ================================
   Chess Platform - Global Design System
   Mobile-First Responsive Design
   ================================ */

/* CSS Custom Properties (Variables) */
:root {
  /* Colors - Dark Chess Theme */
  --color-bg-primary: #0a0a0a;
  --color-bg-secondary: #1a1a1a; 
  --color-bg-tertiary: #2a2a2a;
  --color-bg-card: #1e1e1e;
  --color-bg-hover: #2e2e2e;
  
  /* Chess Green Accents */
  --color-accent-primary: #769656;
  --color-accent-secondary: #5d7a42;
  --color-accent-dark: #4a5f35;
  --color-accent-light: #8fad6b;
  
  /* Chess Board Colors */
  --color-board-light: #f0d9b5;
  --color-board-dark: #b58863;
  
  /* Text Colors */
  --color-text-primary: #f0d9b5;
  --color-text-secondary: #d4c5a6;
  --color-text-muted: #9a8f7e;
  --color-text-inverse: #2a2a2a;
  
  /* Status Colors */
  --color-success: #22c55e;
  --color-error: #ef4444;
  --color-warning: #f59e0b;
  --color-info: #3b82f6;
  
  /* Borders & Shadows */
  --color-border: #3a3a3a;
  --color-border-light: rgba(240, 217, 181, 0.1);
  --color-border-focus: var(--color-accent-primary);
  
  /* Shadows */
  --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.4);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.5);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.6);
  --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.7);
  
  /* Responsive Spacing - Mobile First */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 0.75rem;
  --space-lg: 1rem;
  --space-xl: 1.25rem;
  --space-2xl: 1.5rem;
  --space-3xl: 2rem;
  
  /* Border Radius */
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
  --radius-full: 9999px;
  
  /* Typography - Mobile First */
  --font-family-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-family-mono: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
  
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 0.875rem;  /* Smaller base for mobile */
  --font-size-lg: 1rem;
  --font-size-xl: 1.125rem;
  --font-size-2xl: 1.25rem;
  --font-size-3xl: 1.5rem;
  --font-size-4xl: 2rem;
  
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  
  /* Responsive Layout - Mobile First */
  --container-max-width: 100%;
  --container-padding: var(--space-md);
  --sidebar-width: 100vw;  /* Full width on mobile */
  --header-height: 56px;   /* Smaller on mobile */
  --touch-target-min: 44px; /* Minimum touch target size */
  
  /* Responsive Breakpoints */
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
  
  /* Transitions */
  --transition-fast: 0.15s ease;
  --transition-normal: 0.2s ease;
  --transition-slow: 0.3s ease;
  
  /* Glass Effect */
  --glass-bg: rgba(30, 30, 30, 0.85);  /* Slightly more opaque for mobile */
  --glass-border: rgba(240, 217, 181, 0.1);
  --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

/* ================================
   Reset & Base Styles - Mobile First
   ================================ */

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: 14px; /* Smaller base for mobile */
  scroll-behavior: smooth;
  /* Prevent horizontal scroll on mobile */
  overflow-x: hidden;
}

body {
  font-family: var(--font-family-primary);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-normal);
  line-height: 1.5; /* Tighter line height for mobile */
  color: var(--color-text-primary);
  background: linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  /* Prevent horizontal scroll */
  overflow-x: hidden;
  /* Better text rendering on mobile */
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

/* Remove default button styles */
button {
  border: none;
  background: none;
  font-family: inherit;
  cursor: pointer;
}

/* Remove default input styles */
input, textarea, select {
  border: none;
  background: none;
  font-family: inherit;
  outline: none;
}

/* Remove default list styles */
ul, ol {
  list-style: none;
}

/* Remove default link styles */
a {
  text-decoration: none;
  color: inherit;
}

/* ================================
   Typography
   ================================ */

h1, h2, h3, h4, h5, h6 {
  font-weight: var(--font-weight-bold);
  line-height: 1.3;
  margin-bottom: var(--space-md);
  color: var(--color-text-primary);
}

h1 { font-size: var(--font-size-4xl); }
h2 { font-size: var(--font-size-3xl); }
h3 { font-size: var(--font-size-2xl); }
h4 { font-size: var(--font-size-xl); }
h5 { font-size: var(--font-size-lg); }
h6 { font-size: var(--font-size-base); }

p {
  margin-bottom: var(--space-md);
  color: var(--color-text-secondary);
}

.text-muted {
  color: var(--color-text-muted);
}

.text-small {
  font-size: var(--font-size-sm);
}

.text-center {
  text-align: center;
}

/* ================================
   Layout Components - Mobile First
   ================================ */

.container {
  width: 100%;
  max-width: var(--container-max-width);
  margin: 0 auto;
  padding: 0 var(--container-padding);
}

.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

.gap-sm {
  gap: var(--space-sm);
}

.gap-md {
  gap: var(--space-md);
}

.gap-lg {
  gap: var(--space-lg);
}

/* ================================
   Glass Morphism Components
   ================================ */

.glass-card {
  background: var(--glass-bg);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--glass-shadow);
}

/* ================================
   Form Elements
   ================================ */

.form-group {
  margin-bottom: var(--space-lg);
}

.form-label {
  display: block;
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  color: var(--color-text-secondary);
  margin-bottom: var(--space-sm);
}

.form-input {
  width: 100%;
  padding: var(--space-md);
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  color: var(--color-text-primary);
  font-size: var(--font-size-base);
  transition: all var(--transition-normal);
}

.form-input:focus {
  border-color: var(--color-accent-primary);
  box-shadow: 0 0 0 3px rgba(118, 150, 86, 0.1);
  background: rgba(255, 255, 255, 0.08);
}

.form-input::placeholder {
  color: var(--color-text-muted);
}

.form-error {
  color: var(--color-error);
  font-size: var(--font-size-sm);
  margin-top: var(--space-xs);
}

/* ================================
   Button Components - Mobile Optimized
   ================================ */

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-sm);
  padding: var(--space-lg) var(--space-xl);  /* Larger padding for mobile */
  border-radius: var(--radius-md);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  text-align: center;
  transition: all var(--transition-normal);
  cursor: pointer;
  min-height: var(--touch-target-min); /* Touch-friendly */
  border: none;
  outline: none;
  /* Better touch feedback */
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

.btn-primary {
  background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-secondary) 100%);
  color: var(--color-text-inverse);
  box-shadow: var(--shadow-sm);
}

/* Enhanced mobile interactions */
.btn-primary:hover,
.btn-primary:focus {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  background: linear-gradient(135deg, var(--color-accent-light) 0%, var(--color-accent-primary) 100%);
}

.btn-primary:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

.btn-primary:active {
  transform: translateY(0);
}

.btn-secondary {
  background: var(--color-bg-tertiary);
  color: var(--color-text-primary);
  border: 1px solid var(--color-border);
}

.btn-secondary:hover {
  background: var(--color-bg-hover);
  border-color: var(--color-accent-primary);
}

.btn-ghost {
  background: transparent;
  color: var(--color-text-secondary);
  border: 1px solid transparent;
}

.btn-ghost:hover {
  color: var(--color-accent-primary);
  background: rgba(118, 150, 86, 0.1);
}

.btn-full {
  width: 100%;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

/* ================================
   Loading States
   ================================ */

.loading {
  position: relative;
  overflow: hidden;
}

.loading::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(118, 150, 86, 0.2), transparent);
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% { left: -100%; }
  100% { left: 100%; }
}

/* ================================
   Utility Classes
   ================================ */

.hidden {
  display: none !important;
}

.visible {
  display: block !important;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* ================================
   Animations
   ================================ */

.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

.slide-up {
  animation: slideUp 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { 
    opacity: 0;
    transform: translateY(20px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

/* ================================
  Chess Board Components
  ================================ */

.chess-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  aspect-ratio: 1;
  border: 2px solid var(--color-border);
  border-radius: var(--radius-md);
  overflow: hidden;
  box-shadow: var(--shadow-lg);
}

.chess-square {
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.chess-square.light {
  background-color: var(--color-board-light);
}

.chess-square.dark {
  background-color: var(--color-board-dark);
}

.chess-square:hover {
  box-shadow: inset 0 0 0 3px var(--color-accent-primary);
}

.chess-square.selected {
  box-shadow: inset 0 0 0 3px var(--color-accent-primary);
  background-color: var(--color-accent-light);
}

.chess-piece {
  font-size: 2rem;
  user-select: none;
  pointer-events: none;
}

/* Mobile responsive chess board */
@media (max-width: 767px) {
  .chess-piece {
   font-size: 1.5rem;
  }
}

/* ================================
   Responsive Design - Mobile First Approach
   ================================ */

/* Small devices (landscape phones, 640px and up) */
@media (min-width: 640px) {
  :root {
    --container-padding: var(--space-lg);
    --font-size-base: 1rem;
  }
  
  html {
    font-size: 15px;
  }
}

/* Medium devices (tablets, 768px and up) */
@media (min-width: 768px) {
  :root {
    --container-max-width: 1200px;
    --container-padding: var(--space-xl);
    --sidebar-width: 260px;
    --header-height: 64px;
    --space-md: 1rem;
    --space-lg: 1.5rem;
    --space-xl: 2rem;
    --space-2xl: 3rem;
    --space-3xl: 4rem;
  }
  
  html {
    font-size: 16px;
  }
  
  .container {
    padding: 0 var(--container-padding);
  }
  
  h1 { font-size: var(--font-size-3xl); }
  h2 { font-size: var(--font-size-2xl); }
}

/* Large devices (desktops, 1024px and up) */
@media (min-width: 1024px) {
  :root {
    --sidebar-width: 280px;
    --container-padding: var(--space-2xl);
  }
}

/* Extra large devices (large desktops, 1280px and up) */
@media (min-width: 1280px) {
  :root {
    --container-padding: var(--space-3xl);
  }
}

/* Mobile-specific optimizations */
@media (max-width: 767px) {
  .btn {
    width: 100%;
    margin-bottom: var(--space-sm);
  }
  
  .form-input {
    font-size: 16px; /* Prevent zoom on iOS */
  }
  
  /* Hide scrollbars on mobile for cleaner look */
  ::-webkit-scrollbar {
    width: 0px;
    background: transparent;
  }
}

/* Touch device optimizations */
@media (pointer: coarse) {
  .btn {
    min-height: 48px; /* Larger touch targets */
  }
  
  .form-input {
    min-height: 48px;
  }
}
===== chess-platform/frontend/src/utils/api.js =====
/**
 * Chess Platform - Enhanced API Communication
 * Handles all backend communication with proper error handling and token management
 */

class ChessAPI {
  constructor() {
    this.baseURL = 'http://localhost:8000/api';
    this.accessToken = localStorage.getItem('access');
    this.refreshToken = localStorage.getItem('refresh');
    this.isRefreshing = false;
    this.failedQueue = [];
  }

  /**
   * Set authentication tokens
   * @param {string} access - Access token
   * @param {string} refresh - Refresh token
   */
  setTokens(access, refresh) {
    this.accessToken = access;
    this.refreshToken = refresh;
    localStorage.setItem('access', access);
    localStorage.setItem('refresh', refresh);
    
    // Update router auth status
    if (window.router) {
      window.router.setAuth(true);
    }
  }

  /**
   * Clear authentication tokens
   */
  clearTokens() {
    this.accessToken = null;
    this.refreshToken = null;
    localStorage.removeItem('access');
    localStorage.removeItem('refresh');
    
    // Update router auth status
    if (window.router) {
      window.router.setAuth(false);
    }
  }

  /**
   * Check if user is authenticated
   */
  isAuthenticated() {
    return !!this.accessToken;
  }

  /**
   * Make API request with automatic token refresh
   * @param {string} endpoint - API endpoint
   * @param {Object} options - Fetch options
   */
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    // Prepare headers
    const headers = {
      'Content-Type': 'application/json',
      ...options.headers
    };

    // Add authentication header
    if (this.accessToken) {
      headers['Authorization'] = `Bearer ${this.accessToken}`;
    }

    // Prepare request options
    const requestOptions = {
      ...options,
      headers
    };

    try {
      let response = await fetch(url, requestOptions);

      // Handle 401 - Unauthorized (token expired)
      if (response.status === 401 && this.refreshToken && !this.isRefreshing) {
        const refreshed = await this.refreshAccessToken();
        
        if (refreshed) {
          // Retry original request with new token
          headers['Authorization'] = `Bearer ${this.accessToken}`;
          response = await fetch(url, { ...requestOptions, headers });
        } else {
          // Refresh failed, redirect to login
          this.clearTokens();
          if (window.router) {
            window.router.navigate('/login');
          }
          throw new Error('Authentication expired');
        }
      }

      return this.handleResponse(response);
      
    } catch (error) {
      console.error('API Request failed:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Handle API response
   * @param {Response} response - Fetch response
   */
  async handleResponse(response) {
    const contentType = response.headers.get('content-type');
    let data;

    if (contentType && contentType.includes('application/json')) {
      data = await response.json();
    } else {
      data = await response.text();
    }

    if (!response.ok) {
      throw {
        status: response.status,
        statusText: response.statusText,
        data: data
      };
    }

    return {
      ok: true,
      status: response.status,
      data: data
    };
  }

  /**
   * Handle API errors
   * @param {Error|Object} error - Error object
   */
  handleError(error) {
    if (error.status) {
      // HTTP error
      return {
        ok: false,
        status: error.status,
        message: this.getErrorMessage(error),
        data: error.data
      };
    } else {
      // Network or other error
      return {
        ok: false,
        status: 0,
        message: error.message || 'Network error occurred',
        data: null
      };
    }
  }

  /**
   * Get user-friendly error message
   * @param {Object} error - Error object
   */
  getErrorMessage(error) {
    const statusMessages = {
      400: 'Invalid request data',
      401: 'Authentication required',
      403: 'Access denied',
      404: 'Resource not found',
      409: 'Resource conflict',
      422: 'Validation error',
      429: 'Too many requests',
      500: 'Server error occurred',
      502: 'Server temporarily unavailable',
      503: 'Service temporarily unavailable'
    };

    if (error.data && typeof error.data === 'object') {
      // Try to extract specific error message
      if (error.data.detail) return error.data.detail;
      if (error.data.message) return error.data.message;
      if (error.data.error) return error.data.error;
      
      // Handle field validation errors
      const fields = Object.keys(error.data);
      if (fields.length > 0) {
        const field = fields[0];
        const messages = error.data[field];
        if (Array.isArray(messages)) {
          return `${field}: ${messages[0]}`;
        }
        return `${field}: ${messages}`;
      }
    }

    return statusMessages[error.status] || 'An error occurred';
  }

  /**
   * Refresh access token
   */
  async refreshAccessToken() {
    if (!this.refreshToken || this.isRefreshing) {
      return false;
    }

    this.isRefreshing = true;

    try {
      const response = await fetch(`${this.baseURL}/auth/refresh/`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          refresh: this.refreshToken
        })
      });

      if (response.ok) {
        const data = await response.json();
        this.setTokens(data.access, this.refreshToken);
        this.processQueue(null, data.access);
        return true;
      } else {
        this.processQueue(new Error('Token refresh failed'), null);
        this.clearTokens();
        return false;
      }
    } catch (error) {
      this.processQueue(error, null);
      this.clearTokens();
      return false;
    } finally {
      this.isRefreshing = false;
    }
  }

  /**
   * Process queued requests after token refresh
   */
  processQueue(error, token) {
    this.failedQueue.forEach(({ resolve, reject }) => {
      if (error) {
        reject(error);
      } else {
        resolve(token);
      }
    });
    
    this.failedQueue = [];
  }

  // =================================
  // Authentication API Methods
  // =================================

  /**
   * Register new user
   * @param {Object} userData - User registration data
   */
  async register(userData) {
    return this.request('/auth/register/', {
      method: 'POST',
      body: JSON.stringify(userData)
    });
  }

  /**
   * Login user
   * @param {string} username - Username
   * @param {string} password - Password
   */
  async login(username, password) {
    const response = await this.request('/auth/login/', {
      method: 'POST',
      body: JSON.stringify({ username, password })
    });

    if (response.ok && response.data.access) {
      this.setTokens(response.data.access, response.data.refresh);
    }

    return response;
  }

  /**
   * Logout user
   */
  async logout() {
    try {
      if (this.refreshToken) {
        await this.request('/auth/logout/', {
          method: 'POST',
          body: JSON.stringify({ refresh: this.refreshToken })
        });
      }
    } catch (error) {
      console.warn('Logout request failed:', error);
    } finally {
      this.clearTokens();
      if (window.router) {
        window.router.navigate('/login');
      }
    }
  }

  /**
   * Get current user profile
   */
  async getUserProfile() {
    return this.request('/auth/profile/');
  }

  // =================================
  // Game API Methods
  // =================================

  /**
   * Get game timer status
   */
  async getGameTimer(gameId) {
    return this.request(`/games/${gameId}/timer/`);
  }

  /**
   * Get all games
   */
  async getGames() {
    return this.request('/games/');
  }

  /**
   * Create new game
   */
  async createGame() {
    return this.request('/games/create/', {
      method: 'POST'
    });
  }

  /**
   * Join game
   * @param {number} gameId - Game ID
   */
  async joinGame(gameId) {
    return this.request(`/games/${gameId}/join/`, {
      method: 'POST'
    });
  }

  /**
   * Get game details
   * @param {number} gameId - Game ID
   */
  async getGameDetail(gameId) {
    return this.request(`/games/${gameId}/`);
  }

  /**
   * Make a move
   * @param {number} gameId - Game ID
   * @param {string} from - From square (e.g., 'e2')
   * @param {string} to - To square (e.g., 'e4')
   * @param {string} promotion - Promotion piece (optional)
   */
  async makeMove(gameId, from, to, promotion = null) {
    const payload = {
      from_square: from,
      to_square: to
    };

    if (promotion) {
      payload.promotion = promotion;
    }

    return this.request(`/games/${gameId}/move/`, {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  /**
   * Make a computer move
   * @param {number} gameId - Game ID
   * @param {string} difficulty - AI difficulty ('easy', 'medium', 'hard', 'expert')
   */
  async makeComputerMove(gameId, difficulty = 'medium') {
    const payload = {
      difficulty: difficulty
    };

    return this.request(`/games/${gameId}/computer-move/`, {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  /**
   * Create a game against the computer
   * @param {string} playerColor - Player's color ('white' or 'black')
   * @param {string} difficulty - AI difficulty ('easy', 'medium', 'hard', 'expert')
   */
  async createComputerGame(playerColor = 'white', difficulty = 'medium') {
    const payload = {
      player_color: playerColor,
      difficulty: difficulty
    };

    return this.request('/games/create-computer/', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  /**
   * Get legal moves for a piece at a specific square
   * @param {number} gameId - Game ID  
   * @param {string} fromSquare - Square to get legal moves from (e.g., 'e2')
   */
  async getLegalMoves(gameId, fromSquare) {
    return this.request(`/games/${gameId}/legal-moves/?from_square=${fromSquare}`, {
      method: 'GET'
    });
  }

  /**
   * Get game timer data
   * @param {number} gameId - Game ID
   */
  async getGameTimer(gameId) {
    return this.request(`/games/${gameId}/timer/`, {
      method: 'GET'
    });
  }

  // =================================
  // Profile API Methods
  // =================================

  /**
   * Update user profile
   * @param {Object} profileData - Profile data
   */
  async updateProfile(profileData) {
    return this.request('/profiles/update/', {
      method: 'PATCH',
      body: JSON.stringify(profileData)
    });
  }

  /**
   * Upload user avatar
   * @param {File} file - Avatar image file
   */
  async uploadAvatar(file) {
    const formData = new FormData();
    formData.append('avatar', file);

    // Don't set Content-Type header - let browser handle it for FormData
    const headers = {};
    if (this.accessToken) {
      headers['Authorization'] = `Bearer ${this.accessToken}`;
    }

    const url = `${this.baseURL}/auth/avatar/upload/`;
    console.log('Uploading avatar to:', url);
    console.log('File details:', { name: file.name, type: file.type, size: file.size });

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: formData
      });

      console.log('Upload response status:', response.status);
      console.log('Upload response headers:', response.headers);

      return this.handleResponse(response);
    } catch (error) {
      console.error('Upload fetch error:', error);
      throw error;
    }
  }

  /**
   * Delete user avatar
   */
  async deleteAvatar() {
    return this.request('/auth/avatar/delete/', {
      method: 'DELETE'
    });
  }

  /**
   * Get user statistics
   */
  async getUserStats() {
    return this.request('/profiles/stats/');
  }

  // =================================
  // Utility Methods
  // =================================

  /**
   * Show API error to user
   * @param {Object} error - Error object from API response
   */
  showError(error) {
    const message = error.message || 'An error occurred';
    
    // Create or update error toast
    this.showToast(message, 'error');
  }

  /**
   * Show success message to user
   * @param {string} message - Success message
   */
  showSuccess(message) {
    this.showToast(message, 'success');
  }

  /**
   * Show toast notification
   * @param {string} message - Message text
   * @param {string} type - Toast type ('success', 'error', 'info')
   */
  showToast(message, type = 'info') {
    // Remove existing toast
    const existingToast = document.querySelector('.toast-notification');
    if (existingToast) {
      existingToast.remove();
    }

    // Create new toast
    const toast = document.createElement('div');
    toast.className = `toast-notification toast-${type} slide-up`;
    toast.innerHTML = `
      <div class="toast-content">
        <span class="toast-message">${message}</span>
        <button class="toast-close" onclick="this.parentElement.parentElement.remove()">×</button>
      </div>
    `;

    // Add styles if not already present
    if (!document.querySelector('#toast-styles')) {
      const style = document.createElement('style');
      style.id = 'toast-styles';
      style.textContent = `
        .toast-notification {
          position: fixed;
          top: var(--space-lg);
          right: var(--space-lg);
          min-width: 300px;
          max-width: 500px;
          padding: var(--space-md);
          border-radius: var(--radius-md);
          box-shadow: var(--shadow-lg);
          z-index: 1000;
          backdrop-filter: blur(16px);
        }
        
        .toast-success {
          background: rgba(34, 197, 94, 0.9);
          border: 1px solid var(--color-success);
          color: white;
        }
        
        .toast-error {
          background: rgba(239, 68, 68, 0.9);
          border: 1px solid var(--color-error);
          color: white;
        }
        
        .toast-info {
          background: var(--glass-bg);
          border: 1px solid var(--glass-border);
          color: var(--color-text-primary);
        }
        
        .toast-content {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: var(--space-md);
        }
        
        .toast-message {
          flex: 1;
          font-size: var(--font-size-sm);
        }
        
        .toast-close {
          background: none;
          border: none;
          color: inherit;
          font-size: var(--font-size-lg);
          cursor: pointer;
          padding: 0;
          width: 24px;
          height: 24px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: var(--radius-sm);
          transition: background var(--transition-fast);
        }
        
        .toast-close:hover {
          background: rgba(255, 255, 255, 0.1);
        }
        
        @media (max-width: 480px) {
          .toast-notification {
            left: var(--space-md);
            right: var(--space-md);
            min-width: auto;
          }
        }
      `;
      document.head.appendChild(style);
    }

    // Add to DOM
    document.body.appendChild(toast);

    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (toast.parentElement) {
        toast.remove();
      }
    }, 5000);
  }

  /**
   * Format API error for display
   * @param {Object} error - Error object
   */
  formatError(error) {
    if (!error) return 'Unknown error occurred';
    
    if (typeof error === 'string') return error;
    
    if (error.message) return error.message;
    
    if (error.data && typeof error.data === 'object') {
      // Handle validation errors
      const fields = Object.keys(error.data);
      if (fields.length > 0) {
        const errors = [];
        fields.forEach(field => {
          const messages = error.data[field];
          if (Array.isArray(messages)) {
            errors.push(`${field}: ${messages.join(', ')}`);
          } else {
            errors.push(`${field}: ${messages}`);
          }
        });
        return errors.join('; ');
      }
    }
    
    return 'An error occurred';
  }
}

// Create global API instance
const api = new ChessAPI();

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ChessAPI;
}

// Make available globally
window.api = api;
===== chess-platform/frontend/src/utils/rating_utils.js =====
/**
 * Chess Platform - Frontend Rating Utilities
 * JavaScript utilities for rating display and calculations
 */

class RatingUtils {
  /**
   * Get rating class/title based on rating
   */
  static getRatingClass(rating) {
    if (rating < 800) return 'Beginner';
    if (rating < 1000) return 'Novice';
    if (rating < 1200) return 'Amateur';
    if (rating < 1400) return 'Intermediate';
    if (rating < 1600) return 'Advanced';
    if (rating < 1800) return 'Expert';
    if (rating < 2000) return 'Master';
    if (rating < 2200) return 'International Master';
    if (rating < 2400) return 'Grandmaster';
    return 'Super Grandmaster';
  }

  /**
   * Get rating class color
   */
  static getRatingColor(rating) {
    if (rating < 1000) return '#8b5cf6'; // Purple
    if (rating < 1200) return '#06b6d4'; // Cyan
    if (rating < 1400) return '#10b981'; // Green
    if (rating < 1600) return '#f59e0b'; // Amber
    if (rating < 1800) return '#ef4444'; // Red
    if (rating < 2000) return '#ec4899'; // Pink
    if (rating < 2200) return '#8b5cf6'; // Purple
    if (rating < 2400) return '#f59e0b'; // Gold
    return '#dc2626'; // Dark Red
  }

  /**
   * Format rating change with proper sign and color
   */
  static formatRatingChange(change) {
    if (change > 0) {
      return {
        text: `+${change}`,
        color: 'var(--color-success)',
        class: 'rating-increase'
      };
    } else if (change < 0) {
      return {
        text: `${change}`,
        color: 'var(--color-error)',
        class: 'rating-decrease'
      };
    } else {
      return {
        text: '0',
        color: 'var(--color-text-muted)',
        class: 'rating-unchanged'
      };
    }
  }

  /**
   * Calculate expected score for rating display
   * This is for frontend display only - actual calculations are done on backend
   */
  static calculateExpectedScore(playerRating, opponentRating) {
    const ratingDifference = opponentRating - playerRating;
    return 1 / (1 + Math.pow(10, ratingDifference / 400));
  }

  /**
   * Get confidence level based on games played
   */
  static getConfidenceLevel(gamesCount) {
    if (gamesCount < 10) return { level: 'Very Low', color: '#ef4444' };
    if (gamesCount < 30) return { level: 'Low', color: '#f59e0b' };
    if (gamesCount < 100) return { level: 'Medium', color: '#10b981' };
    if (gamesCount < 500) return { level: 'High', color: '#06b6d4' };
    return { level: 'Very High', color: '#8b5cf6' };
  }

  /**
   * Format rating with appropriate styling
   */
  static formatRating(rating, options = {}) {
    const {
      showClass = true,
      showColor = true,
      abbreviated = false
    } = options;

    const ratingClass = this.getRatingClass(rating);
    const color = this.getRatingColor(rating);

    const result = {
      rating: rating,
      class: ratingClass,
      color: color,
      display: rating.toString()
    };

    if (abbreviated) {
      result.classAbbr = this.getAbbreviatedClass(ratingClass);
    }

    return result;
  }

  /**
   * Get abbreviated rating class
   */
  static getAbbreviatedClass(ratingClass) {
    const abbreviations = {
      'Beginner': 'BEG',
      'Novice': 'NOV',
      'Amateur': 'AM',
      'Intermediate': 'INT',
      'Advanced': 'ADV',
      'Expert': 'EXP',
      'Master': 'M',
      'International Master': 'IM',
      'Grandmaster': 'GM',
      'Super Grandmaster': 'SGM'
    };
    return abbreviations[ratingClass] || 'UNK';
  }

  /**
   * Create rating badge HTML
   */
  static createRatingBadge(rating, options = {}) {
    const {
      size = 'medium',
      showClass = false,
      className = ''
    } = options;

    const ratingInfo = this.formatRating(rating, options);
    const sizeClass = `rating-badge--${size}`;
    
    return `
      <span class="rating-badge ${sizeClass} ${className}" 
            style="background: linear-gradient(135deg, ${ratingInfo.color}20, ${ratingInfo.color}10); 
                   border: 1px solid ${ratingInfo.color}40; 
                   color: ${ratingInfo.color};">
        ${ratingInfo.display}
        ${showClass ? `<small class="rating-class">${ratingInfo.classAbbr || ratingInfo.class}</small>` : ''}
      </span>
    `;
  }

  /**
   * Calculate win rate percentage
   */
  static calculateWinRate(wins, total) {
    if (total === 0) return 0;
    return Math.round((wins / total) * 100 * 10) / 10; // Round to 1 decimal
  }

  /**
   * Format win rate with styling
   */
  static formatWinRate(winRate) {
    let color = 'var(--color-text-muted)';
    
    if (winRate >= 70) color = 'var(--color-success)';
    else if (winRate >= 55) color = 'var(--color-accent-primary)';
    else if (winRate >= 45) color = 'var(--color-warning)';
    else if (winRate < 35) color = 'var(--color-error)';

    return {
      percentage: winRate,
      display: `${winRate}%`,
      color: color
    };
  }

  /**
   * Simulate rating change for preview (frontend only)
   * Note: Actual rating calculations happen on the backend
   */
  static simulateRatingChange(playerRating, opponentRating, gameResult, timeControl = 'rapid') {
    // This is a simplified simulation for UI preview only
    const expectedScore = this.calculateExpectedScore(playerRating, opponentRating);
    
    // Simplified K-factor
    let kFactor = 20;
    if (timeControl === 'blitz') kFactor = 32;
    else if (timeControl === 'classical') kFactor = 16;
    
    const rawChange = kFactor * (gameResult - expectedScore);
    const change = Math.round(Math.max(-50, Math.min(50, rawChange)));
    
    return {
      change: change,
      newRating: playerRating + change,
      expectedScore: Math.round(expectedScore * 1000) / 1000
    };
  }

  /**
   * Get time control display name
   */
  static getTimeControlDisplay(timeControl) {
    const displays = {
      'bullet': { name: 'Bullet', icon: '⚡', color: '#ef4444' },
      'blitz': { name: 'Blitz', icon: '🔥', color: '#f59e0b' },
      'rapid': { name: 'Rapid', icon: '🏃', color: '#10b981' },
      'classical': { name: 'Classical', icon: '🏛️', color: '#06b6d4' }
    };
    return displays[timeControl] || { name: timeControl, icon: '♟️', color: 'var(--color-accent-primary)' };
  }

  /**
   * Format game result for display
   */
  static formatGameResult(result, userColor) {
    const resultMap = {
      '1-0': { white: 'Win', black: 'Loss', color: { white: 'success', black: 'error' } },
      '0-1': { white: 'Loss', black: 'Win', color: { white: 'error', black: 'success' } },
      '1/2-1/2': { white: 'Draw', black: 'Draw', color: { white: 'warning', black: 'warning' } }
    };

    const resultInfo = resultMap[result];
    if (!resultInfo) return { text: 'Unknown', color: 'muted' };

    return {
      text: resultInfo[userColor],
      color: `var(--color-${resultInfo.color[userColor]})`
    };
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = RatingUtils;
}

// Make available globally
window.RatingUtils = RatingUtils;

===== chess-platform/frontend/src/utils/router.js =====
// Advanced Router for Chess Platform
class ChessRouter {
  constructor() {
    this.routes = {};
    this.currentRoute = null;
    this.initialized = false;
    
    // Listen to popstate events for browser back/forward
    window.addEventListener('popstate', (event) => {
      this.handleRoute(window.location.pathname, false);
    });
  }

  // Add a route with configuration
  addRoute(path, config) {
    this.routes[path] = {
      path: path,
      title: config.title || 'Chess Platform',
      template: config.template,
      controller: config.controller,
      public: config.public || false,
      requiresAuth: config.requiresAuth || false,
      ...config
    };
  }

  // Register a route with a callback (backward compatibility)
  register(path, callback) {
    this.routes[path] = { callback };
  }

  // Navigate to a route
  navigate(path, pushState = true) {
    if (pushState) {
      window.history.pushState(null, '', path);
    }
    this.handleRoute(path, pushState);
  }

  // Handle route changes
  async handleRoute(path, pushState = true) {
    this.currentRoute = path;
    
    // Find matching route (exact match first, then pattern matching)
    let route = this.routes[path];
    
    if (!route) {
      // Try pattern matching for routes like /game/:id
      for (const routePath in this.routes) {
        if (this.matchRoute(routePath, path)) {
          route = this.routes[routePath];
          break;
        }
      }
    }
    
    if (route) {
      // Set page title
      if (route.title) {
        document.title = route.title;
      }
      
      // Handle authentication requirements
      if (route.requiresAuth && !this.checkAuth()) {
        this.navigate('/login');
        return;
      }
      
      // Load template if specified
      if (route.template) {
        await this.loadTemplate(route.template);
      }
      
      // Execute controller
      if (route.controller) {
        route.controller(this.extractParams(route.path, path));
      } else if (route.callback) {
        route.callback();
      }
    } else {
      console.warn(`No route handler found for: ${path}`);
      // Default fallback - redirect to login or home
      this.navigate('/login');
    }
  }

  // Match route patterns like /game/:id
  matchRoute(pattern, path) {
    const patternParts = pattern.split('/');
    const pathParts = path.split('/');
    
    if (patternParts.length !== pathParts.length) {
      return false;
    }
    
    return patternParts.every((part, i) => {
      return part.startsWith(':') || part === pathParts[i];
    });
  }

  // Extract parameters from route like /game/:id
  extractParams(pattern, path) {
    const patternParts = pattern.split('/');
    const pathParts = path.split('/');
    const params = {};
    
    patternParts.forEach((part, i) => {
      if (part.startsWith(':')) {
        params[part.substring(1)] = pathParts[i];
      }
    });
    
    return params;
  }

  // Load template content
  async loadTemplate(templatePath) {
    try {
      const response = await fetch(templatePath);
      if (response.ok) {
        const html = await response.text();
        const app = document.getElementById('app');
        if (app) {
          app.innerHTML = html;
        }
      } else {
        console.error(`Failed to load template: ${templatePath}`);
        this.showError('Page not found');
      }
    } catch (error) {
      console.error(`Error loading template: ${templatePath}`, error);
      this.showError('Failed to load page');
    }
  }

  // Check if user is authenticated
  checkAuth() {
    const token = localStorage.getItem('access');
    if (!token) return false;
    
    try {
      // Basic token expiration check (decode JWT payload)
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp > currentTime;
    } catch (error) {
      console.warn('Invalid token format:', error);
      localStorage.removeItem('access');
      localStorage.removeItem('refresh');
      return false;
    }
  }

  // Set authentication state
  setAuth(isAuthenticated) {
    // This can be called by the API when auth state changes
    if (!isAuthenticated) {
      localStorage.removeItem('access');
      localStorage.removeItem('refresh');
    }
  }

  // Show error page
  showError(message) {
    const app = document.getElementById('app');
    if (app) {
      app.innerHTML = `
        <div class="error-page" style="text-align: center; padding: 50px;">
          <div class="error-icon" style="font-size: 48px;">⚠️</div>
          <h1 class="error-title">Oops! Something went wrong</h1>
          <p class="error-message">${message}</p>
          <button onclick="location.reload()" style="padding: 10px 20px; margin-top: 20px; background: #60a5fa; color: white; border: none; border-radius: 5px; cursor: pointer;">
            Refresh Page
          </button>
        </div>
      `;
    }
  }

  // Initialize router
  async init() {
    this.initialized = true;
    
    // Start with current path or default to login
    const currentPath = window.location.pathname;
    if (currentPath === '/') {
      this.navigate('/login');
    } else {
      await this.handleRoute(currentPath, false);
    }
  }

  // Get current route
  getCurrentRoute() {
    return this.currentRoute;
  }

  // Refresh current route
  refresh() {
    this.handleRoute(window.location.pathname, false);
  }
}

// Create global router instance
const router = new ChessRouter();

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ChessRouter;
}

// Make available globally
window.router = router;

===== chess-platform/frontend/src/utils/utils.js =====
/**
 * Chess Platform - Client-Side Router
 * Handles navigation between pages without full page reloads
 */

class ChessRouter {
  constructor() {
    this.routes = {};
    this.currentRoute = null;
    this.isAuthenticated = false;
    
    // Initialize router
    this.init();
  }

  /**
   * Initialize the router
   */
  init() {
    // Check authentication status
    this.checkAuth();
    
    // Handle browser back/forward buttons
    window.addEventListener('popstate', (e) => {
      this.handleRoute(window.location.pathname, false);
    });

    // Handle initial page load
    this.handleRoute(window.location.pathname);
    
    // Set up link click handlers
    document.addEventListener('click', (e) => {
      if (e.target.matches('[data-route]')) {
        e.preventDefault();
        const route = e.target.getAttribute('data-route');
        this.navigate(route);
      }
    });
  }

  /**
   * Register a route
   * @param {string} path - Route path
   * @param {Object} config - Route configuration
   */
  addRoute(path, config) {
    this.routes[path] = {
      title: config.title || 'Chess Platform',
      template: config.template,
      controller: config.controller,
      requiresAuth: config.requiresAuth || false,
      public: config.public || false
    };
  }

  /**
   * Navigate to a route
   * @param {string} path - Route path
   * @param {boolean} pushState - Whether to push to history
   */
  navigate(path, pushState = true) {
    if (pushState) {
      history.pushState(null, null, path);
    }
    this.handleRoute(path);
  }

  /**
   * Handle route navigation
   * @param {string} path - Route path  
   * @param {boolean} pushState - Whether to push to history
   */
  async handleRoute(path, pushState = true) {
    // Remove query params and hash for route matching
    const cleanPath = path.split('?')[0].split('#')[0];
    
    // Find matching route
    let route = this.routes[cleanPath];
    
    // Default routes
    if (!route) {
      if (cleanPath === '/' || cleanPath === '/index.html' || cleanPath === '') {
        if (this.isAuthenticated) {
          return this.navigate('/lobby', pushState);
        } else {
          return this.navigate('/login', pushState);
        }
      }
      
      // 404 - redirect to appropriate page
      if (this.isAuthenticated) {
        return this.navigate('/lobby', pushState);
      } else {
        return this.navigate('/login', pushState);
      }
    }

    // Check authentication requirements
    if (route.requiresAuth && !this.isAuthenticated) {
      return this.navigate('/login', pushState);
    }
    
    if (route.public && this.isAuthenticated && (cleanPath === '/login' || cleanPath === '/register')) {
      return this.navigate('/lobby', pushState);
    }

    // Update current route
    this.currentRoute = cleanPath;
    
    // Update page title
    document.title = route.title;
    
    try {
      // Load and display the page
      await this.loadPage(route);
    } catch (error) {
      console.error('Error loading page:', error);
      this.showError('Failed to load page');
    }
  }

  /**
   * Load page content
   * @param {Object} route - Route configuration
   */
  async loadPage(route) {
    try {
      // Show loading state
      this.showLoading();
      
      // Load template
      let html;
      if (typeof route.template === 'string') {
        // Load from URL
        const response = await fetch(route.template);
        if (!response.ok) throw new Error(`Failed to load template: ${response.status}`);
        html = await response.text();
      } else if (typeof route.template === 'function') {
        // Generate from function
        html = route.template();
      } else {
        throw new Error('Invalid template configuration');
      }
      
      // Update page content
      const appContainer = document.getElementById('app');
      if (!appContainer) {
        throw new Error('App container not found');
      }
      
      appContainer.innerHTML = html;
      
      // Run controller if provided
      if (route.controller && typeof route.controller === 'function') {
        await route.controller();
      }
      
      // Hide loading state
      this.hideLoading();
      
      // Add fade-in animation
      appContainer.classList.add('fade-in');
      
    } catch (error) {
      this.hideLoading();
      throw error;
    }
  }

  /**
   * Check authentication status
   */
  checkAuth() {
    const token = localStorage.getItem('access');
    this.isAuthenticated = !!token;
    return this.isAuthenticated;
  }

  /**
   * Update authentication status
   * @param {boolean} status - Authentication status
   */
  setAuth(status) {
    this.isAuthenticated = status;
  }

  /**
   * Show loading state
   */
  showLoading() {
    const loader = document.getElementById('page-loader');
    if (loader) {
      loader.classList.remove('hidden');
    }
  }

  /**
   * Hide loading state  
   */
  hideLoading() {
    const loader = document.getElementById('page-loader');
    if (loader) {
      loader.classList.add('hidden');
    }
  }

  /**
   * Show error message
   * @param {string} message - Error message
   */
  showError(message) {
    // Create or update error element
    let errorEl = document.getElementById('router-error');
    if (!errorEl) {
      errorEl = document.createElement('div');
      errorEl.id = 'router-error';
      errorEl.className = 'error-message';
      document.body.appendChild(errorEl);
    }
    
    errorEl.textContent = message;
    errorEl.classList.remove('hidden');
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      errorEl.classList.add('hidden');
    }, 5000);
  }

  /**
   * Get current route
   */
  getCurrentRoute() {
    return this.currentRoute;
  }

  /**
   * Get route parameters from URL
   * @param {string} pattern - Route pattern with parameters
   */
  getParams(pattern = null) {
    const url = new URL(window.location.href);
    const params = {};
    
    // Get query parameters
    url.searchParams.forEach((value, key) => {
      params[key] = value;
    });
    
    // If pattern provided, extract path parameters
    if (pattern) {
      const pathParts = window.location.pathname.split('/');
      const patternParts = pattern.split('/');
      
      patternParts.forEach((part, index) => {
        if (part.startsWith(':')) {
          const paramName = part.substring(1);
          params[paramName] = pathParts[index];
        }
      });
    }
    
    return params;
  }

  /**
   * Redirect to a route
   * @param {string} path - Route path
   */
  redirect(path) {
    this.navigate(path);
  }

  /**
   * Go back in history
   */
  back() {
    history.back();
  }

  /**
   * Refresh current route
   */
  refresh() {
    this.handleRoute(window.location.pathname, false);
  }
}

// Create global router instance
const router = new ChessRouter();

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ChessRouter;
}

// Make available globally
window.router = router;
===== chess-platform/games/admin.py =====
from django.contrib import admin
from .models import Game, Move


@admin.register(Game)
class GameAdmin(admin.ModelAdmin):
    list_display = ('id', 'white_player', 'black_player', 'status', 'created_at')
    list_filter = ('status', 'created_at')
    search_fields = ('white_player__username', 'black_player__username')


@admin.register(Move)
class MoveAdmin(admin.ModelAdmin):
    list_display = ('id', 'game', 'move_number', 'player', 'notation', 'created_at')
    list_filter = ('created_at',)
    search_fields = ('notation', 'player__username')

===== chess-platform/games/apps.py =====
from django.apps import AppConfig


class GamesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'games'

===== chess-platform/games/models.py =====
# games/models.py
from django.db import models
from django.conf import settings
from django.utils import timezone
from datetime import timedelta
import chess
import json


class ChessManager:
    """Manager class for chess platform data initialization and management"""
    
    @staticmethod
    def create_default_time_controls():
        """Create standard time controls used in professional chess"""
        defaults = [
            # Bullet (< 3 minutes)
            {'name': 'Bullet 1+0', 'category': 'bullet', 'initial_time': 60, 'increment': 0, 
             'description': 'Ultra-fast games for quick thinking'},
            {'name': 'Bullet 2+1', 'category': 'bullet', 'initial_time': 120, 'increment': 1,
             'description': 'Fast-paced games with small increment'},

            # Blitz (3-10 minutes)
            {'name': 'Blitz 3+0', 'category': 'blitz', 'initial_time': 180, 'increment': 0,
             'description': 'Classic blitz format'},
            {'name': 'Blitz 3+2', 'category': 'blitz', 'initial_time': 180, 'increment': 2,
             'description': 'Popular online blitz format'},
            {'name': 'Blitz 5+0', 'category': 'blitz', 'initial_time': 300, 'increment': 0,
             'description': 'Standard 5-minute blitz'},
            {'name': 'Blitz 5+3', 'category': 'blitz', 'initial_time': 300, 'increment': 3,
             'description': '5-minute blitz with increment'},

            # Rapid (10-60 minutes)
            {'name': 'Rapid 10+0', 'category': 'rapid', 'initial_time': 600, 'increment': 0,
             'description': 'Quick rapid games'},
            {'name': 'Rapid 10+5', 'category': 'rapid', 'initial_time': 600, 'increment': 5,
             'description': 'Popular rapid format with increment'},
            {'name': 'Rapid 15+10', 'category': 'rapid', 'initial_time': 900, 'increment': 10,
             'description': 'Tournament-style rapid'},

            # Classical (> 60 minutes)
            {'name': 'Classical 30+0', 'category': 'classical', 'initial_time': 1800, 'increment': 0,
             'description': 'Classical time control'},
            {'name': 'Classical 30+30', 'category': 'classical', 'initial_time': 1800, 'increment': 30,
             'description': 'FIDE-style classical with increment'},
            {'name': 'Classical 90+30', 'category': 'classical', 'initial_time': 5400, 'increment': 30,
             'description': 'Long classical games'},
        ]

        created_count = 0
        for tc_data in defaults:
            time_control, created = TimeControl.objects.get_or_create(
                name=tc_data['name'],
                defaults=tc_data
            )
            if created:
                created_count += 1
        
        return created_count
    
    @staticmethod
    def create_default_achievements():
        """Create standard chess achievements"""
        from accounts.models import Achievement
        
        defaults = [
            # Milestone Achievements
            {'name': 'First Victory', 'description': 'Win your first game', 
             'category': 'milestone', 'condition': 'games_won >= 1', 'points': 10, 'icon': '🎯'},
            {'name': 'Veteran Player', 'description': 'Play 100 games', 
             'category': 'milestone', 'condition': 'total_games >= 100', 'points': 50, 'icon': '🏆'},
            {'name': 'Chess Master', 'description': 'Play 1000 games', 
             'category': 'milestone', 'condition': 'total_games >= 1000', 'points': 200, 'icon': '👑'},
            
            # Rating Achievements
            {'name': 'Rising Star', 'description': 'Reach 1400 rating', 
             'category': 'rating', 'condition': 'rapid_rating >= 1400', 'points': 25, 'icon': '⭐'},
            {'name': 'Strong Player', 'description': 'Reach 1600 rating', 
             'category': 'rating', 'condition': 'rapid_rating >= 1600', 'points': 50, 'icon': '💪'},
            {'name': 'Expert Level', 'description': 'Reach 1800 rating', 
             'category': 'rating', 'condition': 'rapid_rating >= 1800', 'points': 100, 'icon': '🎓'},
            {'name': 'Master Level', 'description': 'Reach 2000 rating', 
             'category': 'rating', 'condition': 'rapid_rating >= 2000', 'points': 200, 'icon': '🥇'},
            
            # Streak Achievements
            {'name': 'Win Streak', 'description': 'Win 5 games in a row', 
             'category': 'streak', 'condition': 'current_win_streak >= 5', 'points': 30, 'icon': '🔥'},
            {'name': 'Unstoppable', 'description': 'Win 10 games in a row', 
             'category': 'streak', 'condition': 'current_win_streak >= 10', 'points': 75, 'icon': '⚡'},
            
            # Special Achievements
            {'name': 'Speed Demon', 'description': 'Win 50 blitz games', 
             'category': 'special', 'condition': 'blitz_games >= 50', 'points': 40, 'icon': '💨'},
            {'name': 'Puzzle Solver', 'description': 'Solve 100 puzzles', 
             'category': 'puzzle', 'condition': 'puzzles_solved >= 100', 'points': 35, 'icon': '🧩'},
        ]

        created_count = 0
        for ach_data in defaults:
            achievement, created = Achievement.objects.get_or_create(
                name=ach_data['name'],
                defaults=ach_data
            )
            if created:
                created_count += 1
        
        return created_count


class TimeControl(models.Model):
    """Define different time control formats"""

    name = models.CharField(max_length=50, unique=True)
    category = models.CharField(
        max_length=10,
        choices=[
            ('bullet', 'Bullet'),
            ('blitz', 'Blitz'),
            ('rapid', 'Rapid'),
            ('classical', 'Classical'),
            ('custom', 'Custom'),
        ]
    )
    initial_time = models.IntegerField(help_text="Initial time in seconds")
    increment = models.IntegerField(default=0, help_text="Increment per move in seconds")
    description = models.CharField(max_length=100, blank=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        db_table = 'time_controls'
        ordering = ['category', 'initial_time']

    def __str__(self):
        minutes = self.initial_time // 60
        if self.increment > 0:
            return f"{minutes}+{self.increment}"
        return f"{minutes} min"

    def get_display_name(self):
        """Get user-friendly display name"""
        minutes = self.initial_time // 60
        if self.increment > 0:
            return f"{self.name} ({minutes}+{self.increment})"
        return f"{self.name} ({minutes} min)"


class Game(models.Model):
    """Enhanced game model with timer support and detailed tracking"""

    STATUS_CHOICES = [
        ('waiting', 'Waiting for opponent'),
        ('active', 'In progress'),
        ('finished', 'Finished'),
        ('aborted', 'Aborted'),
    ]

    RESULT_CHOICES = [
        ('1-0', 'White wins'),
        ('0-1', 'Black wins'),
        ('1/2-1/2', 'Draw'),
        ('*', 'Game in progress'),
    ]

    TERMINATION_CHOICES = [
        ('checkmate', 'Checkmate'),
        ('resignation', 'Resignation'),
        ('timeout', 'Time out'),
        ('draw_agreement', 'Draw by agreement'),
        ('stalemate', 'Stalemate'),
        ('insufficient_material', 'Insufficient material'),
        ('threefold_repetition', 'Threefold repetition'),
        ('fifty_move_rule', 'Fifty-move rule'),
        ('abandoned', 'Game abandoned'),
    ]

    # Players
    white_player = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='games_as_white',
        null=True,
        blank=True
    )
    black_player = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='games_as_black',
        null=True,
        blank=True
    )

    # Game state
    fen = models.CharField(
        max_length=200,
        default=chess.STARTING_FEN,
        help_text="Current board position in FEN"
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='waiting')
    result = models.CharField(max_length=10, choices=RESULT_CHOICES, default='*')
    termination = models.CharField(max_length=30, choices=TERMINATION_CHOICES, blank=True, null=True)
    winner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='won_games'
    )

    # Timers
    time_control = models.CharField(max_length=20, default='rapid', help_text="Time control format")
    white_time_left = models.IntegerField(default=600, help_text="Remaining time in seconds for white")
    black_time_left = models.IntegerField(default=600, help_text="Remaining time in seconds for black")
    last_move_at = models.DateTimeField(null=True, blank=True)

    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'games_game'  # Use existing table name
        indexes = [
            models.Index(fields=['status']),
            models.Index(fields=['created_at']),
        ]
        ordering = ['-created_at']

    def __str__(self):
        return f"Game {self.id} ({self.white_player} vs {self.black_player})"

    def initialize_timers(self):
        """Set both players' clocks to the initial time"""
        if self.time_control:
            self.white_time_remaining = self.time_control.initial_time
            self.black_time_remaining = self.time_control.initial_time
        self.last_move_time = timezone.now()
        self.save()

    def update_clock(self, is_white_move=True):
        """
        Deduct time from the player who is currently moving.
        Should be called when a move is made.
        """
        if not self.last_move_time:
            self.last_move_time = timezone.now()
            self.save()
            return

        now = timezone.now()
        elapsed = int((now - self.last_move_time).total_seconds())

        if is_white_move:
            self.white_time_remaining = max(0, self.white_time_remaining - elapsed)
            if self.white_time_remaining > 0 and self.time_control:
                self.white_time_remaining += self.time_control.increment
        else:
            self.black_time_remaining = max(0, self.black_time_remaining - elapsed)
            if self.black_time_remaining > 0 and self.time_control:
                self.black_time_remaining += self.time_control.increment

        self.last_move_time = now
        self.save()

    def check_time_expired(self):
        """Return 'white' or 'black' if a player's time ran out"""
        if self.white_time_remaining <= 0:
            return 'white'
        if self.black_time_remaining <= 0:
            return 'black'
        return None


class Move(models.Model):
    """Store moves with notation and metadata"""

    game = models.ForeignKey(Game, on_delete=models.CASCADE, related_name='moves')
    player = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    move_number = models.IntegerField()
    from_square = models.CharField(max_length=5)
    to_square = models.CharField(max_length=5)
    notation = models.CharField(max_length=20)
    fen_after_move = models.CharField(max_length=200, help_text="FEN after move", default=chess.STARTING_FEN)
    created_at = models.DateTimeField(auto_now_add=True)
    time_taken = models.IntegerField(default=0, help_text="Seconds spent on this move")
    time_left = models.IntegerField(default=600, help_text="Time remaining after this move")
    captured_piece = models.CharField(max_length=2, blank=True, null=True)
    is_check = models.BooleanField(default=False)
    is_checkmate = models.BooleanField(default=False)
    is_castling = models.BooleanField(default=False)
    is_en_passant = models.BooleanField(default=False)
    promotion_piece = models.CharField(max_length=2, blank=True, null=True)

    class Meta:
        db_table = 'games_move'  # Use existing table name
        ordering = ['move_number']
        indexes = [
            models.Index(fields=['game', 'move_number']),
        ]

    def __str__(self):
        return f"Move {self.move_number}: {self.notation}"

    def to_dict(self):
        """Return JSON-serializable representation of move"""
        return {
            "move_number": self.move_number,
            "from": self.from_square,
            "to": self.to_square,
            "promotion": self.promotion_piece,
            "notation": self.notation,
            "fen_after": self.fen_after_move,
            "timestamp": self.created_at.isoformat(),
            "time_taken": self.time_taken,
        }


class GameInvitation(models.Model):
    """Handle game invitations between players"""
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('accepted', 'Accepted'),
        ('declined', 'Declined'),
        ('expired', 'Expired'),
        ('cancelled', 'Cancelled'),
    ]
    
    from_player = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='sent_invitations'
    )
    to_player = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='received_invitations'
    )
    time_control = models.ForeignKey(TimeControl, on_delete=models.CASCADE)
    message = models.TextField(max_length=200, blank=True, help_text="Optional invitation message")
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(help_text="When this invitation expires")
    responded_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'games_gameinvitation'  # Following your naming convention
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['from_player', 'status']),
            models.Index(fields=['to_player', 'status']),
            models.Index(fields=['created_at']),
            models.Index(fields=['expires_at']),
        ]
    
    def __str__(self):
        return f"{self.from_player.username} → {self.to_player.username} ({self.time_control})"
    
    def is_expired(self):
        """Check if invitation has expired"""
        return timezone.now() > self.expires_at
    
    def accept(self):
        """Accept the invitation and create game"""
        if self.status != 'pending' or self.is_expired():
            return None
            
        self.status = 'accepted'
        self.responded_at = timezone.now()
        self.save()
        
        # Create the game with proper time control format
        game = Game.objects.create(
            white_player=self.from_player,
            black_player=self.to_player,
            time_control=self.time_control.category,  # Use category string to match Game model
            white_time_left=self.time_control.initial_time,
            black_time_left=self.time_control.initial_time,
            status='waiting'
        )
        return game
    
    def decline(self):
        """Decline the invitation"""
        self.status = 'declined'
        self.responded_at = timezone.now()
        self.save()
    
    def cancel(self):
        """Cancel the invitation (only by sender)"""
        if self.status == 'pending':
            self.status = 'cancelled'
            self.responded_at = timezone.now()
            self.save()
    
    def get_display_name(self):
        """Get user-friendly display for the invitation"""
        return f"{self.time_control.get_display_name()} game"

===== chess-platform/games/serializers.py =====
from rest_framework import serializers
from .models import Game, Move


class MoveSerializer(serializers.ModelSerializer):
    player_username = serializers.CharField(source='player.username', read_only=True)

    class Meta:
        model = Move
        fields = [
            'id', 'game', 'move_number', 'player', 'player_username',
            'from_square', 'to_square', 'notation', 'fen_after_move', 'created_at'
        ]
        # Mark all auto-filled fields as read-only so they aren't required in input
        read_only_fields = [
            'id', 'created_at', 'player_username',
            'game', 'player', 'move_number', 'notation', 'fen_after_move'
        ]


class GameSerializer(serializers.ModelSerializer):
    white_player_username = serializers.CharField(source='white_player.username', read_only=True)
    black_player_username = serializers.CharField(source='black_player.username', read_only=True)
    moves = MoveSerializer(many=True, read_only=True)

    class Meta:
        model = Game
        fields = [
            'id', 'white_player', 'white_player_username',
            'black_player', 'black_player_username',
            'status', 'fen', 'winner',
            'created_at', 'updated_at', 'moves'
        ]
        read_only_fields = [
            'id', 'created_at', 'updated_at', 'moves',
            'white_player', 'black_player',
            'white_player_username', 'black_player_username'
        ]

===== chess-platform/games/tests.py =====
from django.test import TestCase

# Create your tests here.

===== chess-platform/games/urls.py =====
from django.urls import path
from . import views

urlpatterns = [
    path("", views.GameListView.as_view(), name="game-list"),                  # GET list
    path("create/", views.create_game, name="game-create"),                    # POST create
    path("create-computer/", views.create_computer_game, name="game-create-computer"), # POST create vs computer
    path("<int:pk>/", views.GameDetailView.as_view(), name="game-detail"),     # GET detail
    path("<int:pk>/join/", views.join_game, name="game-join"),                 # POST join
    path("<int:pk>/move/", views.make_move, name="game-move"),                 # POST make move
    path("<int:pk>/computer-move/", views.make_computer_move, name="game-computer-move"), # POST computer move
    path("<int:pk>/legal-moves/", views.get_legal_moves, name="game-legal-moves"),  # GET legal moves
    path("<int:pk>/timer/", views.get_game_timer, name="game-timer"),          # GET timer status
]

===== chess-platform/games/views.py =====
import chess
from django.db import transaction
from django.shortcuts import get_object_or_404
from rest_framework import status, generics
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
import json
import logging

from .models import Game, Move
from .serializers import GameSerializer, MoveSerializer

# Import chess engine
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'engine'))
from engine import get_computer_move

# Add logging
logger = logging.getLogger(__name__)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
@transaction.atomic
def make_move(request, pk):
    """Submit a move, validate with python-chess, and update game state."""
    logger.info(f"Move request received for game {pk} by user {request.user}")
    logger.info(f"Request data: {request.data}")
    
    game = get_object_or_404(Game, pk=pk)

    # Must be a participant
    if request.user not in [game.white_player, game.black_player]:
        logger.error(f"User {request.user} not a player in game {pk}")
        return Response({"detail": "You are not a player in this game."},
                        status=status.HTTP_403_FORBIDDEN)

    # Load board from FEN
    try:
        # Handle "startpos" FEN
        if game.fen == "startpos":
            game.fen = chess.STARTING_FEN
            game.save()
        
        board = chess.Board(game.fen)
        logger.info(f"Board loaded from FEN: {game.fen}")
    except Exception as e:
        logger.error(f"Invalid FEN in game {pk}: {game.fen}, error: {e}")
        return Response({"detail": "Corrupted game state (invalid FEN)."},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # Enforce turn
    expected_player = game.white_player if board.turn == chess.WHITE else game.black_player
    if expected_player != request.user:
        logger.error(f"Wrong turn: expected {expected_player}, got {request.user}")
        return Response({
            "detail": "It is not your turn.",
            "current_turn": "white" if board.turn == chess.WHITE else "black",
            "expected_player": expected_player.username,
            "actual_player": request.user.username
        }, status=status.HTTP_400_BAD_REQUEST)

    # Read request data
    from_sq = (request.data.get('from_square') or "").strip().lower()
    to_sq = (request.data.get('to_square') or "").strip().lower()
    promotion = request.data.get('promotion')
    
    logger.info(f"Move attempt: {from_sq} -> {to_sq}, promotion: {promotion}")

    if not (len(from_sq) == 2 and len(to_sq) == 2):
        return Response({"detail": "from_square/to_square must be like 'e2' and 'e4'."},
                        status=status.HTTP_400_BAD_REQUEST)

    # Build UCI string
    uci = f"{from_sq}{to_sq}"
    if promotion:
        promo = str(promotion).lower()
        if promo not in ['q', 'r', 'b', 'n']:
            return Response({"detail": "Invalid promotion piece (use q/r/b/n)."},
                            status=status.HTTP_400_BAD_REQUEST)
        uci += promo

    logger.info(f"UCI move: {uci}")

    try:
        move = chess.Move.from_uci(uci)
        logger.info(f"Parsed move: {move}")
    except Exception as e:
        logger.error(f"Invalid move format: {uci}, error: {e}")
        return Response({"detail": "Invalid move format."},
                        status=status.HTTP_400_BAD_REQUEST)

    if move not in board.legal_moves:
        legal_moves = [board.san(m) for m in board.legal_moves][:10]  # First 10 legal moves
        logger.error(f"Illegal move: {move}, legal moves: {legal_moves}")
        return Response({
            "detail": "Illegal move for current position.",
            "attempted_move": str(move),
            "legal_moves_sample": legal_moves,
            "board_fen": board.fen()
        }, status=status.HTTP_400_BAD_REQUEST)

    # Get SAN notation before pushing
    san = board.san(move)
    logger.info(f"Move SAN: {san}")

    # Apply move
    board.push(move)
    new_fen = board.fen()
    logger.info(f"New FEN after move: {new_fen}")

    # Save move record
    move_number = game.moves.count() + 1
    
    move_obj = Move.objects.create(
        game=game,
        player=request.user,
        move_number=move_number,
        from_square=from_sq,
        to_square=to_sq,
        notation=san,
        fen_after_move=new_fen
    )
    
    logger.info(f"Move saved: {move_obj}")

    # Update game state
    game.fen = new_fen
    if board.is_game_over():
        game.status = 'finished'
        result = board.result()
        if result == '1-0':
            game.winner = game.white_player
        elif result == '0-1':
            game.winner = game.black_player
        logger.info(f"Game finished with result: {result}")
    else:
        game.status = 'active'
    
    game.save()
    logger.info(f"Game updated: status={game.status}, fen={game.fen}")

    # Return updated game info
    game_serializer = GameSerializer(game)
    move_serializer = MoveSerializer(move_obj)
    
    response_data = {
        "move": move_serializer.data,
        "game": game_serializer.data
    }
    
    logger.info(f"Returning response: {response_data}")
    return Response(response_data, status=status.HTTP_201_CREATED)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_game(request):
    """Create a new chess game with the current user as white."""
    game = Game.objects.create(
        white_player=request.user,
        fen=chess.STARTING_FEN,  # Use actual FEN, not "startpos"
        status='waiting'
    )
    serializer = GameSerializer(game)
    logger.info(f"Game created: {game.id} by {request.user}")
    return Response(serializer.data, status=status.HTTP_201_CREATED)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def join_game(request, pk):
    """Join a game as black if it's waiting."""
    game = get_object_or_404(Game, pk=pk)

    if game.status != 'waiting':
        return Response({"detail": "Game is not available to join."},
                        status=status.HTTP_400_BAD_REQUEST)

    if game.white_player == request.user:
        return Response({"detail": "You cannot join your own game as black."},
                        status=status.HTTP_400_BAD_REQUEST)

    game.black_player = request.user
    game.status = 'active'
    game.save()

    serializer = GameSerializer(game)
    logger.info(f"User {request.user} joined game {game.id}")
    return Response(serializer.data)


class GameListView(generics.ListAPIView):
    """List recent games."""
    queryset = Game.objects.all().order_by('-created_at')
    serializer_class = GameSerializer


class GameDetailView(generics.RetrieveAPIView):
    """Get details of a single game."""
    queryset = Game.objects.all()
    serializer_class = GameSerializer


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_legal_moves(request, pk):
    """Get legal moves for a specific square in the game."""
    game = get_object_or_404(Game, pk=pk)
    
    # Must be a participant
    if request.user not in [game.white_player, game.black_player]:
        return Response({"detail": "You are not a player in this game."},
                        status=status.HTTP_403_FORBIDDEN)
    
    # Get the square parameter
    from_square = request.GET.get('from_square', '').strip().lower()
    
    if not from_square or len(from_square) != 2:
        return Response({"detail": "from_square parameter required (e.g., 'e2')"},
                        status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Handle "startpos" FEN
        if game.fen == "startpos":
            game.fen = chess.STARTING_FEN
            game.save()
        
        board = chess.Board(game.fen)
        
        # Convert square name to chess.Square
        try:
            square = chess.parse_square(from_square)
        except ValueError:
            return Response({"detail": "Invalid square name"},
                            status=status.HTTP_400_BAD_REQUEST)
        
        # Get piece at square
        piece = board.piece_at(square)
        if not piece:
            return Response({"moves": []})
        
        # Check if it's the player's piece
        is_white_piece = piece.color == chess.WHITE
        is_white_player = request.user == game.white_player
        
        if is_white_piece != is_white_player:
            return Response({"detail": "Not your piece"},
                            status=status.HTTP_400_BAD_REQUEST)
        
        # Get all legal moves from this square
        legal_moves = []
        for move in board.legal_moves:
            if move.from_square == square:
                to_square_name = chess.square_name(move.to_square)
                is_capture = board.is_capture(move)
                
                legal_moves.append({
                    "to": to_square_name,
                    "capture": is_capture,
                    "uci": move.uci()
                })
        
        return Response({
            "from_square": from_square,
            "moves": legal_moves,
            "count": len(legal_moves)
        })
        
    except Exception as e:
        logger.error(f"Error getting legal moves for game {pk}: {e}")
        return Response({"detail": "Error calculating legal moves"},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_game_timer(request, pk):
    """Get timer status for a game."""
    game = get_object_or_404(Game, pk=pk)
    
    # Must be a participant
    if request.user not in [game.white_player, game.black_player]:
        return Response({"detail": "You are not a player in this game."},
                        status=status.HTTP_403_FORBIDDEN)
    
    try:
        # Parse FEN to get current turn
        if game.fen == "startpos":
            game.fen = chess.STARTING_FEN
            game.save()
        
        board = chess.Board(game.fen)
        current_turn = "white" if board.turn == chess.WHITE else "black"
        
        return Response({
            "game_id": game.id,
            "white_time": game.white_time_left,
            "black_time": game.black_time_left,
            "current_turn": current_turn,
            "game_status": game.status,
            "last_move_at": game.last_move_at
        })
        
    except Exception as e:
        logger.error(f"Error getting timer for game {pk}: {e}")
        return Response({"detail": "Error getting timer data"},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
@transaction.atomic
def make_computer_move(request, pk):
    """Make a computer move for the game."""
    logger.info(f"Computer move request for game {pk} by user {request.user}")
    
    game = get_object_or_404(Game, pk=pk)
    
    # Must be a participant
    if request.user not in [game.white_player, game.black_player]:
        return Response({"detail": "You are not a player in this game."},
                        status=status.HTTP_403_FORBIDDEN)
    
    # Check if game allows computer moves (could add a field for this)
    # For now, allow if one player is None (indicating computer opponent)
    if game.white_player and game.black_player:
        return Response({"detail": "This is a human vs human game."},
                        status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Handle "startpos" FEN
        if game.fen == "startpos":
            game.fen = chess.STARTING_FEN
            game.save()
        
        board = chess.Board(game.fen)
        
        # Get difficulty from request or use default
        difficulty = request.data.get('difficulty', 'medium')
        if difficulty not in ['easy', 'medium', 'hard', 'expert']:
            difficulty = 'medium'
        
        logger.info(f"Making computer move with difficulty: {difficulty}")
        
        # Get computer move
        result = get_computer_move(game.fen, difficulty)
        
        if not result['success']:
            logger.error(f"Computer move failed: {result['error']}")
            return Response({"detail": f"Computer move failed: {result['error']}"},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        move_info = result['move']
        new_fen = result['new_fen']
        
        # Determine which player is the computer
        current_turn = board.turn
        computer_player = None
        if current_turn == chess.WHITE and not game.white_player:
            # White is computer, create a virtual computer user if needed
            from django.contrib.auth.models import User
            computer_player, created = User.objects.get_or_create(
                username='computer_white',
                defaults={'first_name': 'Computer', 'last_name': 'White'}
            )
            if not game.white_player:
                game.white_player = computer_player
        elif current_turn == chess.BLACK and not game.black_player:
            # Black is computer
            from django.contrib.auth.models import User
            computer_player, created = User.objects.get_or_create(
                username='computer_black', 
                defaults={'first_name': 'Computer', 'last_name': 'Black'}
            )
            if not game.black_player:
                game.black_player = computer_player
        else:
            return Response({"detail": "It's not the computer's turn."},
                            status=status.HTTP_400_BAD_REQUEST)
        
        # Parse the move
        try:
            chess_move = chess.Move.from_uci(move_info['uci'])
            san = board.san(chess_move)
        except Exception as e:
            logger.error(f"Error parsing computer move: {e}")
            return Response({"detail": "Invalid computer move generated."},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        # Create move record
        move_number = game.moves.count() + 1
        
        move_obj = Move.objects.create(
            game=game,
            player=computer_player,
            move_number=move_number,
            from_square=move_info['from_square'],
            to_square=move_info['to_square'],
            notation=san,
            fen_after_move=new_fen
        )
        
        logger.info(f"Computer move saved: {move_obj}")
        
        # Update game state
        game.fen = new_fen
        
        # Check if game is over
        new_board = chess.Board(new_fen)
        if new_board.is_game_over():
            game.status = 'finished'
            result_str = new_board.result()
            if result_str == '1-0':
                game.winner = game.white_player
            elif result_str == '0-1':
                game.winner = game.black_player
            logger.info(f"Game finished with result: {result_str}")
        else:
            game.status = 'active'
        
        game.save()
        logger.info(f"Game updated after computer move: status={game.status}")
        
        # Return response
        game_serializer = GameSerializer(game)
        move_serializer = MoveSerializer(move_obj)
        
        response_data = {
            "move": move_serializer.data,
            "game": game_serializer.data,
            "computer_move": {
                "from_square": move_info['from_square'],
                "to_square": move_info['to_square'],
                "notation": san,
                "uci": move_info['uci']
            },
            "engine_info": result['engine_info'],
            "game_status": result['game_status']
        }
        
        logger.info(f"Computer move response: {response_data}")
        return Response(response_data, status=status.HTTP_201_CREATED)
        
    except Exception as e:
        logger.error(f"Error making computer move for game {pk}: {e}")
        return Response({"detail": f"Error making computer move: {str(e)}"},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_computer_game(request):
    """Create a new game against the computer."""
    try:
        # Get player color preference (default to white)
        player_color = request.data.get('player_color', 'white').lower()
        difficulty = request.data.get('difficulty', 'medium')
        
        if player_color not in ['white', 'black']:
            player_color = 'white'
        
        if difficulty not in ['easy', 'medium', 'hard', 'expert']:
            difficulty = 'medium'
        
        # Create computer user if it doesn't exist
        from django.contrib.auth.models import User
        if player_color == 'white':
            computer_user, created = User.objects.get_or_create(
                username='computer_black',
                defaults={'first_name': 'Computer', 'last_name': 'Black'}
            )
            game = Game.objects.create(
                white_player=request.user,
                black_player=computer_user,
                fen=chess.STARTING_FEN,
                status='active'
            )
        else:
            computer_user, created = User.objects.get_or_create(
                username='computer_white',
                defaults={'first_name': 'Computer', 'last_name': 'White'}
            )
            game = Game.objects.create(
                white_player=computer_user,
                black_player=request.user,
                fen=chess.STARTING_FEN,
                status='active'
            )
        
        # Store difficulty in game metadata (you might want to add this field to the model)
        # For now, we'll include it in the response
        
        serializer = GameSerializer(game)
        logger.info(f"Computer game created: {game.id} by {request.user}, player_color: {player_color}, difficulty: {difficulty}")
        
        response_data = serializer.data
        response_data['difficulty'] = difficulty
        response_data['player_color'] = player_color
        response_data['is_computer_game'] = True
        
        return Response(response_data, status=status.HTTP_201_CREATED)
        
    except Exception as e:
        logger.error(f"Error creating computer game: {e}")
        return Response({"detail": f"Error creating computer game: {str(e)}"},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)
===== chess-platform/games/__init__.py =====

===== chess-platform/games/management/__init__.py =====

===== chess-platform/games/management/commands/check_timeouts.py =====
"""
Django management command for checking and handling game timeouts
Professional timeout detection system for chess games

Usage:
    python manage.py check_timeouts
    
This command should be run periodically (every 30 seconds) via cron job or task scheduler:
    */30 * * * * cd /path/to/chess-platform && python manage.py check_timeouts
"""

from django.core.management.base import BaseCommand
from django.utils import timezone
from django.db import transaction
import logging
from games.models import Game

logger = logging.getLogger(__name__)


class Command(BaseCommand):
    help = 'Check for game timeouts and automatically end timed-out games'

    def add_arguments(self, parser):
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be done without actually doing it',
        )
        parser.add_argument(
            '--verbose',
            action='store_true',
            help='Show detailed output for each game checked',
        )

    def handle(self, *args, **options):
        dry_run = options['dry_run']
        verbose = options['verbose']
        
        start_time = timezone.now()
        
        if verbose:
            self.stdout.write(
                self.style.SUCCESS(f'Starting timeout check at {start_time}')
            )

        # Get all active games
        active_games = Game.objects.filter(status='active').select_related(
            'white_player', 'black_player', 'time_control'
        )
        
        games_checked = 0
        games_timed_out = 0
        errors = 0

        for game in active_games:
            games_checked += 1
            
            try:
                with transaction.atomic():
                    # Check for timeout
                    timeout_info = game.check_timeout()
                    
                    if timeout_info['timeout']:
                        if dry_run:
                            self.stdout.write(
                                self.style.WARNING(
                                    f'DRY RUN: Game {game.id} would be ended due to timeout '
                                    f'({timeout_info["timeout_player"]} player)'
                                )
                            )
                        else:
                            # Handle the timeout
                            success = game.handle_timeout()
                            if success:
                                games_timed_out += 1
                                self.stdout.write(
                                    self.style.SUCCESS(
                                        f'Game {game.id} ended due to timeout '
                                        f'({timeout_info["timeout_player"]} player). '
                                        f'Winner: {timeout_info["winner"].username if timeout_info["winner"] else "None"}'
                                    )
                                )
                                
                                # Log the timeout for monitoring
                                logger.info(
                                    f'Game timeout handled: Game {game.id}, '
                                    f'timeout_player: {timeout_info["timeout_player"]}, '
                                    f'winner: {timeout_info["winner"].username if timeout_info["winner"] else "None"}'
                                )
                    elif verbose:
                        # Show game status for verbose mode
                        timer_info = game.get_timer_display()
                        self.stdout.write(
                            f'Game {game.id}: White {timer_info["white_time"]}s, '
                            f'Black {timer_info["black_time"]}s, '
                            f'Turn: {timer_info["current_turn"]}'
                        )
                        
            except Exception as e:
                errors += 1
                error_msg = f'Error checking game {game.id}: {str(e)}'
                self.stdout.write(self.style.ERROR(error_msg))
                logger.error(error_msg, exc_info=True)

        # Summary
        end_time = timezone.now()
        duration = (end_time - start_time).total_seconds()
        
        summary_style = self.style.SUCCESS if errors == 0 else self.style.WARNING
        
        self.stdout.write(
            summary_style(
                f'\nTimeout check completed in {duration:.2f}s\n'
                f'Games checked: {games_checked}\n'
                f'Games timed out: {games_timed_out}\n'
                f'Errors: {errors}'
            )
        )
        
        if dry_run:
            self.stdout.write(
                self.style.WARNING('DRY RUN MODE - No changes were made')
            )

===== chess-platform/games/management/commands/__init__.py =====

===== chess-platform/games/templates/games/game_list.html =====
{% load static %} 

<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Available Games</title>
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
</head>
<body>
    <h1>Available Games</h1>

    <!-- Create Game Button -->
    <button id="createGameBtn">Create Game</button>

    <!-- Games List -->
    <ul id="gamesList">
        <!-- Games will be loaded here by script.js -->
    </ul>

    <!-- Link to external JS -->
    <script src="{% static 'js/script.js' %}"></script>
</body>
</html>

===== chess-platform/games/utils/rating_calculator.py =====
# games/utils/rating_calculator.py
import math
from typing import Tuple
from django.conf import settings


class ELORatingCalculator:
    """
    Professional ELO rating system for chess games
    Based on standard FIDE ELO calculations with customizations
    """
    
    # K-factors based on rating and game count
    K_FACTORS = {
        'provisional': 40,  # First 30 games
        'below_2100': 20,   # Rating below 2100
        'above_2100': 10,   # Rating 2100 and above
        'blitz': 32,        # Blitz games get higher K-factor
        'rapid': 20,        # Rapid games standard K-factor
        'classical': 16,    # Classical games lower K-factor for stability
    }
    
    # Rating thresholds
    PROVISIONAL_GAMES = 30
    HIGH_RATING_THRESHOLD = 2100
    
    # Maximum rating change per game
    MAX_RATING_CHANGE = 50
    MIN_RATING_CHANGE = 1

    @classmethod
    def calculate_rating_change(
        cls, 
        player_rating: int,
        opponent_rating: int, 
        game_result: float,  # 1.0 = win, 0.5 = draw, 0.0 = loss
        time_control: str = 'rapid',
        player_games_count: int = 0,
        is_provisional: bool = False
    ) -> Tuple[int, dict]:
        """
        Calculate rating change for a player after a game
        
        Args:
            player_rating: Current rating of the player
            opponent_rating: Current rating of the opponent
            game_result: Game result (1.0/0.5/0.0)
            time_control: Type of game (blitz/rapid/classical)
            player_games_count: Total games played by player
            is_provisional: Whether player is in provisional period
            
        Returns:
            Tuple of (rating_change, calculation_details)
        """
        
        # Calculate expected score using ELO formula
        expected_score = cls._calculate_expected_score(player_rating, opponent_rating)
        
        # Determine K-factor
        k_factor = cls._get_k_factor(
            player_rating, 
            player_games_count, 
            time_control, 
            is_provisional
        )
        
        # Calculate raw rating change
        raw_change = k_factor * (game_result - expected_score)
        
        # Apply bounds and rounding
        rating_change = cls._apply_rating_change_bounds(raw_change)
        
        # Prepare calculation details
        details = {
            'expected_score': round(expected_score, 3),
            'k_factor': k_factor,
            'raw_change': round(raw_change, 2),
            'rating_change': rating_change,
            'new_rating': player_rating + rating_change,
            'confidence': cls._calculate_confidence(player_games_count)
        }
        
        return rating_change, details

    @classmethod
    def calculate_both_players(
        cls,
        white_rating: int,
        black_rating: int,
        game_result: str,  # '1-0', '0-1', '1/2-1/2'
        time_control: str = 'rapid',
        white_games: int = 0,
        black_games: int = 0
    ) -> Tuple[int, int, dict]:
        """
        Calculate rating changes for both players
        
        Returns:
            Tuple of (white_change, black_change, details)
        """
        
        # Convert result string to numeric values
        if game_result == '1-0':  # White wins
            white_result, black_result = 1.0, 0.0
        elif game_result == '0-1':  # Black wins
            white_result, black_result = 0.0, 1.0
        elif game_result == '1/2-1/2':  # Draw
            white_result, black_result = 0.5, 0.5
        else:
            raise ValueError(f"Invalid game result: {game_result}")
        
        # Calculate changes for both players
        white_change, white_details = cls.calculate_rating_change(
            white_rating, black_rating, white_result, time_control, white_games
        )
        
        black_change, black_details = cls.calculate_rating_change(
            black_rating, white_rating, black_result, time_control, black_games
        )
        
        # Combined details
        combined_details = {
            'white': white_details,
            'black': black_details,
            'game_result': game_result,
            'time_control': time_control,
            'rating_difference': abs(white_rating - black_rating)
        }
        
        return white_change, black_change, combined_details

    @classmethod
    def _calculate_expected_score(cls, player_rating: int, opponent_rating: int) -> float:
        """Calculate expected score using standard ELO formula"""
        rating_difference = opponent_rating - player_rating
        return 1 / (1 + math.pow(10, rating_difference / 400))

    @classmethod
    def _get_k_factor(
        cls, 
        rating: int, 
        games_count: int, 
        time_control: str, 
        is_provisional: bool
    ) -> int:
        """Determine K-factor based on various conditions"""
        
        if is_provisional or games_count < cls.PROVISIONAL_GAMES:
            return cls.K_FACTORS['provisional']
        
        # Time control specific K-factors
        time_control_k = cls.K_FACTORS.get(time_control, cls.K_FACTORS['rapid'])
        
        # Rating based adjustments
        if rating >= cls.HIGH_RATING_THRESHOLD:
            # Reduce K-factor for high-rated players for stability
            return max(time_control_k - 4, cls.K_FACTORS['above_2100'])
        else:
            return time_control_k

    @classmethod
    def _apply_rating_change_bounds(cls, raw_change: float) -> int:
        """Apply minimum and maximum bounds to rating changes"""
        # Round to nearest integer
        change = round(raw_change)
        
        # Apply bounds
        if change > 0:
            change = max(change, cls.MIN_RATING_CHANGE)
            change = min(change, cls.MAX_RATING_CHANGE)
        elif change < 0:
            change = min(change, -cls.MIN_RATING_CHANGE)
            change = max(change, -cls.MAX_RATING_CHANGE)
        
        return change

    @classmethod
    def _calculate_confidence(cls, games_count: int) -> str:
        """Calculate rating confidence based on games played"""
        if games_count < 10:
            return 'Very Low'
        elif games_count < 30:
            return 'Low'
        elif games_count < 100:
            return 'Medium'
        elif games_count < 500:
            return 'High'
        else:
            return 'Very High'

    @classmethod
    def get_rating_class(cls, rating: int) -> str:
        """Get rating class/title based on rating"""
        if rating < 800:
            return 'Beginner'
        elif rating < 1000:
            return 'Novice'
        elif rating < 1200:
            return 'Amateur'
        elif rating < 1400:
            return 'Intermediate'
        elif rating < 1600:
            return 'Advanced'
        elif rating < 1800:
            return 'Expert'
        elif rating < 2000:
            return 'Master'
        elif rating < 2200:
            return 'International Master'
        elif rating < 2400:
            return 'Grandmaster'
        else:
            return 'Super Grandmaster'

    @classmethod
    def simulate_rating_progression(
        cls, 
        initial_rating: int = 1200, 
        games: int = 100,
        win_rate: float = 0.5,
        time_control: str = 'rapid'
    ) -> list:
        """
        Simulate rating progression over multiple games
        Useful for testing and demonstration
        """
        
        progression = [{'game': 0, 'rating': initial_rating, 'change': 0}]
        current_rating = initial_rating
        
        import random
        
        for game_num in range(1, games + 1):
            # Simulate opponent rating (normal distribution around player rating)
            opponent_rating = max(800, int(random.gauss(current_rating, 200)))
            
            # Simulate game result based on win rate
            rand_result = random.random()
            if rand_result < win_rate - 0.1:  # Win
                result = 1.0
            elif rand_result < win_rate + 0.1:  # Draw  
                result = 0.5
            else:  # Loss
                result = 0.0
            
            # Calculate rating change
            change, _ = cls.calculate_rating_change(
                current_rating, 
                opponent_rating, 
                result, 
                time_control, 
                game_num - 1
            )
            
            current_rating += change
            
            progression.append({
                'game': game_num,
                'rating': current_rating,
                'change': change,
                'opponent_rating': opponent_rating,
                'result': result
            })
        
        return progression


# Convenience functions for common calculations
def calculate_game_rating_changes(white_user, black_user, game_result, time_control='rapid'):
    """
    Calculate rating changes for a completed game
    
    Args:
        white_user: CustomUser instance for white player
        black_user: CustomUser instance for black player  
        game_result: '1-0', '0-1', or '1/2-1/2'
        time_control: 'blitz', 'rapid', or 'classical'
    
    Returns:
        Tuple of (white_change, black_change, details)
    """
    
    white_rating = white_user.get_rating(time_control)
    black_rating = black_user.get_rating(time_control)
    
    white_games = getattr(white_user, f'{time_control}_games', 0)
    black_games = getattr(black_user, f'{time_control}_games', 0)
    
    return ELORatingCalculator.calculate_both_players(
        white_rating=white_rating,
        black_rating=black_rating,
        game_result=game_result,
        time_control=time_control,
        white_games=white_games,
        black_games=black_games
    )


def update_player_ratings(white_user, black_user, game_result, time_control='rapid', game_instance=None):
    """
    Update both players' ratings and create rating history records
    
    Args:
        white_user: CustomUser instance for white player
        black_user: CustomUser instance for black player
        game_result: '1-0', '0-1', or '1/2-1/2' 
        time_control: 'blitz', 'rapid', or 'classical'
        game_instance: Game model instance for history tracking
    """
    
    from accounts.models import RatingHistory
    
    # Calculate rating changes
    white_change, black_change, details = calculate_game_rating_changes(
        white_user, black_user, game_result, time_control
    )
    
    # Update white player
    white_old_rating = white_user.get_rating(time_control)
    white_new_rating = white_old_rating + white_change
    setattr(white_user, f'{time_control}_rating', white_new_rating)
    
    # Update black player  
    black_old_rating = black_user.get_rating(time_control)
    black_new_rating = black_old_rating + black_change
    setattr(black_user, f'{time_control}_rating', black_new_rating)
    
    # Update game statistics
    white_result = 'win' if game_result == '1-0' else ('draw' if game_result == '1/2-1/2' else 'loss')
    black_result = 'win' if game_result == '0-1' else ('draw' if game_result == '1/2-1/2' else 'loss')
    
    white_user.update_game_stats(white_result, time_control)
    black_user.update_game_stats(black_result, time_control)
    
    # Save both users
    white_user.save()
    black_user.save()
    
    # Create rating history records
    RatingHistory.objects.create(
        user=white_user,
        time_control=time_control,
        old_rating=white_old_rating,
        new_rating=white_new_rating,
        rating_change=white_change,
        game=game_instance,
        reason='game_result'
    )
    
    RatingHistory.objects.create(
        user=black_user,
        time_control=time_control,
        old_rating=black_old_rating,
        new_rating=black_new_rating,
        rating_change=black_change,
        game=game_instance,
        reason='game_result'
    )
    
    return {
        'white_change': white_change,
        'black_change': black_change,
        'white_new_rating': white_new_rating,
        'black_new_rating': black_new_rating,
        'details': details
    }

===== chess-platform/games/utils/__init__.py =====
