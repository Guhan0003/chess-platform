//this is test frontend/index.html(real frontend is in C:\Users\guhan\chess-platform\frontend\src\pages\)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Platform</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/png" href="assets/favicon.jpeg">
</head>
<body>
  <header class="container">
    <h1>Chess Platform</h1>
    <p class="note">Vanilla HTML/CSS/JS talking to Django API</p>
  </header>

  <main class="container grid">
    <section class="card" id="auth">
      <h2>Authentication</h2>

      <div class="stack">
        <h3>Login</h3>
        <form id="loginForm" autocomplete="on">
          <label>
            Username
            <input id="login-username" name="username" required />
          </label>
          <label>
            Password
            <input id="login-password" name="password" type="password" required />
          </label>
          <button type="submit">Login</button>
        </form>
      </div>

      <hr />

      <div class="stack">
        <h3>Register</h3>
        <form id="registerForm" autocomplete="on">
          <label>
            Username
            <input id="register-username" name="username" required />
          </label>
          <label>
            Email
            <input id="register-email" name="email" type="email" />
          </label>
          <label>
            Password
            <input id="register-password" name="password" type="password" required />
            <input id="register-password-confirm" name="passwordConfirm" type="password" placeholder="Confirm password" required />
          </label>
          <button type="submit">Register</button>
        </form>
      </div>

      <div class="stack">
        <h3>Session</h3>
        <div class="row">
          <button id="btn-logout" type="button">Logout</button>
          <button id="btn-refresh" type="button">Refresh Token</button>
        </div>
        <p><strong>Status:</strong> <span id="auth-status">Signed out</span></p>
      </div>
    </section>

    <section class="card" id="actions">
      <h2>Game Actions</h2>

      <div class="stack">
        <button id="btn-create" type="button">Create New Game (You as White)</button>
      </div>

      <div class="stack">
        <h3>Join a Game</h3>
        <form id="joinForm">
          <label>
            Game ID
            <input id="join-game-id" name="gameId" type="number" required />
          </label>
          <button type="submit">Join as Black</button>
        </form>
      </div>

      <div class="stack">
        <h3>Make a Move</h3>
        <form id="moveForm" autocomplete="off">
          <label>
            Game ID
            <input id="move-game-id" name="gameId" type="number" required />
          </label>
          <label>
            From (e.g., e2)
            <input id="move-from" name="from" maxlength="2" required />
          </label>
          <label>
            To (e.g., e4)
            <input id="move-to" name="to" maxlength="2" required />
          </label>
          <label>
            Promotion (q/r/b/n, optional)
            <input id="move-promo" name="promotion" maxlength="1" />
          </label>
          <button type="submit">Submit Move</button>
        </form>
      </div>

      <div class="stack">
        <h3>Quick Fetch Game</h3>
        <form id="detailsForm" class="row">
          <label>
            Game ID
            <input id="details-game-id" name="gameId" type="number" />
          </label>
          <button type="submit">Fetch</button>
        </form>
      </div>
    </section>

    <section class="card" id="board-card">
      <h2>Board</h2>
      <div id="board-wrapper">
        <div id="chessboard" data-asset-base="assets"></div>

        <aside id="sidebar">
          <div class="stack">
            <h3>Current Game</h3>
            <p><strong>ID:</strong> <span id="current-game-id">â€”</span></p>
            <p><strong>Status:</strong> <span id="current-game-status">â€”</span></p>
            <p><strong>Turn:</strong> <span id="current-turn">â€”</span></p>
          </div>
          <div class="stack">
            <h3>Moves</h3>
            <ol id="move-list" class="move-list"></ol>
          </div>
        </aside>
      </div>
    </section>

    <section class="card" id="games">
      <h2>Available Games</h2>
      <div id="games-list" class="list">Loadingâ€¦</div>
    </section>

    <section class="card" id="details">
      <h2>Game Details (Raw)</h2>
      <pre id="details-output" class="pre">No game loaded.</pre>
    </section>
  </main>

  <footer class="container">
    <small>Â© Your Chess Platform</small>
  </footer>

  <script>
    // ================================
    // Globals & API Configuration
    // ================================
    const API_BASE = "http://127.0.0.1:8000/api";
    let accessToken = localStorage.getItem("access");
    let refreshToken = localStorage.getItem("refresh");
    let activeGameId = null;
    
    // ================================
    // DOM Element References
    // ================================
    let elements = {};
    
    // ================================
    // Authentication & Token Helpers
    // ================================
    function saveTokens(access, refresh) {
      accessToken = access;
      refreshToken = refresh;
      localStorage.setItem("access", access);
      localStorage.setItem("refresh", refresh);
      updateAuthUI();
    }
    
    function clearTokens() {
      accessToken = null;
      refreshToken = null;
      localStorage.removeItem("access");
      localStorage.removeItem("refresh");
      updateAuthUI();
    }
    
    function updateAuthUI() {
      if (elements.authStatus) {
        elements.authStatus.textContent = accessToken ? "Signed in" : "Signed out";
      }
    }
    
    async function apiFetch(url, options = {}) {
      options.headers = options.headers || {};
      if (accessToken) {
        options.headers["Authorization"] = `Bearer ${accessToken}`;
      }
    
      let response = await fetch(url, options);
    
      if (response.status === 401 && refreshToken) {
        const refreshed = await refreshAccessToken();
        if (refreshed) {
          options.headers["Authorization"] = `Bearer ${accessToken}`;
          response = await fetch(url, options);
        }
      }
    
      return response;
    }
    
    // ================================
    // API Functions
    // ================================
    async function registerUser(username, email, password) {
      const res = await fetch(`${API_BASE}/auth/register/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, email, password }),
      });
      return { ok: res.ok, data: await res.json() };
    }
    
    async function loginUser(username, password) {
      const res = await fetch(`${API_BASE}/auth/login/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });
      const data = await res.json();
      if (res.ok) {
        saveTokens(data.access, data.refresh);
      }
      return { ok: res.ok, data };
    }
    
    async function refreshAccessToken() {
      if (!refreshToken) return false;
      const res = await fetch(`${API_BASE}/auth/refresh/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refresh: refreshToken }),
      });
      if (res.ok) {
        const data = await res.json();
        saveTokens(data.access, refreshToken);
        return true;
      }
      clearTokens();
      return false;
    }
    
    async function logoutUser() {
      if (refreshToken) {
        await apiFetch(`${API_BASE}/auth/logout/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ refresh: refreshToken }),
        });
      }
      clearTokens();
      alert("You have been logged out.");
    }
    
    async function createGame() {
      const res = await apiFetch(`${API_BASE}/games/create/`, { method: "POST" });
      return { ok: res.ok, data: await res.json() };
    }
    
    async function joinGame(gameId) {
      const res = await apiFetch(`${API_BASE}/games/${gameId}/join/`, { method: "POST" });
      return { ok: res.ok, data: await res.json() };
    }
    
    // ================================
    // Timer Management System
    // ================================
    let gameTimer = { white_time: 600, black_time: 600, current_turn: 'white' };
    let currentTurn = 'white';
    let lastTimerUpdate = Date.now();
    let timerInterval = null;

    // Start timer management
    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      
      timerInterval = setInterval(() => {
        updateTimerDisplay();
        saveTimerState();
      }, 1000);
      
      updateTimerDisplay();
    }

    // Update timer display
    function updateTimerDisplay() {
      if (gameTimer && lastTimerUpdate) {
        const elapsed = Math.floor((Date.now() - lastTimerUpdate) / 1000);
        
        let whiteTime = gameTimer.white_time;
        let blackTime = gameTimer.black_time;
        
        if (elapsed >= 0 && elapsed < 60) {
          if (currentTurn === 'white') {
            whiteTime = Math.max(0, whiteTime - elapsed);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
          }
        }
        
        const whiteMinutes = Math.floor(whiteTime / 60);
        const whiteSeconds = whiteTime % 60;
        const blackMinutes = Math.floor(blackTime / 60);
        const blackSeconds = blackTime % 60;
        
        console.log(`â±ï¸ Timer updated - White: ${whiteMinutes}:${whiteSeconds.toString().padStart(2, '0')}, Black: ${blackMinutes}:${blackSeconds.toString().padStart(2, '0')}, Turn: ${currentTurn}`);
      }
    }

    // Switch turns after moves
    function switchTurn(reason = 'move') {
      console.log(`ðŸš¨ðŸš¨ðŸš¨ SWITCHING TURN! Reason: ${reason} ðŸš¨ðŸš¨ðŸš¨`);
      console.log(`ðŸ” Before: currentTurn=${currentTurn}`);
      
      // Save current player's time
      if (lastTimerUpdate) {
        const elapsed = Math.floor((Date.now() - lastTimerUpdate) / 1000);
        if (elapsed > 0 && elapsed < 60) {
          if (currentTurn === 'white') {
            gameTimer.white_time = Math.max(0, gameTimer.white_time - elapsed);
            console.log(`â° White timer updated: ${gameTimer.white_time}s`);
          } else {
            gameTimer.black_time = Math.max(0, gameTimer.black_time - elapsed);
            console.log(`â° Black timer updated: ${gameTimer.black_time}s`);
          }
        }
      }
      
      // Switch to other player
      currentTurn = currentTurn === 'white' ? 'black' : 'white';
      gameTimer.current_turn = currentTurn;
      lastTimerUpdate = Date.now();
      
      console.log(`âœ…âœ…âœ… TURN SWITCHED TO: ${currentTurn} âœ…âœ…âœ…`);
      console.log(`â° Timer values: White=${gameTimer.white_time}s, Black=${gameTimer.black_time}s`);
      
      updateTimerDisplay();
    }

    // Save timer state to localStorage
    function saveTimerState() {
      if (activeGameId) {
        const timerState = {
          white_time: gameTimer.white_time,
          black_time: gameTimer.black_time,
          current_turn: currentTurn,
          timestamp: Date.now()
        };
        localStorage.setItem(`timer_${activeGameId}`, JSON.stringify(timerState));
      }
    }

    // Load timer state from localStorage
    function loadTimerState() {
      if (activeGameId) {
        const saved = localStorage.getItem(`timer_${activeGameId}`);
        if (saved) {
          try {
            const timerState = JSON.parse(saved);
            const age = Date.now() - timerState.timestamp;
            if (age < 300000) { // 5 minutes
              console.log('ðŸ“‚ Loading saved timer state:', timerState);
              
              // Apply elapsed time since save
              const timeSinceSave = Math.floor(age / 1000);
              if (timeSinceSave > 0 && timeSinceSave < 60) {
                if (timerState.current_turn === 'white') {
                  timerState.white_time = Math.max(0, timerState.white_time - timeSinceSave);
                } else {
                  timerState.black_time = Math.max(0, timerState.black_time - timeSinceSave);
                }
              }
              
              gameTimer = timerState;
              currentTurn = timerState.current_turn;
              lastTimerUpdate = Date.now();
              return true;
            }
          } catch (e) {
            console.warn('Failed to parse saved timer state');
          }
        }
      }
      return false;
    }

    async function makeMove(gameId, from, to, promotion = null) {
      console.log("ðŸš¨ðŸš¨ðŸš¨ MAKEMOVE CALLED! ðŸš¨ðŸš¨ðŸš¨", {gameId, from, to, promotion});
      
      if (!gameId) {
        console.error("No active game selected.");
        alert("No active game selected. Please create or join a game first!");
        return { ok: false, data: { detail: "No active game selected" } };
      }

      const payload = { from_square: from, to_square: to };
      if (promotion) payload.promotion = promotion;

      try {
        const res = await apiFetch(`${API_BASE}/games/${gameId}/move/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        const data = await res.json();
        console.log("Move API response:", data);

        if (!res.ok) {
          return { ok: false, data };
        }

        console.log("âœ… Move successful! Switching turn...");
        
        // Switch turn after successful move
        switchTurn('player_move');

        return { ok: true, data };
      } catch (err) {
        console.error("Network/move error:", err);
        return { ok: false, data: { detail: "Network error" } };
      }
    }    async function getGames() {
      const res = await apiFetch(`${API_BASE}/games/`);
      return { ok: res.ok, data: await res.json() };
    }
    
    async function getGameDetail(gameId) {
      const res = await apiFetch(`${API_BASE}/games/${gameId}/`);
      return { ok: res.ok, data: await res.json() };
    }
    
    // ================================
    // Chessboard Rendering
    // ================================
    function fenCharToAssetChar(ch) {
      const mapping = {
        p: "bP", r: "bR", n: "bN", b: "bB", q: "bQ", k: "bK",
        P: "wP", R: "wR", N: "wN", B: "wB", Q: "wQ", K: "wK",
      };
      return mapping[ch] || "";
    }
    
    function renderBoardFromFen(fen, assetBase = "assets") {
      if (!elements.chessboard) return;
      elements.chessboard.innerHTML = "";
    
      const placement = fen.split(" ")[0];
      const ranks = placement.split("/");
    
      for (let rankIndex = 0; rankIndex < 8; rankIndex++) {
        const rankStr = ranks[rankIndex];
        let fileIndex = 0;
        for (const char of rankStr) {
          if (/\d/.test(char)) {
            const emptySquares = parseInt(char, 10);
            for (let i = 0; i < emptySquares; i++) {
              const square = document.createElement("div");
              const isLight = (rankIndex + fileIndex) % 2 === 0;
              square.className = `square ${isLight ? 'light' : 'dark'}`;
              square.dataset.coord = String.fromCharCode(97 + fileIndex) + (8 - rankIndex);
              elements.chessboard.appendChild(square);
              fileIndex++;
            }
          } else {
            const square = document.createElement("div");
            const isLight = (rankIndex + fileIndex) % 2 === 0;
            square.className = `square ${isLight ? 'light' : 'dark'}`;
            square.dataset.coord = String.fromCharCode(97 + fileIndex) + (8 - rankIndex);
    
            const assetName = fenCharToAssetChar(char);
            if (assetName) {
              const img = document.createElement("img");
              img.src = `${assetBase}/${assetName}.png`;
              img.alt = assetName;
              img.draggable = false;
              square.appendChild(img);
            }
            elements.chessboard.appendChild(square);
            fileIndex++;
          }
        }
      }
    
      // Enable click-to-move after rendering
      enableClickToMove();
    }
    
    // ================================
    // Click-to-Move Support
    // ================================
    let selectedSquare = null;
    
    function enableClickToMove() {
      if (!elements.chessboard) return;
    
      const squares = elements.chessboard.querySelectorAll(".square");
      squares.forEach(square => {
        square.addEventListener("click", async () => {
          const coord = square.dataset.coord;
          
          // Show feedback that square was clicked
          console.log("Clicked square:", coord, "Active game:", activeGameId);
    
          if (!activeGameId) {
            alert("No active game selected. Please create or join a game first!");
            return;
          }
    
          if (!selectedSquare) {
            // First click: select source
            selectedSquare = coord;
            
            // Remove any existing selections
            squares.forEach(sq => sq.classList.remove("selected"));
            square.classList.add("selected");
            
            console.log("Selected square:", selectedSquare);
          } else {
            // Second click: make move
            const from = selectedSquare;
            const to = coord;
    
            // Remove selection highlight
            squares.forEach(sq => sq.classList.remove("selected"));
            selectedSquare = null;
    
            console.log("Making move:", from, "to", to);
    
            // Check for pawn promotion
            let promotion = null;
            const fromRank = parseInt(from[1], 10);
            const toRank = parseInt(to[1], 10);
            if ((fromRank === 7 && toRank === 8) || (fromRank === 2 && toRank === 1)) {
              promotion = prompt("Promote to (q/r/b/n)? Leave empty for queen.", "q") || "q";
            }
    
            const { ok, data } = await makeMove(activeGameId, from, to, promotion);
            if (ok) {
              console.log("Move successful!");
              // Refresh the game state
              await updateGameDetails(activeGameId);
            } else {
              console.error("Move failed:", data);
              alert(`Invalid move: ${data.detail || JSON.stringify(data)}`);
            }
          }
        });
      });
    }
    
    // ================================
    // UI Update Functions
    // ================================
    async function updateGamesList() {
      if (!elements.gamesList) return;
      elements.gamesList.innerHTML = "Loading...";
      const { ok, data } = await getGames();
      if (!ok) {
        elements.gamesList.innerHTML = "Failed to load games. Please log in first.";
        return;
      }
    
      elements.gamesList.innerHTML = "";
      if (data.length === 0) {
        elements.gamesList.innerHTML = "No available games.";
        return;
      }
    
      data.forEach(game => {
        const item = document.createElement("div");
        item.className = "game-item";
        item.innerHTML = `
          <div class="game-meta">
            <span class="players">#${game.id}: ${game.white_player_username || '...'} vs ${game.black_player_username || '...'}</span>
            <span class="status">${game.status}</span>
          </div>
          <div class="row">
            <button class="view-game-btn" data-game-id="${game.id}">View & Play</button>
          </div>
        `;
        elements.gamesList.appendChild(item);
      });
    }
    
    async function updateGameDetails(gameId) {
      const { ok, data: game } = await getGameDetail(gameId);
      if (!ok) {
        alert("Could not fetch game details.");
        return;
      }

      if (elements.detailsOutput) {
        elements.detailsOutput.textContent = JSON.stringify(game, null, 2);
      }

      if (elements.currentGameId) elements.currentGameId.textContent = game.id;
      activeGameId = game.id; // IMPORTANT: Set the active game

      if (elements.currentGameStatus) elements.currentGameStatus.textContent = game.status;
      if (elements.currentTurn) {
        const turn = game.fen.split(" ")[1] === 'w' ? 'White' : 'Black';
        elements.currentTurn.textContent = turn;
      }

      // Initialize timer for this game
      if (!loadTimerState()) {
        // If no saved state, initialize with default values
        console.log('ðŸŽ® Initializing new game timer');
        gameTimer = { white_time: 600, black_time: 600, current_turn: 'white' };
        currentTurn = 'white';
        lastTimerUpdate = Date.now();
      }
      
      // Start the timer
      startTimer();

      if (elements.moveList) {
        elements.moveList.innerHTML = "";
        game.moves.forEach(move => {
          const li = document.createElement("li");
          li.textContent = `${move.move_number}. ${move.notation}`;
          elements.moveList.appendChild(li);
        });
      }

      const assetBase = elements.chessboard.dataset.assetBase || "assets";
      renderBoardFromFen(game.fen, assetBase);
      
      console.log("Game loaded:", game.id, "Status:", game.status);
    }    // ================================
    // Event Listeners Setup
    // ================================
    function initializeEventListeners() {
      elements.loginForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const username = elements.loginForm.elements.username.value;
        const password = elements.loginForm.elements.password.value;
        const { ok, data } = await loginUser(username, password);
        if (ok) {
          alert("Login successful!");
          await updateGamesList();
        } else {
          alert(`Login failed: ${JSON.stringify(data)}`);
        }
      });
    
      elements.registerForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const username = elements.registerForm.elements.username.value;
        const email = elements.registerForm.elements.email.value;
        const password = elements.registerForm.elements.password.value;
        const { ok, data } = await registerUser(username, email, password);
        if (ok) {
          alert("Registration successful! Please log in.");
        } else {
          alert(`Registration failed: ${JSON.stringify(data)}`);
        }
      });
    
      elements.btnLogout?.addEventListener("click", logoutUser);
    
      elements.btnRefresh?.addEventListener("click", async () => {
        const success = await refreshAccessToken();
        alert(success ? "Token refreshed." : "Failed to refresh token.");
      });
    
      elements.btnCreate?.addEventListener("click", async () => {
        const { ok, data } = await createGame();
        if (ok) {
          alert(`Game #${data.id} created!`);
          await updateGamesList();
          await updateGameDetails(data.id); // auto-open created game
        } else {
          alert(`Failed to create game: ${JSON.stringify(data)}`);
        }
      });
    
      elements.joinForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const gameId = elements.joinForm.elements.gameId.value;
        const { ok, data } = await joinGame(gameId);
        if (ok) {
          alert(`Successfully joined game #${data.id}`);
          await updateGamesList();
          await updateGameDetails(data.id); // open joined game
        } else {
          alert(`Failed to join game: ${JSON.stringify(data)}`);
        }
      });
    
      elements.moveForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const gameId = elements.moveForm.elements.gameId.value;
        const from = elements.moveForm.elements.from.value;
        const to = elements.moveForm.elements.to.value;
        const promotion = elements.moveForm.elements.promotion.value || null;
    
        const { ok, data } = await makeMove(gameId || activeGameId, from, to, promotion);
        if (ok) {
          alert("Move successful!");
          await updateGameDetails(gameId || activeGameId);
        } else {
          alert(`Invalid move: ${JSON.stringify(data)}`);
        }
      });
    
      elements.detailsForm?.addEventListener("submit", async (e) => {
        e.preventDefault();
        const gameId = elements.detailsForm.elements.gameId.value;
        if (gameId) {
          await updateGameDetails(gameId);
        }
      });
    
      elements.gamesList?.addEventListener("click", (e) => {
        if (e.target.classList.contains("view-game-btn")) {
          const gameId = e.target.dataset.gameId;
          updateGameDetails(gameId);
        }
      });
    }
    
    // ================================
    // Initial Page Load
    // ================================
    document.addEventListener("DOMContentLoaded", () => {
      elements = {
        authStatus: document.getElementById("auth-status"),
        loginForm: document.getElementById("loginForm"),
        registerForm: document.getElementById("registerForm"),
        btnLogout: document.getElementById("btn-logout"),
        btnRefresh: document.getElementById("btn-refresh"),
        btnCreate: document.getElementById("btn-create"),
        joinForm: document.getElementById("joinForm"),
        moveForm: document.getElementById("moveForm"),
        detailsForm: document.getElementById("detailsForm"),
        gamesList: document.getElementById("games-list"),
        detailsOutput: document.getElementById("details-output"),
        chessboard: document.getElementById("chessboard"),
        currentGameId: document.getElementById("current-game-id"),
        currentGameStatus: document.getElementById("current-game-status"),
        currentTurn: document.getElementById("current-turn"),
        moveList: document.getElementById("move-list"),
      };
    
      initializeEventListeners();
      updateAuthUI();
    
      // Render a default board on load
      const startFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
      const assetBase = elements.chessboard?.dataset.assetBase || "assets";
      renderBoardFromFen(startFen, assetBase);
    
      // Load available games if logged in
      if (accessToken) {
        updateGamesList();
      }
    });
  </script>
</body>
</html>