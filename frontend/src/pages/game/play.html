<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game - Chess Platform</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>♛</text></svg>">
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Game-specific styles maintaining design consistency */
    .game-container {
      min-height: 100vh;
      background: 
        radial-gradient(ellipse at top left, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      display: flex;
      flex-direction: column;
    }

    /* Game Header */
    .game-header {
      height: var(--header-height);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-xl);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .game-title {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .game-id {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
    }

    .current-user-info {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      background: rgba(255, 255, 255, 0.05);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
    }

    .current-user-info strong {
      color: var(--color-accent-primary);
    }

    .game-status-badge {
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
    }

    .status-active {
      background: rgba(34, 197, 94, 0.2);
      color: var(--color-success);
    }

    .status-waiting {
      background: rgba(251, 191, 36, 0.2);
      color: var(--color-warning);
    }

    .status-finished {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .game-actions {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .back-btn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: var(--font-size-sm);
      transition: all var(--transition-normal);
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-accent-primary);
      transform: translateX(-2px);
    }

    /* Game Content */
    .game-content {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr auto 320px;
      gap: var(--space-xl);
      padding: var(--space-xl);
      align-items: start;
    }

    /* Player Info */
    .players-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .player-card {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-lg);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      transition: all var(--transition-normal);
    }

    .player-card.current-turn {
      border-color: var(--color-accent-primary);
      box-shadow: 0 0 0 1px rgba(118, 150, 86, 0.2), var(--shadow-md);
      background: rgba(118, 150, 86, 0.03);
    }

    .player-card.black {
      order: -1; /* Black player on top */
    }

    .player-avatar {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
      position: relative;
    }

    .player-avatar.black {
      background: linear-gradient(135deg, var(--color-bg-tertiary) 0%, #1f2937 100%);
      color: var(--color-text-primary);
    }

    .player-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .player-name {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
    }

    .player-rating {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .rating-badge {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
      font-weight: var(--font-weight-medium);
    }

    .player-timer {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      font-family: var(--font-family-mono);
      min-width: 80px;
      text-align: right;
    }

    .player-timer.low-time {
      color: var(--color-error);
      animation: pulse-timer 1s ease-in-out infinite;
    }

    @keyframes pulse-timer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .turn-indicator {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 12px;
      height: 12px;
      border-radius: var(--radius-full);
      background: var(--color-accent-primary);
      border: 2px solid var(--color-bg-primary);
      animation: pulse 2s ease-in-out infinite;
    }

    /* Chess Board */
    .board-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 500px;
      padding: var(--space-md);
    }

    .chess-board {
      width: min(70vh, 500px);
      height: min(70vh, 500px);
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      border: 2px solid var(--glass-border);
      position: relative;
    }

    .chess-square {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all var(--transition-fast);
      user-select: none;
    }

    .chess-square.light {
      background-color: var(--color-board-light);
    }

    .chess-square.dark {
      background-color: var(--color-board-dark);
    }

    .chess-square:hover {
      background-color: rgba(118, 150, 86, 0.3) !important;
    }

    .chess-square.selected {
      background-color: rgba(255, 235, 59, 0.7) !important;
      box-shadow: inset 0 0 0 3px #ffd700;
    }

    .chess-square.possible-move {
      background-color: rgba(34, 197, 94, 0.3) !important;
    }

    .chess-square.possible-move::after {
      content: '';
      width: 30%;
      height: 30%;
      border-radius: var(--radius-full);
      background: rgba(34, 197, 94, 0.6);
    }

    .chess-square.possible-capture {
      background-color: rgba(239, 68, 68, 0.3) !important;
    }

    .chess-square.possible-capture::after {
      content: '';
      width: 100%;
      height: 100%;
      border: 3px solid rgba(239, 68, 68, 0.7);
      border-radius: var(--radius-sm);
      position: absolute;
      box-sizing: border-box;
    }

    .chess-square.last-move {
      background-color: rgba(59, 130, 246, 0.4) !important;
    }

    .chess-square.in-check {
      background-color: rgba(239, 68, 68, 0.5) !important;
      animation: check-flash 0.5s ease-in-out;
    }

    @keyframes check-flash {
      0%, 100% { background-color: rgba(239, 68, 68, 0.5) !important; }
      50% { background-color: rgba(239, 68, 68, 0.8) !important; }
    }

    .chess-piece {
      font-size: 2.5rem;
      user-select: none;
      pointer-events: none;
      transition: transform var(--transition-fast);
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .chess-piece.white-piece {
      color: #f8f9fa;
      text-shadow: 
        1px 1px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .chess-piece.black-piece {
      color: #1a1a1a;
      text-shadow: 
        1px 1px 0 #fff,
        -1px -1px 0 #fff,
        1px -1px 0 #fff,
        -1px 1px 0 #fff,
        2px 2px 4px rgba(255, 255, 255, 0.3);
    }

    .chess-square:hover .chess-piece {
      transform: scale(1.05);
    }

    /* Coordinate Labels */
    .coord-label {
      position: absolute;
      font-size: 0.7rem;
      font-weight: var(--font-weight-medium);
      color: rgba(0, 0, 0, 0.6);
      pointer-events: none;
    }

    .coord-file {
      bottom: 2px;
      right: 4px;
    }

    .coord-rank {
      top: 2px;
      left: 4px;
    }

    /* Game Sidebar */
    .game-sidebar {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
      min-width: 320px;
    }

    .sidebar-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
    }

    .panel-header {
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: between;
      gap: var(--space-sm);
    }

    .panel-title {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .panel-content {
      padding: var(--space-lg);
    }

    /* Game Controls */
    .game-controls {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .control-group {
      display: flex;
      gap: var(--space-sm);
    }

    .control-btn {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      transition: all var(--transition-normal);
      cursor: pointer;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--color-accent-primary);
      color: var(--color-accent-primary);
    }

    .control-btn.danger:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: var(--color-error);
      color: var(--color-error);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Move History */
    .move-history {
      max-height: 300px;
      overflow-y: auto;
      padding: var(--space-sm) 0;
    }

    .move-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .move-pair {
      display: grid;
      grid-template-columns: auto 1fr 1fr;
      gap: var(--space-sm);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-family: var(--font-family-mono);
      font-size: var(--font-size-sm);
      transition: background var(--transition-fast);
    }

    .move-pair:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .move-number {
      color: var(--color-text-muted);
      font-weight: var(--font-weight-medium);
      min-width: 20px;
    }

    .move-white,
    .move-black {
      color: var(--color-text-secondary);
      cursor: pointer;
      padding: 2px var(--space-xs);
      border-radius: var(--radius-xs);
      transition: all var(--transition-fast);
    }

    .move-white:hover,
    .move-black:hover {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
    }

    .move-current {
      background: rgba(118, 150, 86, 0.3) !important;
      color: var(--color-accent-primary) !important;
    }

    /* Game Status */
    .game-status {
      text-align: center;
      padding: var(--space-lg);
    }

    .status-message {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }

    .status-details {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
    }

    /* Captured Pieces */
    .captured-pieces {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
      justify-content: center;
    }

    .captured-piece {
      font-size: 1.2rem;
      opacity: 0.7;
      filter: grayscale(50%);
    }

    /* Promotion Dialog */
    .promotion-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .promotion-dialog.show {
      opacity: 1;
      visibility: visible;
    }

    .promotion-content {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-xl);
      text-align: center;
    }

    .promotion-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-lg);
    }

    .promotion-pieces {
      display: flex;
      gap: var(--space-md);
      justify-content: center;
    }

    .promotion-piece {
      width: 60px;
      height: 60px;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .promotion-piece:hover {
      background: rgba(118, 150, 86, 0.2);
      border-color: var(--color-accent-primary);
      transform: scale(1.1);
    }

    /* Loading States */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-lg);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .loading-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(118, 150, 86, 0.2);
      border-top: 3px solid var(--color-accent-primary);
      border-radius: var(--radius-full);
      animation: spin 1s linear infinite;
    }

    /* Mobile-First Responsive Design */
    
    /* Base mobile styles (up to 640px) */
    .game-header {
      height: var(--header-height-mobile);
      padding: 0 var(--space-md);
      flex-wrap: wrap;
      gap: var(--space-sm);
    }

    .game-title h1 {
      font-size: var(--font-size-lg);
    }

    .game-controls {
      gap: var(--space-sm);
    }

    .game-controls .btn {
      padding: var(--space-sm) var(--space-md);
      font-size: var(--font-size-xs);
      min-height: var(--touch-target-min);
      min-width: var(--touch-target-min);
    }

    /* Base styles for all screen sizes */
    .game-content {
      display: grid !important;
      grid-template-columns: 1fr auto 320px !important;
      gap: var(--space-xl);
      padding: var(--space-xl);
      max-width: 1400px;
      margin: 0 auto;
    }

    .chess-board {
      width: min(70vh, 500px);
      height: min(70vh, 500px);
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      border: 2px solid var(--glass-border);
      position: relative;
    }

    .chess-square {
      border-radius: 2px;
    }

    .chess-piece {
      font-size: 2.5rem;
      user-select: none;
      pointer-events: none;
      transition: transform var(--transition-fast);
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .players-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      margin-bottom: var(--space-lg);
    }

    .player-card.black {
      order: -1;
    }

    .player-card {
      padding: var(--space-md);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .player-avatar {
      width: 36px;
      height: 36px;
      font-size: var(--font-size-sm);
      flex-shrink: 0;
    }

    .player-info {
      flex: 1;
      min-width: 0;
    }

    .player-name {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-rating {
      font-size: var(--font-size-xs);
      opacity: 0.8;
    }

    .player-timer {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      font-family: 'Courier New', monospace;
      min-width: 80px;
      text-align: right;
    }

    .player-timer.warning {
      color: var(--color-warning);
      animation: pulse 1s infinite;
    }

    .player-timer.critical {
      color: var(--color-error);
      animation: pulse 0.5s infinite;
    }

    .game-sidebar {
      min-width: 320px;
      width: 320px;
    }

    .panel-content {
      padding: var(--space-md);
      max-height: 300px;
      overflow-y: auto;
    }

    .move-list {
      font-family: 'Courier New', monospace;
      font-size: var(--font-size-sm);
      line-height: 1.4;
    }

    .chat-messages {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: var(--space-md);
    }

    .chat-input {
      display: flex;
      gap: var(--space-sm);
    }

    .chat-input input {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      font-size: var(--font-size-sm);
    }

    .chat-input button {
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-sm);
      min-height: var(--touch-target-min);
      min-width: var(--touch-target-min);
    }

    /* Small tablet styles (641px to 768px) */
    @media (min-width: 641px) {
      .game-header {
        height: var(--header-height);
        padding: 0 var(--space-lg);
      }

      .game-title h1 {
        font-size: var(--font-size-xl);
      }

      .game-content {
        padding: var(--space-lg);
        gap: var(--space-lg);
      }

      .chess-board {
        width: min(70vw, 70vh, 500px);
        height: min(70vw, 70vh, 500px);
      }

      .chess-piece {
        font-size: 2rem;
      }

      .players-section {
        flex-direction: row;
        justify-content: space-between;
      }

      .player-card {
        flex: 1;
        max-width: 300px;
      }

      .player-avatar {
        width: 44px;
        height: 44px;
        font-size: var(--font-size-base);
      }

      .player-name {
        font-size: var(--font-size-base);
      }

      .player-timer {
        font-size: var(--font-size-xl);
      }

      .panel-content {
        max-height: 400px;
      }
    }

    /* Large tablet styles (769px to 1024px) */
    @media (min-width: 769px) {
      .chess-board {
        width: min(75vw, 75vh);
        height: min(75vw, 75vh);
      }

      .chess-piece {
        font-size: 2.2rem;
      }

      .panel-content {
        max-height: 500px;
      }

      .chat-messages {
        max-height: 250px;
      }
    }

    /* Desktop styles (1025px to 1280px) */
    @media (min-width: 1025px) {
      .game-content {
        grid-template-columns: 1fr auto 320px !important;
        gap: var(--space-xl);
        padding: var(--space-xl);
      }

      .players-section {
        order: 0;
        flex-direction: column;
        gap: var(--space-md);
        margin-bottom: 0;
      }

      .player-card.black {
        order: -1;
      }

      .chess-board {
        width: min(65vw, 65vh);
        height: min(65vw, 65vh);
      }

      .chess-piece {
        font-size: 2.5rem;
      }

      .game-sidebar {
        min-width: 300px;
        width: 300px;
      }

      .panel-content {
        max-height: 600px;
      }

      .chat-messages {
        max-height: 300px;
      }
    }

    /* Large desktop styles (1281px and up) */
    @media (min-width: 1281px) {
      .game-content {
        grid-template-columns: 1fr auto 350px !important;
        gap: var(--space-2xl);
        padding: var(--space-2xl);
        max-width: 1400px;
        margin: 0 auto;
      }

      .game-sidebar {
        min-width: 350px;
        width: 350px;
      }

      .chess-board {
        width: min(60vw, 60vh);
        height: min(60vw, 60vh);
      }

      .chess-piece {
        font-size: 3rem;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .chess-square {
        position: relative;
      }

      .chess-square::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: transparent;
        z-index: 1;
      }

      .chess-piece {
        position: relative;
        z-index: 2;
        touch-action: none;
        font-size: 2rem;
      }

      .game-controls .btn {
        min-height: var(--touch-target-min);
        min-width: var(--touch-target-min);
        padding: var(--space-md);
      }

      .chat-input input,
      .chat-input button {
        min-height: var(--touch-target-min);
      }

      /* Enhanced highlighting for touch */
      .chess-square.selected {
        box-shadow: inset 0 0 0 3px var(--color-primary);
      }

      .chess-square.valid-move {
        box-shadow: inset 0 0 0 2px var(--color-success);
      }

      .chess-square.last-move {
        box-shadow: inset 0 0 0 2px var(--color-accent);
      }

      /* Prevent text selection during drag */
      .chess-board {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
    }

    /* Landscape orientation adjustments for mobile */
    /* Mobile layout */
    @media (max-width: 768px) {
      .game-content {
        grid-template-columns: 1fr !important;
        gap: 1rem;
      }
      
      .game-sidebar {
        order: 2;
        min-width: auto;
        width: 100%;
      }
      
      .chess-board {
        width: 90vw;
        height: 90vw;
        max-width: 400px;
        max-height: 400px;
      }
      
      .chess-piece {
        font-size: 1.5rem;
      }
      
      .players-section {
        flex-direction: column;
        text-align: center;
      }
    }

    @media (max-width: 768px) and (orientation: landscape) {
      .game-content {
        grid-template-columns: 1fr 250px;
        gap: var(--space-md);
      }

      .chess-board {
        width: min(60vh, 60vw);
        height: min(60vh, 60vw);
      }

      .players-section {
        flex-direction: row;
        justify-content: space-between;
      }

      .game-sidebar {
        width: 250px;
        min-width: 250px;
      }

      .panel-content {
        max-height: 200px;
      }

      .chat-messages {
        max-height: 120px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="game-container fade-in">
      <!-- Game Header -->
      <header class="game-header">
        <div class="game-title">
          <span class="game-id" id="gameId">Game #---</span>
          <div class="game-status-badge" id="gameStatus">Loading...</div>
        </div>
        
        <div class="current-user-info" id="currentUserInfo" style="display: none;">
          <span>Playing as: </span>
          <strong id="currentUserName">---</strong>
          <span>(</span><span id="currentUserRating">----</span><span>)</span>
        </div>
        
        <div class="game-actions">
          <a href="#" class="back-btn" data-route="/lobby">
            <span>←</span>
            <span>Back to Lobby</span>
          </a>
        </div>
      </header>

      <!-- Game Content -->
      <div class="game-content">
        <!-- Player Info -->
        <div class="players-section">
          <div class="player-card white" id="whitePlayer">
            <div class="player-avatar">
              <span id="whiteAvatar">?</span>
            </div>
            <div class="player-info">
              <div class="player-name" id="whiteName">Loading...</div>
              <div class="player-rating">
                Rating: <span class="rating-badge" id="whiteRating">----</span>
              </div>
            </div>
            <div class="player-timer" id="whiteTimer">∞</div>
          </div>

          <div class="player-card black" id="blackPlayer">
            <div class="player-avatar black">
              <span id="blackAvatar">?</span>
            </div>
            <div class="player-info">
              <div class="player-name" id="blackName">Waiting...</div>
              <div class="player-rating">
                Rating: <span class="rating-badge" id="blackRating">----</span>
              </div>
            </div>
            <div class="player-timer" id="blackTimer">∞</div>
          </div>
        </div>

        <!-- Chess Board -->
        <div class="board-container">
          <div class="chess-board" id="chessBoard">
            <!-- Board squares will be generated here -->
            <div class="loading-overlay" id="boardLoading">
              <div class="loading-spinner"></div>
            </div>
          </div>
        </div>

        <!-- Game Sidebar -->
        <div class="game-sidebar">
          <!-- Game Controls -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>⚙️</span>
                Game Controls
              </h3>
            </div>
            <div class="panel-content">
              <div class="game-controls">
                <div class="control-group">
                  <button class="control-btn" id="offerDrawBtn">
                    🤝 Offer Draw
                  </button>
                  <button class="control-btn danger" id="resignBtn">
                    🏳️ Resign
                  </button>
                </div>
                <div class="control-group">
                  <button class="control-btn" id="flipBoardBtn">
                    🔄 Flip Board
                  </button>
                  <button class="control-btn" id="analysisBtn">
                    📊 Analysis
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Move History -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>📜</span>
                Move History
              </h3>
            </div>
            <div class="panel-content">
              <div class="move-history" id="moveHistory">
                <div class="move-list" id="moveList">
                  <!-- Moves will be populated here -->
                  <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
                    No moves yet. Game starting...
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Game Status -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>📋</span>
                Game Info
              </h3>
            </div>
            <div class="panel-content">
              <div class="game-status">
                <div class="status-message" id="statusMessage">Game in progress</div>
                <div class="status-details" id="statusDetails">White to move</div>
              </div>
            </div>
          </div>

          <!-- Captured Pieces -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>🏴‍☠️</span>
                Captured Pieces
              </h3>
            </div>
            <div class="panel-content">
              <div class="captured-pieces" id="capturedPieces">
                <!-- Captured pieces will be shown here -->
                <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
                  No captures yet
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Promotion Dialog -->
      <div class="promotion-dialog" id="promotionDialog">
        <div class="promotion-content">
          <h3 class="promotion-title">Choose promotion piece:</h3>
          <div class="promotion-pieces">
            <div class="promotion-piece" data-piece="q">♕</div>
            <div class="promotion-piece" data-piece="r">♖</div>
            <div class="promotion-piece" data-piece="b">♗</div>
            <div class="promotion-piece" data-piece="n">♘</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="../../utils/api.js"></script>
  <script src="../../utils/router.js"></script>
  
  <script>
    // Set up router routes for game page
    function setupRoutes() {
      console.log('Setting up routes for game page...');
      
      // Add route for lobby
      router.addRoute('/lobby', {
        title: 'Lobby - Chess Platform',
        controller: () => {
          window.location.href = '/lobby/';
        },
        requiresAuth: true
      });
      
      // Add route for profile
      router.addRoute('/profile', {
        title: 'Profile - Chess Platform',
        controller: () => {
          window.location.href = '/profile/';
        },
        requiresAuth: true
      });
      
      // Add route for puzzles
      router.addRoute('/puzzles', {
        title: 'Puzzles - Chess Platform',
        controller: () => {
          window.location.href = '/puzzles/';
        },
        requiresAuth: true
      });
      
      console.log('Routes configured for game page');
    }
    
    // Set up navigation click handlers
    function setupNavigation() {
      console.log('Setting up navigation for game page...');
      
      document.querySelectorAll('a[data-route]').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          console.log('Navigating to:', route);
          
          // Use direct navigation for reliability
          window.location.href = route + '/';
        });
      });
    }
    
    // Game page controller
    function initGamePage() {
      // Set up router routes
      setupRoutes();
      
      // Set up navigation click handlers
      setupNavigation();
      
      let gameData = null;
      let selectedSquare = null;
      let possibleMoves = [];
      let gameId = null;
      let currentUser = null;
      let moveHistory = [];
      let api;
      
      // Timer management
      let timerInterval = null;
      let gameTimerData = null;
      let lastTimerUpdate = null;
      
      // Timer Functions
      function formatTime(seconds) {
        if (seconds === null || seconds === undefined) return '∞';
        if (seconds < 0) return '0:00';
        
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }
      
      function updateTimerDisplay() {
        if (!gameTimerData) return;
        
        const whiteTimer = document.getElementById('whiteTimer');
        const blackTimer = document.getElementById('blackTimer');
        
        if (!whiteTimer || !blackTimer) return;
        
        // Calculate current time for display
        let whiteTime = gameTimerData.white_time;
        let blackTime = gameTimerData.black_time;
        
        // If game is active and we have a last update timestamp, calculate elapsed time
        if (gameTimerData.game_status === 'active' && lastTimerUpdate) {
          const elapsed = Math.floor((Date.now() - lastTimerUpdate) / 1000);
          
          if (gameTimerData.current_turn === 'white') {
            whiteTime = Math.max(0, whiteTime - elapsed);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
          }
        }
        
        // Update display
        whiteTimer.textContent = formatTime(whiteTime);
        blackTimer.textContent = formatTime(blackTime);
        
        // Add warning classes for low time
        whiteTimer.classList.toggle('low-time', whiteTime <= 30);
        blackTimer.classList.toggle('low-time', blackTime <= 30);
        
        // Update turn indicators
        const whiteCard = whiteTimer.closest('.player-card');
        const blackCard = blackTimer.closest('.player-card');
        
        if (whiteCard && blackCard) {
          whiteCard.classList.toggle('current-turn', gameTimerData.current_turn === 'white');
          blackCard.classList.toggle('current-turn', gameTimerData.current_turn === 'black');
        }
        
        // Check for timeout
        if (whiteTime <= 0 || blackTime <= 0) {
          handleTimeout(whiteTime <= 0 ? 'white' : 'black');
        }
      }
      
      function handleTimeout(timeoutPlayer) {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        
        api.showError(`${timeoutPlayer === 'white' ? 'White' : 'Black'} player ran out of time!`);
        
        // Refresh game data to get the final state
        setTimeout(() => {
          loadGameData();
        }, 1000);
      }
      
      async function fetchTimerData() {
        try {
          const response = await api.getGameTimer(gameId);
          if (response.ok) {
            gameTimerData = response.data;
            lastTimerUpdate = Date.now();
            updateTimerDisplay();
          }
        } catch (error) {
          console.error('Failed to fetch timer data:', error);
        }
      }
      
      function startTimerUpdates() {
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        // Update timer display every second
        timerInterval = setInterval(() => {
          updateTimerDisplay();
        }, 1000);
        
        // Fetch fresh timer data every 10 seconds
        setInterval(() => {
          fetchTimerData();
        }, 10000);
      }
      
      function stopTimerUpdates() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }
      
      // Initialize game
      initializeGame();
      
      async function initializeGame() {
        try {
          // Initialize API
          api = new ChessAPI();
          window.api = api;
          
          // Check authentication - for demo purposes, auto-login testuser
          await ensureAuthentication();
          
          // Get game ID from URL
          gameId = getGameIdFromUrl();
          if (!gameId) {
            api.showError('Invalid game URL');
            navigateToRoute('/lobby');
            return;
          }
          
          // Load current user
          await loadCurrentUser();
          
          // Load game data
          await loadGameData();
          
          // Set up event listeners
          setupEventListeners();
          
          // Start periodic updates
          setupPeriodicUpdates();
          
        } catch (error) {
          console.error('Failed to initialize game:', error);
          api.showError('Failed to load game');
        }
      }
      
      function getGameIdFromUrl() {
        // Check URL parameters first (e.g., ?game=123)
        const urlParams = new URLSearchParams(window.location.search);
        const gameIdParam = urlParams.get('game');
        if (gameIdParam) {
          return parseInt(gameIdParam);
        }
        
        // Fallback to path-based extraction
        const path = window.location.pathname;
        const matches = path.match(/\/game\/(\d+)/);
        return matches ? parseInt(matches[1]) : null;
      }
      
      async function loadCurrentUser() {
        try {
          const response = await api.getUserProfile();
          if (response.ok) {
            currentUser = response.data;
            updateCurrentUserDisplay();
          }
        } catch (error) {
          console.error('Failed to load current user:', error);
        }
      }
      
      function updateCurrentUserDisplay() {
        if (currentUser) {
          document.getElementById('currentUserName').textContent = currentUser.username;
          document.getElementById('currentUserRating').textContent = currentUser.rating || 1200;
          document.getElementById('currentUserInfo').style.display = 'block';
        }
      }
      
      async function ensureAuthentication() {
        console.log('🔐 Checking authentication status...');
        
        // Check if already authenticated
        if (api.isAuthenticated()) {
          console.log('✅ User is already authenticated');
          return true;
        }
        
        console.log('❌ User not authenticated');
        
        // Professional implementation: redirect to login
        console.log('🔄 Redirecting to login page...');
        api.showError('Please log in to view games');
        
        // Redirect to login with return URL
        const returnUrl = encodeURIComponent(window.location.pathname + window.location.search);
        window.location.href = `/login/?next=${returnUrl}`;
        
        return false;
      }
      
      // Professional navigation helper function with proper Django URL support
      function navigateToRoute(path) {
        console.log('🧭 Navigating to route:', path);
        
        // Use Django URLs for proper backend integration
        const djangoUrlMap = {
          '/lobby': '/lobby/',           // Django serves lobby.html
          '/login': '/login/',           // Django serves login.html  
          '/register': '/register/',     // Django serves register.html
          '/profile': '/profile/',       // Django serves profile page
          '/': '/'                       // Django serves home/login
        };
        
        // Check if we have a Django URL mapping
        if (djangoUrlMap[path]) {
          console.log('✅ Using Django URL:', djangoUrlMap[path]);
          window.location.href = djangoUrlMap[path];
          return;
        }
        
        // Fallback to router if available
        if (window.router) {
          console.log('🔄 Using router navigation');
          window.router.navigate(path);
        } else {
          // Last resort: relative path mapping (deprecated)
          console.warn('⚠️ Using deprecated relative path mapping for:', path);
          const pathMap = {
            '/lobby': '../dashboard/lobby.html',
            '/login': '../auth/login.html',
            '/profile': '../profile/index.html'
          };
          
          if (pathMap[path]) {
            window.location.href = pathMap[path];
          } else {
            console.error('❌ No route mapping found for:', path);
            // Default to lobby as safe fallback
            window.location.href = '/lobby/';
          }
        }
      }
      
      async function loadGameData() {
        try {
          showBoardLoading(true);
          const response = await api.getGameDetail(gameId);
          
          if (response.ok) {
            gameData = response.data;
            console.log('Game data loaded:', gameData);
            
            // Ensure we have a valid FEN
            if (!gameData.fen || gameData.fen === 'startpos') {
              gameData.fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
            }
            
            console.log('Using FEN:', gameData.fen);
            
            updateGameDisplay();
            renderBoard();
            
            // Load timer data (non-blocking)
            fetchTimerData().catch(err => {
              console.warn('Timer data not available:', err);
            });
            
            // Start timer updates if game is active
            if (gameData.status === 'active') {
              startTimerUpdates();
            } else {
              stopTimerUpdates();
            }
          } else {
            throw new Error(api.formatError(response));
          }
        } catch (error) {
          console.error('Failed to load game data:', error);
          api.showError('Failed to load game data');
        } finally {
          showBoardLoading(false);
        }
      }
      
      function updateGameDisplay() {
        if (!gameData) return;
        
        // Update game header
        document.getElementById('gameId').textContent = `Game #${gameData.id}`;
        const statusEl = document.getElementById('gameStatus');
        statusEl.textContent = getStatusText(gameData.status);
        statusEl.className = `game-status-badge status-${gameData.status}`;
        
        // Update player info
        updatePlayerInfo('white', gameData.white_player_username, gameData.white_player_rating);
        updatePlayerInfo('black', gameData.black_player_username, gameData.black_player_rating);
        
        // Update turn indicator
        updateTurnIndicator();
        
        // Update move history
        updateMoveHistory();
        
        // Update game status
        updateGameStatus();
      }
      
      function updatePlayerInfo(color, username, rating) {
        const nameEl = document.getElementById(`${color}Name`);
        const avatarEl = document.getElementById(`${color}Avatar`);
        const ratingEl = document.getElementById(`${color}Rating`);
        
        if (username) {
          nameEl.textContent = username;
          avatarEl.textContent = username.charAt(0).toUpperCase();
          ratingEl.textContent = rating || 1200;
        } else {
          nameEl.textContent = color === 'white' ? 'White Player' : 'Waiting...';
          avatarEl.textContent = '?';
          ratingEl.textContent = '----';
        }
      }
      
      function updateTurnIndicator() {
        const whiteCard = document.getElementById('whitePlayer');
        const blackCard = document.getElementById('blackPlayer');
        
        // Remove current turn indicators
        whiteCard.classList.remove('current-turn');
        blackCard.classList.remove('current-turn');
        whiteCard.querySelector('.turn-indicator')?.remove();
        blackCard.querySelector('.turn-indicator')?.remove();
        
        if (gameData.status === 'active') {
          const currentTurn = getCurrentTurn();
          const currentPlayerCard = document.getElementById(`${currentTurn}Player`);
          currentPlayerCard.classList.add('current-turn');
          
          // Add turn indicator dot
          const indicator = document.createElement('div');
          indicator.className = 'turn-indicator';
          currentPlayerCard.querySelector('.player-avatar').appendChild(indicator);
        }
      }
      
      function getCurrentTurn() {
        // Parse FEN to get current turn
        const fenParts = gameData.fen.split(' ');
        return fenParts[1] === 'w' ? 'white' : 'black';
      }
      
      function updateMoveHistory() {
        const moveListEl = document.getElementById('moveList');
        const moves = gameData.moves || [];
        
        if (moves.length === 0) {
          moveListEl.innerHTML = `
            <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
              No moves yet. Game starting...
            </div>
          `;
          return;
        }
        
        let html = '';
        for (let i = 0; i < moves.length; i += 2) {
          const moveNumber = Math.floor(i / 2) + 1;
          const whiteMove = moves[i];
          const blackMove = moves[i + 1];
          
          html += `
            <div class="move-pair">
              <span class="move-number">${moveNumber}.</span>
              <span class="move-white" data-move-index="${i}">${whiteMove.notation}</span>
              <span class="move-black" data-move-index="${i + 1}">
                ${blackMove ? blackMove.notation : ''}
              </span>
            </div>
          `;
        }
        
        moveListEl.innerHTML = html;
        
        // Scroll to bottom
        const historyEl = document.getElementById('moveHistory');
        historyEl.scrollTop = historyEl.scrollHeight;
      }
      
      function updateGameStatus() {
        const statusMessageEl = document.getElementById('statusMessage');
        const statusDetailsEl = document.getElementById('statusDetails');
        
        if (gameData.status === 'waiting') {
          statusMessageEl.textContent = 'Waiting for opponent';
          statusDetailsEl.textContent = 'Game will start when black player joins';
        } else if (gameData.status === 'active') {
          const currentTurn = getCurrentTurn();
          statusMessageEl.textContent = 'Game in progress';
          statusDetailsEl.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)} to move`;
        } else if (gameData.status === 'finished') {
          if (gameData.winner) {
            const winnerColor = gameData.winner === gameData.white_player ? 'White' : 'Black';
            statusMessageEl.textContent = `${winnerColor} wins!`;
            statusDetailsEl.textContent = 'Game completed';
          } else {
            statusMessageEl.textContent = 'Game drawn';
            statusDetailsEl.textContent = 'Game ended in a draw';
          }
        }
      }
      
      function renderBoard() {
        const boardEl = document.getElementById('chessBoard');
        if (!boardEl) {
          console.error('Chess board element not found!');
          return;
        }
        
        console.log('Rendering board with FEN:', gameData?.fen);
        boardEl.innerHTML = '';
        
        // Create squares
        for (let rank = 8; rank >= 1; rank--) {
          for (let file = 1; file <= 8; file++) {
            const square = document.createElement('div');
            const fileChar = String.fromCharCode(96 + file); // a-h
            const squareName = fileChar + rank;
            
            square.className = `chess-square ${(rank + file) % 2 === 0 ? 'dark' : 'light'}`;
            square.dataset.square = squareName;
            
            // Add coordinate labels
            if (rank === 1) {
              const fileLabel = document.createElement('div');
              fileLabel.className = 'coord-label coord-file';
              fileLabel.textContent = fileChar;
              square.appendChild(fileLabel);
            }
            
            if (file === 1) {
              const rankLabel = document.createElement('div');
              rankLabel.className = 'coord-label coord-rank';
              rankLabel.textContent = rank;
              square.appendChild(rankLabel);
            }
            
            // Add piece if present
            const piece = getPieceAtSquare(squareName);
            if (piece) {
              console.log(`Placing piece ${piece} at ${squareName}`);
              const pieceEl = document.createElement('div');
              const isWhitePiece = piece === piece.toUpperCase();
              pieceEl.className = `chess-piece ${isWhitePiece ? 'white-piece' : 'black-piece'}`;
              pieceEl.textContent = getPieceUnicode(piece);
              pieceEl.dataset.piece = piece;
              square.appendChild(pieceEl);
            }
            
            boardEl.appendChild(square);
          }
        }
        
        console.log('Board rendered, total squares:', boardEl.children.length);
        setupBoardEventListeners();
      }
      
      function getPieceAtSquare(squareName) {
        // Parse FEN to get piece at specific square
        if (!gameData || !gameData.fen) {
          console.warn('No game data or FEN available');
          return null;
        }
        
        const fenParts = gameData.fen.split(' ');
        const placement = fenParts[0];
        const ranks = placement.split('/');
        
        const file = squareName.charCodeAt(0) - 97; // a=0, b=1, etc.
        const rank = parseInt(squareName[1]) - 1; // 1-8 to 0-7
        const rankString = ranks[7 - rank]; // FEN ranks are from 8 to 1
        
        let currentFile = 0;
        for (const char of rankString) {
          if (/\d/.test(char)) {
            currentFile += parseInt(char);
          } else {
            if (currentFile === file) {
              return char;
            }
            currentFile++;
          }
        }
        
        return null;
      }
      
      function getPieceUnicode(piece) {
        const pieces = {
          'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
          'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
        return pieces[piece] || '';
      }

      function getPieceImageName(piece) {
        // Convert piece notation to image filename
        const color = piece === piece.toUpperCase() ? 'w' : 'b';
        const pieceType = piece.toLowerCase();
        
        const pieceMap = {
          'k': 'K', 'q': 'Q', 'r': 'R', 'b': 'B', 'n': 'N', 'p': 'P'
        };
        
        return `${color}${pieceMap[pieceType]}.png`;
      }
      
      function setupBoardEventListeners() {
        const squares = document.querySelectorAll('.chess-square');
        console.log('🎯 Setting up board event listeners for', squares.length, 'squares');
        
        squares.forEach(square => {
          square.addEventListener('click', handleSquareClick);
        });
        
        console.log('✅ Board event listeners set up');
      }
      
      async function handleSquareClick(event) {
        console.log('🎯 Square clicked!', event.currentTarget.dataset.square);
        const square = event.currentTarget;
        const squareName = square.dataset.square;
        
        console.log('🎮 Current game state:', {
          gameData: gameData?.status,
          currentUser: currentUser?.id,
          whitePlayer: gameData?.white_player,
          blackPlayer: gameData?.black_player
        });
        
        // Check if it's the player's turn
        if (!isPlayerTurn()) {
          console.log('❌ Not player turn');
          api.showToast("It's not your turn!", 'info');
          return;
        }
        
        console.log('✅ Player turn confirmed');
        
        if (!selectedSquare) {
          // First click - select piece
          const piece = getPieceAtSquare(squareName);
          console.log('🎯 First click - piece at square:', piece);
          if (piece && isOwnPiece(piece)) {
            console.log('✅ Valid piece selected');
            selectSquare(squareName);
            highlightPossibleMoves(squareName);
          } else {
            console.log('❌ Invalid piece or not own piece');
          }
        } else {
          // Second click - make move or select different piece
          console.log('🎯 Second click - selected square:', selectedSquare, 'target:', squareName);
          if (squareName === selectedSquare) {
            // Deselect
            console.log('🔄 Deselecting piece');
            clearSelection();
          } else if (isPossibleMove(squareName)) {
            // Make move
            console.log('✅ Making move from', selectedSquare, 'to', squareName);
            await makeMove(selectedSquare, squareName);
          } else {
            // Select different piece
            const piece = getPieceAtSquare(squareName);
            console.log('🎯 Attempting to select different piece:', piece);
            if (piece && isOwnPiece(piece)) {
              console.log('✅ Selecting different piece');
              clearSelection();
              selectSquare(squareName);
              highlightPossibleMoves(squareName);
            } else {
              console.log('🔄 Clearing selection');
              clearSelection();
            }
          }
        }
      }
      
      function isPlayerTurn() {
        if (!gameData || gameData.status !== 'active') {
          console.log('❌ Game not active or no game data:', gameData?.status);
          return false;
        }
        
        const currentTurn = getCurrentTurn();
        const isWhitePlayer = currentUser && currentUser.id === gameData.white_player;
        const isBlackPlayer = currentUser && currentUser.id === gameData.black_player;
        
        console.log('🔍 Turn check:', {
          currentTurn,
          currentUserId: currentUser?.id,
          whitePlayerId: gameData.white_player,
          blackPlayerId: gameData.black_player,
          isWhitePlayer,
          isBlackPlayer,
          result: (currentTurn === 'white' && isWhitePlayer) || (currentTurn === 'black' && isBlackPlayer)
        });
        
        return (currentTurn === 'white' && isWhitePlayer) || 
               (currentTurn === 'black' && isBlackPlayer);
      }
      
      function isOwnPiece(piece) {
        if (!currentUser) {
          console.log('❌ No current user');
          return false;
        }
        
        const isWhitePlayer = currentUser.id === gameData.white_player;
        const isWhitePiece = piece === piece.toUpperCase();
        
        console.log('🔍 Piece ownership check:', {
          piece,
          currentUserId: currentUser.id,
          whitePlayerId: gameData.white_player,
          isWhitePlayer,
          isWhitePiece,
          result: (isWhitePlayer && isWhitePiece) || (!isWhitePlayer && !isWhitePiece)
        });
        
        return (isWhitePlayer && isWhitePiece) || (!isWhitePlayer && !isWhitePiece);
      }
      
      function selectSquare(squareName) {
        selectedSquare = squareName;
        const square = document.querySelector(`[data-square="${squareName}"]`);
        square.classList.add('selected');
      }
      
      function clearSelection() {
        if (selectedSquare) {
          const square = document.querySelector(`[data-square="${selectedSquare}"]`);
          square?.classList.remove('selected');
          selectedSquare = null;
        }
        
        // Clear all move highlights
        document.querySelectorAll('.possible-move, .possible-capture').forEach(square => {
          square.classList.remove('possible-move', 'possible-capture');
        });
        possibleMoves = [];
      }
      
      async function highlightPossibleMoves(squareName) {
        try {
          // Get legal moves from backend
          const response = await api.getLegalMoves(gameId, squareName);
          if (response.ok) {
            possibleMoves = response.data.moves.map(move => ({
              to: move.to,
              capture: move.capture || false
            }));
            
            possibleMoves.forEach(move => {
              const square = document.querySelector(`[data-square="${move.to}"]`);
              if (square) {
                square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
              }
            });
          } else {
            // Fallback to basic move highlighting
            possibleMoves = calculateBasicMoves(squareName);
            possibleMoves.forEach(move => {
              const square = document.querySelector(`[data-square="${move.to}"]`);
              if (square) {
                square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
              }
            });
          }
        } catch (error) {
          console.warn('Failed to get legal moves from backend, using fallback');
          possibleMoves = calculateBasicMoves(squareName);
          possibleMoves.forEach(move => {
            const square = document.querySelector(`[data-square="${move.to}"]`);
            if (square) {
              square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
            }
          });
        }
      }
      
      function calculateBasicMoves(squareName) {
        // Simplified move calculation - fallback only
        const moves = [];
        const piece = getPieceAtSquare(squareName);
        
        if (!piece) return moves;
        
        const file = squareName.charCodeAt(0) - 97;
        const rank = parseInt(squareName[1]) - 1;
        
        // Basic pawn moves only
        if (piece.toLowerCase() === 'p') {
          const direction = piece === 'P' ? 1 : -1;
          const newRank = rank + direction;
          
          if (newRank >= 0 && newRank < 8) {
            const newSquare = String.fromCharCode(97 + file) + (newRank + 1);
            if (!getPieceAtSquare(newSquare)) {
              moves.push({ to: newSquare, capture: false });
              
              // Double pawn move from starting position
              const startingRank = piece === 'P' ? 1 : 6;
              if (rank === startingRank) {
                const doubleRank = rank + (direction * 2);
                if (doubleRank >= 0 && doubleRank < 8) {
                  const doubleSquare = String.fromCharCode(97 + file) + (doubleRank + 1);
                  if (!getPieceAtSquare(doubleSquare)) {
                    moves.push({ to: doubleSquare, capture: false });
                  }
                }
              }
            }
          }
        }
        
        return moves;
      }
      
      function isPossibleMove(squareName) {
        return possibleMoves.some(move => move.to === squareName);
      }
      
      async function makeMove(from, to) {
        try {
          clearSelection();
          showBoardLoading(true);
          
          // Check if move requires promotion
          const piece = getPieceAtSquare(from);
          const isPromotion = piece && piece.toLowerCase() === 'p' && 
                             (to[1] === '8' || to[1] === '1');
          
          let promotion = null;
          if (isPromotion) {
            promotion = await showPromotionDialog();
            if (!promotion) {
              showBoardLoading(false);
              return;
            }
          }
          
          const response = await api.makeMove(gameId, from, to, promotion);
          
          if (response.ok) {
            gameData = response.data.game;
            
            // Update timer data if provided in response
            if (response.data.timer) {
              gameTimerData = response.data.timer;
              lastTimerUpdate = Date.now();
            }
            
            updateGameDisplay();
            renderBoard();
            updateTimerDisplay();
            
            // Restart timer updates if game is still active
            if (gameData.status === 'active') {
              startTimerUpdates();
            } else {
              stopTimerUpdates();
            }
            
            api.showSuccess('Move made successfully!');
            
            // Check if it's a computer game and it's the computer's turn
            await handleComputerTurn();
          } else {
            api.showError(api.formatError(response));
          }
        } catch (error) {
          console.error('Move error:', error);
          api.showError('Failed to make move');
        } finally {
          showBoardLoading(false);
        }
      }
      
      // Computer Chess Functions
      async function handleComputerTurn() {
        try {
          if (!isComputerGame() || !isComputerTurn()) {
            return;
          }
          
          // Small delay for better UX
          setTimeout(async () => {
            await makeComputerMove();
          }, 1000);
          
        } catch (error) {
          console.error('Error handling computer turn:', error);
        }
      }
      
      function isComputerGame() {
        if (!gameData) return false;
        
        // Check if either player is a computer
        const isWhiteComputer = gameData.white_player && 
          (gameData.white_player.username === 'computer_white' || 
           gameData.white_player.first_name === 'Computer');
        const isBlackComputer = gameData.black_player && 
          (gameData.black_player.username === 'computer_black' || 
           gameData.black_player.first_name === 'Computer');
        
        return isWhiteComputer || isBlackComputer;
      }
      
      function isComputerTurn() {
        if (!gameData || !currentUser) return false;
        
        const currentTurn = getCurrentTurn();
        
        if (currentTurn === 'white') {
          return gameData.white_player && 
            gameData.white_player.username !== currentUser.username &&
            (gameData.white_player.username === 'computer_white' || 
             gameData.white_player.first_name === 'Computer');
        } else {
          return gameData.black_player && 
            gameData.black_player.username !== currentUser.username &&
            (gameData.black_player.username === 'computer_black' || 
             gameData.black_player.first_name === 'Computer');
        }
      }
      
      async function makeComputerMove() {
        try {
          showBoardLoading(true);
          
          // Get difficulty from URL params or use default
          const urlParams = new URLSearchParams(window.location.search);
          const difficulty = urlParams.get('difficulty') || 'medium';
          
          console.log(`Making computer move with difficulty: ${difficulty}`);
          
          const response = await api.makeComputerMove(gameId, difficulty);
          
          if (response.ok) {
            gameData = response.data.game;
            
            // Update timer data if provided
            if (response.data.timer) {
              gameTimerData = response.data.timer;
              lastTimerUpdate = Date.now();
            }
            
            updateGameDisplay();
            renderBoard();
            updateTimerDisplay();
            
            // Show computer move info
            const moveInfo = response.data.computer_move;
            const engineInfo = response.data.engine_info;
            
            console.log('Computer move:', moveInfo);
            console.log('Engine info:', engineInfo);
            
            api.showSuccess(
              `Computer moved: ${moveInfo.from_square} → ${moveInfo.to_square} (${moveInfo.notation})`,
              3000
            );
            
            // Continue timer updates if game is still active
            if (gameData.status === 'active') {
              startTimerUpdates();
            } else {
              stopTimerUpdates();
              
              // Show game over message
              if (response.data.game_status && response.data.game_status.is_game_over) {
                if (response.data.game_status.is_checkmate) {
                  const winner = getCurrentTurn() === 'white' ? 'Black' : 'White';
                  api.showSuccess(`Checkmate! ${winner} wins!`, 5000);
                } else if (response.data.game_status.is_stalemate) {
                  api.showSuccess('Stalemate! The game is a draw.', 5000);
                }
              }
            }
            
          } else {
            api.showError(`Computer move failed: ${api.formatError(response)}`);
          }
          
        } catch (error) {
          console.error('Error making computer move:', error);
          api.showError('Failed to make computer move');
        } finally {
          showBoardLoading(false);
        }
      }
      
      function getCurrentTurn() {
        if (!gameTimerData) return 'white';
        return gameTimerData.current_turn;
      }
      
      function showPromotionDialog() {
        return new Promise((resolve) => {
          const dialog = document.getElementById('promotionDialog');
          dialog.classList.add('show');
          
          const pieces = dialog.querySelectorAll('.promotion-piece');
          pieces.forEach(piece => {
            piece.onclick = () => {
              dialog.classList.remove('show');
              resolve(piece.dataset.piece);
            };
          });
        });
      }
      
      function setupEventListeners() {
        // Back button navigation
        document.querySelector('.back-btn').addEventListener('click', (e) => {
          e.preventDefault();
          const route = e.currentTarget.dataset.route;
          navigateToRoute(route);
        });
        
        // Game controls
        document.getElementById('offerDrawBtn').addEventListener('click', () => {
          api.showToast('Draw offer feature coming soon!', 'info');
        });
        
        document.getElementById('resignBtn').addEventListener('click', () => {
          if (confirm('Are you sure you want to resign?')) {
            api.showToast('Resignation feature coming soon!', 'info');
          }
        });
        
        document.getElementById('flipBoardBtn').addEventListener('click', () => {
          api.showToast('Board flip feature coming soon!', 'info');
        });
        
        document.getElementById('analysisBtn').addEventListener('click', () => {
          api.showToast('Analysis feature coming soon!', 'info');
        });
        
        // Move history clicks
        document.addEventListener('click', (e) => {
          if (e.target.classList.contains('move-white') || e.target.classList.contains('move-black')) {
            api.showToast('Move navigation coming soon!', 'info');
          }
        });
      }
      
      function setupPeriodicUpdates() {
        // Refresh game state every 3 seconds
        const gameInterval = setInterval(async () => {
          if (document.visibilityState === 'visible' && gameData?.status === 'active') {
            try {
              const response = await api.getGameDetail(gameId);
              if (response.ok && response.data.moves.length !== gameData.moves.length) {
                gameData = response.data;
                updateGameDisplay();
                renderBoard();
              }
            } catch (error) {
              console.error('Failed to refresh game:', error);
            }
          }
        }, 3000);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
          clearInterval(gameInterval);
        });
      }
      
      function showBoardLoading(show) {
        const loadingEl = document.getElementById('boardLoading');
        if (!loadingEl) {
          console.warn('boardLoading element not found');
          return;
        }
        if (show) {
          loadingEl.classList.add('show');
        } else {
          loadingEl.classList.remove('show');
        }
      }
      
      function getStatusText(status) {
        const statusMap = {
          waiting: 'Waiting',
          active: 'Active',
          finished: 'Finished'
        };
        return statusMap[status] || status;
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initGamePage);
    } else {
      initGamePage();
    }
  </script>
</body>
</html>