<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game - Chess Platform</title>
  <link rel="stylesheet" href="../../styles/global.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Game-specific styles maintaining design consistency */
    .game-container {
      min-height: 100vh;
      background: 
        radial-gradient(ellipse at top left, rgba(118, 150, 86, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(240, 217, 181, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
      background-attachment: fixed;
      display: flex;
      flex-direction: column;
    }

    /* Game Header */
    .game-header {
      height: var(--header-height);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--space-xl);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .game-title {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .game-id {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
    }

    .game-status-badge {
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
    }

    .status-active {
      background: rgba(34, 197, 94, 0.2);
      color: var(--color-success);
    }

    .status-waiting {
      background: rgba(251, 191, 36, 0.2);
      color: var(--color-warning);
    }

    .status-finished {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .game-actions {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }

    .back-btn {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: var(--font-size-sm);
      transition: all var(--transition-normal);
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-accent-primary);
      transform: translateX(-2px);
    }

    /* Game Content */
    .game-content {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr auto 320px;
      gap: var(--space-xl);
      padding: var(--space-xl);
      align-items: start;
    }

    /* Player Info */
    .players-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .player-card {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-lg);
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      transition: all var(--transition-normal);
    }

    .player-card.current-turn {
      border-color: var(--color-accent-primary);
      box-shadow: 0 0 0 1px rgba(118, 150, 86, 0.2), var(--shadow-md);
      background: rgba(118, 150, 86, 0.03);
    }

    .player-card.black {
      order: -1; /* Black player on top */
    }

    .player-avatar {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--color-accent-primary) 0%, var(--color-accent-light) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-inverse);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
      position: relative;
    }

    .player-avatar.black {
      background: linear-gradient(135deg, var(--color-bg-tertiary) 0%, #1f2937 100%);
      color: var(--color-text-primary);
    }

    .player-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .player-name {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
    }

    .player-rating {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .rating-badge {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
      font-weight: var(--font-weight-medium);
    }

    .player-timer {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      font-family: var(--font-family-mono);
      min-width: 80px;
      text-align: right;
    }

    .player-timer.low-time {
      color: var(--color-error);
      animation: pulse-timer 1s ease-in-out infinite;
    }

    @keyframes pulse-timer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .turn-indicator {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 12px;
      height: 12px;
      border-radius: var(--radius-full);
      background: var(--color-accent-primary);
      border: 2px solid var(--color-bg-primary);
      animation: pulse 2s ease-in-out infinite;
    }

    /* Chess Board */
    .board-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .chess-board {
      width: min(70vh, 600px);
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      border: 2px solid var(--glass-border);
      position: relative;
    }

    .chess-square {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      cursor: pointer;
      transition: all var(--transition-fast);
      user-select: none;
    }

    .chess-square.light {
      background-color: var(--color-board-light);
    }

    .chess-square.dark {
      background-color: var(--color-board-dark);
    }

    .chess-square:hover {
      background-color: rgba(118, 150, 86, 0.3) !important;
    }

    .chess-square.selected {
      background-color: rgba(255, 235, 59, 0.7) !important;
      box-shadow: inset 0 0 0 3px #ffd700;
    }

    .chess-square.possible-move {
      background-color: rgba(34, 197, 94, 0.3) !important;
    }

    .chess-square.possible-move::after {
      content: '';
      width: 30%;
      height: 30%;
      border-radius: var(--radius-full);
      background: rgba(34, 197, 94, 0.6);
    }

    .chess-square.possible-capture {
      background-color: rgba(239, 68, 68, 0.3) !important;
    }

    .chess-square.possible-capture::after {
      content: '';
      width: 100%;
      height: 100%;
      border: 3px solid rgba(239, 68, 68, 0.7);
      border-radius: var(--radius-sm);
      position: absolute;
      box-sizing: border-box;
    }

    .chess-square.last-move {
      background-color: rgba(59, 130, 246, 0.4) !important;
    }

    .chess-square.in-check {
      background-color: rgba(239, 68, 68, 0.5) !important;
      animation: check-flash 0.5s ease-in-out;
    }

    @keyframes check-flash {
      0%, 100% { background-color: rgba(239, 68, 68, 0.5) !important; }
      50% { background-color: rgba(239, 68, 68, 0.8) !important; }
    }

    .chess-piece {
      font-size: 2.5rem;
      user-select: none;
      pointer-events: none;
      transition: transform var(--transition-fast);
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
    }

    .chess-square:hover .chess-piece {
      transform: scale(1.05);
    }

    /* Coordinate Labels */
    .coord-label {
      position: absolute;
      font-size: 0.7rem;
      font-weight: var(--font-weight-medium);
      color: rgba(0, 0, 0, 0.6);
      pointer-events: none;
    }

    .coord-file {
      bottom: 2px;
      right: 4px;
    }

    .coord-rank {
      top: 2px;
      left: 4px;
    }

    /* Game Sidebar */
    .game-sidebar {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
      min-width: 320px;
    }

    .sidebar-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
    }

    .panel-header {
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: between;
      gap: var(--space-sm);
    }

    .panel-title {
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .panel-content {
      padding: var(--space-lg);
    }

    /* Game Controls */
    .game-controls {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .control-group {
      display: flex;
      gap: var(--space-sm);
    }

    .control-btn {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      transition: all var(--transition-normal);
      cursor: pointer;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--color-accent-primary);
      color: var(--color-accent-primary);
    }

    .control-btn.danger:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: var(--color-error);
      color: var(--color-error);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Move History */
    .move-history {
      max-height: 300px;
      overflow-y: auto;
      padding: var(--space-sm) 0;
    }

    .move-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .move-pair {
      display: grid;
      grid-template-columns: auto 1fr 1fr;
      gap: var(--space-sm);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-family: var(--font-family-mono);
      font-size: var(--font-size-sm);
      transition: background var(--transition-fast);
    }

    .move-pair:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .move-number {
      color: var(--color-text-muted);
      font-weight: var(--font-weight-medium);
      min-width: 20px;
    }

    .move-white,
    .move-black {
      color: var(--color-text-secondary);
      cursor: pointer;
      padding: 2px var(--space-xs);
      border-radius: var(--radius-xs);
      transition: all var(--transition-fast);
    }

    .move-white:hover,
    .move-black:hover {
      background: rgba(118, 150, 86, 0.2);
      color: var(--color-accent-primary);
    }

    .move-current {
      background: rgba(118, 150, 86, 0.3) !important;
      color: var(--color-accent-primary) !important;
    }

    /* Game Status */
    .game-status {
      text-align: center;
      padding: var(--space-lg);
    }

    .status-message {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }

    .status-details {
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
    }

    /* Captured Pieces */
    .captured-pieces {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
      justify-content: center;
    }

    .captured-piece {
      font-size: 1.2rem;
      opacity: 0.7;
      filter: grayscale(50%);
    }

    /* Promotion Dialog */
    .promotion-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .promotion-dialog.show {
      opacity: 1;
      visibility: visible;
    }

    .promotion-content {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-xl);
      text-align: center;
    }

    .promotion-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-lg);
    }

    .promotion-pieces {
      display: flex;
      gap: var(--space-md);
      justify-content: center;
    }

    .promotion-piece {
      width: 60px;
      height: 60px;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      transition: all var(--transition-normal);
    }

    .promotion-piece:hover {
      background: rgba(118, 150, 86, 0.2);
      border-color: var(--color-accent-primary);
      transform: scale(1.1);
    }

    /* Loading States */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-lg);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
    }

    .loading-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(118, 150, 86, 0.2);
      border-top: 3px solid var(--color-accent-primary);
      border-radius: var(--radius-full);
      animation: spin 1s linear infinite;
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .game-content {
        grid-template-columns: 1fr;
        gap: var(--space-lg);
      }

      .players-section {
        order: -1;
        flex-direction: row;
        justify-content: space-between;
      }

      .player-card.black {
        order: 0;
      }

      .game-sidebar {
        min-width: auto;
      }
    }

    @media (max-width: 768px) {
      .game-content {
        padding: var(--space-lg);
      }

      .chess-board {
        width: min(90vw, 90vh);
      }

      .chess-piece {
        font-size: 2rem;
      }

      .players-section {
        flex-direction: column;
        gap: var(--space-sm);
      }

      .player-card {
        padding: var(--space-md);
      }

      .player-avatar {
        width: 40px;
        height: 40px;
        font-size: var(--font-size-base);
      }

      .player-timer {
        font-size: var(--font-size-lg);
      }
    }

    @media (max-width: 480px) {
      .game-header {
        padding: 0 var(--space-lg);
      }

      .game-content {
        padding: var(--space-md);
      }

      .chess-piece {
        font-size: 1.5rem;
      }

      .panel-content {
        padding: var(--space-md);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="game-container fade-in">
      <!-- Game Header -->
      <header class="game-header">
        <div class="game-title">
          <span class="game-id" id="gameId">Game #---</span>
          <div class="game-status-badge" id="gameStatus">Loading...</div>
        </div>
        
        <div class="game-actions">
          <a href="#" class="back-btn" data-route="/lobby">
            <span>←</span>
            <span>Back to Lobby</span>
          </a>
        </div>
      </header>

      <!-- Game Content -->
      <div class="game-content">
        <!-- Player Info -->
        <div class="players-section">
          <div class="player-card white" id="whitePlayer">
            <div class="player-avatar">
              <span id="whiteAvatar">?</span>
            </div>
            <div class="player-info">
              <div class="player-name" id="whiteName">Loading...</div>
              <div class="player-rating">
                Rating: <span class="rating-badge" id="whiteRating">----</span>
              </div>
            </div>
            <div class="player-timer" id="whiteTimer">∞</div>
          </div>

          <div class="player-card black" id="blackPlayer">
            <div class="player-avatar black">
              <span id="blackAvatar">?</span>
            </div>
            <div class="player-info">
              <div class="player-name" id="blackName">Waiting...</div>
              <div class="player-rating">
                Rating: <span class="rating-badge" id="blackRating">----</span>
              </div>
            </div>
            <div class="player-timer" id="blackTimer">∞</div>
          </div>
        </div>

        <!-- Chess Board -->
        <div class="board-container">
          <div class="chess-board" id="chessBoard">
            <!-- Board squares will be generated here -->
            <div class="loading-overlay" id="boardLoading">
              <div class="loading-spinner"></div>
            </div>
          </div>
        </div>

        <!-- Game Sidebar -->
        <div class="game-sidebar">
          <!-- Game Controls -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>⚙️</span>
                Game Controls
              </h3>
            </div>
            <div class="panel-content">
              <div class="game-controls">
                <div class="control-group">
                  <button class="control-btn" id="offerDrawBtn">
                    🤝 Offer Draw
                  </button>
                  <button class="control-btn danger" id="resignBtn">
                    🏳️ Resign
                  </button>
                </div>
                <div class="control-group">
                  <button class="control-btn" id="flipBoardBtn">
                    🔄 Flip Board
                  </button>
                  <button class="control-btn" id="analysisBtn">
                    📊 Analysis
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Move History -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>📜</span>
                Move History
              </h3>
            </div>
            <div class="panel-content">
              <div class="move-history" id="moveHistory">
                <div class="move-list" id="moveList">
                  <!-- Moves will be populated here -->
                  <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
                    No moves yet. Game starting...
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Game Status -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>📋</span>
                Game Info
              </h3>
            </div>
            <div class="panel-content">
              <div class="game-status">
                <div class="status-message" id="statusMessage">Game in progress</div>
                <div class="status-details" id="statusDetails">White to move</div>
              </div>
            </div>
          </div>

          <!-- Captured Pieces -->
          <div class="sidebar-panel">
            <div class="panel-header">
              <h3 class="panel-title">
                <span>🏴‍☠️</span>
                Captured Pieces
              </h3>
            </div>
            <div class="panel-content">
              <div class="captured-pieces" id="capturedPieces">
                <!-- Captured pieces will be shown here -->
                <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
                  No captures yet
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Promotion Dialog -->
      <div class="promotion-dialog" id="promotionDialog">
        <div class="promotion-content">
          <h3 class="promotion-title">Choose promotion piece:</h3>
          <div class="promotion-pieces">
            <div class="promotion-piece" data-piece="q">♕</div>
            <div class="promotion-piece" data-piece="r">♖</div>
            <div class="promotion-piece" data-piece="b">♗</div>
            <div class="promotion-piece" data-piece="n">♘</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game page controller
    function initGamePage() {
      let gameData = null;
      let selectedSquare = null;
      let possibleMoves = [];
      let gameId = null;
      let currentUser = null;
      let moveHistory = [];
      
      // Initialize game
      initializeGame();
      
      async function initializeGame() {
        try {
          // Get game ID from URL
          gameId = getGameIdFromUrl();
          if (!gameId) {
            api.showError('Invalid game URL');
            router.navigate('/lobby');
            return;
          }
          
          // Load current user
          await loadCurrentUser();
          
          // Load game data
          await loadGameData();
          
          // Set up event listeners
          setupEventListeners();
          
          // Start periodic updates
          setupPeriodicUpdates();
          
        } catch (error) {
          console.error('Failed to initialize game:', error);
          api.showError('Failed to load game');
        }
      }
      
      function getGameIdFromUrl() {
        const path = window.location.pathname;
        const matches = path.match(/\/game\/(\d+)/);
        return matches ? parseInt(matches[1]) : null;
      }
      
      async function loadCurrentUser() {
        try {
          const response = await api.getUserProfile();
          if (response.ok) {
            currentUser = response.data;
          }
        } catch (error) {
          console.error('Failed to load current user:', error);
        }
      }
      
      async function loadGameData() {
        try {
          showBoardLoading(true);
          const response = await api.getGameDetail(gameId);
          
          if (response.ok) {
            gameData = response.data;
            updateGameDisplay();
            renderBoard();
          } else {
            throw new Error(api.formatError(response));
          }
        } catch (error) {
          console.error('Failed to load game data:', error);
          api.showError('Failed to load game data');
        } finally {
          showBoardLoading(false);
        }
      }
      
      function updateGameDisplay() {
        if (!gameData) return;
        
        // Update game header
        document.getElementById('gameId').textContent = `Game #${gameData.id}`;
        const statusEl = document.getElementById('gameStatus');
        statusEl.textContent = getStatusText(gameData.status);
        statusEl.className = `game-status-badge status-${gameData.status}`;
        
        // Update player info
        updatePlayerInfo('white', gameData.white_player_username, gameData.white_player_rating);
        updatePlayerInfo('black', gameData.black_player_username, gameData.black_player_rating);
        
        // Update turn indicator
        updateTurnIndicator();
        
        // Update move history
        updateMoveHistory();
        
        // Update game status
        updateGameStatus();
      }
      
      function updatePlayerInfo(color, username, rating) {
        const nameEl = document.getElementById(`${color}Name`);
        const avatarEl = document.getElementById(`${color}Avatar`);
        const ratingEl = document.getElementById(`${color}Rating`);
        
        if (username) {
          nameEl.textContent = username;
          avatarEl.textContent = username.charAt(0).toUpperCase();
          ratingEl.textContent = rating || 1200;
        } else {
          nameEl.textContent = color === 'white' ? 'White Player' : 'Waiting...';
          avatarEl.textContent = '?';
          ratingEl.textContent = '----';
        }
      }
      
      function updateTurnIndicator() {
        const whiteCard = document.getElementById('whitePlayer');
        const blackCard = document.getElementById('blackPlayer');
        
        // Remove current turn indicators
        whiteCard.classList.remove('current-turn');
        blackCard.classList.remove('current-turn');
        whiteCard.querySelector('.turn-indicator')?.remove();
        blackCard.querySelector('.turn-indicator')?.remove();
        
        if (gameData.status === 'active') {
          const currentTurn = getCurrentTurn();
          const currentPlayerCard = document.getElementById(`${currentTurn}Player`);
          currentPlayerCard.classList.add('current-turn');
          
          // Add turn indicator dot
          const indicator = document.createElement('div');
          indicator.className = 'turn-indicator';
          currentPlayerCard.querySelector('.player-avatar').appendChild(indicator);
        }
      }
      
      function getCurrentTurn() {
        // Parse FEN to get current turn
        const fenParts = gameData.fen.split(' ');
        return fenParts[1] === 'w' ? 'white' : 'black';
      }
      
      function updateMoveHistory() {
        const moveListEl = document.getElementById('moveList');
        const moves = gameData.moves || [];
        
        if (moves.length === 0) {
          moveListEl.innerHTML = `
            <div style="text-align: center; color: var(--color-text-muted); font-size: var(--font-size-sm);">
              No moves yet. Game starting...
            </div>
          `;
          return;
        }
        
        let html = '';
        for (let i = 0; i < moves.length; i += 2) {
          const moveNumber = Math.floor(i / 2) + 1;
          const whiteMove = moves[i];
          const blackMove = moves[i + 1];
          
          html += `
            <div class="move-pair">
              <span class="move-number">${moveNumber}.</span>
              <span class="move-white" data-move-index="${i}">${whiteMove.notation}</span>
              <span class="move-black" data-move-index="${i + 1}">
                ${blackMove ? blackMove.notation : ''}
              </span>
            </div>
          `;
        }
        
        moveListEl.innerHTML = html;
        
        // Scroll to bottom
        const historyEl = document.getElementById('moveHistory');
        historyEl.scrollTop = historyEl.scrollHeight;
      }
      
      function updateGameStatus() {
        const statusMessageEl = document.getElementById('statusMessage');
        const statusDetailsEl = document.getElementById('statusDetails');
        
        if (gameData.status === 'waiting') {
          statusMessageEl.textContent = 'Waiting for opponent';
          statusDetailsEl.textContent = 'Game will start when black player joins';
        } else if (gameData.status === 'active') {
          const currentTurn = getCurrentTurn();
          statusMessageEl.textContent = 'Game in progress';
          statusDetailsEl.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)} to move`;
        } else if (gameData.status === 'finished') {
          if (gameData.winner) {
            const winnerColor = gameData.winner === gameData.white_player ? 'White' : 'Black';
            statusMessageEl.textContent = `${winnerColor} wins!`;
            statusDetailsEl.textContent = 'Game completed';
          } else {
            statusMessageEl.textContent = 'Game drawn';
            statusDetailsEl.textContent = 'Game ended in a draw';
          }
        }
      }
      
      function renderBoard() {
        const boardEl = document.getElementById('chessBoard');
        boardEl.innerHTML = '';
        
        // Create squares
        for (let rank = 8; rank >= 1; rank--) {
          for (let file = 1; file <= 8; file++) {
            const square = document.createElement('div');
            const fileChar = String.fromCharCode(96 + file); // a-h
            const squareName = fileChar + rank;
            
            square.className = `chess-square ${(rank + file) % 2 === 0 ? 'dark' : 'light'}`;
            square.dataset.square = squareName;
            
            // Add coordinate labels
            if (rank === 1) {
              const fileLabel = document.createElement('div');
              fileLabel.className = 'coord-label coord-file';
              fileLabel.textContent = fileChar;
              square.appendChild(fileLabel);
            }
            
            if (file === 1) {
              const rankLabel = document.createElement('div');
              rankLabel.className = 'coord-label coord-rank';
              rankLabel.textContent = rank;
              square.appendChild(rankLabel);
            }
            
            // Add piece if present
            const piece = getPieceAtSquare(squareName);
            if (piece) {
              const pieceEl = document.createElement('div');
              pieceEl.className = 'chess-piece';
              pieceEl.textContent = getPieceUnicode(piece);
              square.appendChild(pieceEl);
            }
            
            boardEl.appendChild(square);
          }
        }
        
        setupBoardEventListeners();
      }
      
      function getPieceAtSquare(squareName) {
        // Parse FEN to get piece at specific square
        const fenParts = gameData.fen.split(' ');
        const placement = fenParts[0];
        const ranks = placement.split('/');
        
        const file = squareName.charCodeAt(0) - 97; // a=0, b=1, etc.
        const rank = parseInt(squareName[1]) - 1; // 1-8 to 0-7
        const rankString = ranks[7 - rank]; // FEN ranks are from 8 to 1
        
        let currentFile = 0;
        for (const char of rankString) {
          if (/\d/.test(char)) {
            currentFile += parseInt(char);
          } else {
            if (currentFile === file) {
              return char;
            }
            currentFile++;
          }
        }
        
        return null;
      }
      
      function getPieceUnicode(piece) {
        const pieces = {
          'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
          'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };
        return pieces[piece] || '';
      }
      
      function setupBoardEventListeners() {
        const squares = document.querySelectorAll('.chess-square');
        
        squares.forEach(square => {
          square.addEventListener('click', handleSquareClick);
        });
      }
      
      async function handleSquareClick(event) {
        const square = event.currentTarget;
        const squareName = square.dataset.square;
        
        // Check if it's the player's turn
        if (!isPlayerTurn()) {
          api.showToast("It's not your turn!", 'info');
          return;
        }
        
        if (!selectedSquare) {
          // First click - select piece
          const piece = getPieceAtSquare(squareName);
          if (piece && isOwnPiece(piece)) {
            selectSquare(squareName);
            highlightPossibleMoves(squareName);
          }
        } else {
          // Second click - make move or select different piece
          if (squareName === selectedSquare) {
            // Deselect
            clearSelection();
          } else if (isPossibleMove(squareName)) {
            // Make move
            await makeMove(selectedSquare, squareName);
          } else {
            // Select different piece
            const piece = getPieceAtSquare(squareName);
            if (piece && isOwnPiece(piece)) {
              clearSelection();
              selectSquare(squareName);
              highlightPossibleMoves(squareName);
            } else {
              clearSelection();
            }
          }
        }
      }
      
      function isPlayerTurn() {
        if (!gameData || gameData.status !== 'active') return false;
        
        const currentTurn = getCurrentTurn();
        const isWhitePlayer = currentUser && currentUser.id === gameData.white_player;
        const isBlackPlayer = currentUser && currentUser.id === gameData.black_player;
        
        return (currentTurn === 'white' && isWhitePlayer) || 
               (currentTurn === 'black' && isBlackPlayer);
      }
      
      function isOwnPiece(piece) {
        if (!currentUser) return false;
        
        const isWhitePlayer = currentUser.id === gameData.white_player;
        const isWhitePiece = piece === piece.toUpperCase();
        
        return (isWhitePlayer && isWhitePiece) || (!isWhitePlayer && !isWhitePiece);
      }
      
      function selectSquare(squareName) {
        selectedSquare = squareName;
        const square = document.querySelector(`[data-square="${squareName}"]`);
        square.classList.add('selected');
      }
      
      function clearSelection() {
        if (selectedSquare) {
          const square = document.querySelector(`[data-square="${selectedSquare}"]`);
          square?.classList.remove('selected');
          selectedSquare = null;
        }
        
        // Clear all move highlights
        document.querySelectorAll('.possible-move, .possible-capture').forEach(square => {
          square.classList.remove('possible-move', 'possible-capture');
        });
        possibleMoves = [];
      }
      
      function highlightPossibleMoves(squareName) {
        // For now, we'll implement basic move highlighting
        // In a full implementation, you'd calculate legal moves
        possibleMoves = calculatePossibleMoves(squareName);
        
        possibleMoves.forEach(move => {
          const square = document.querySelector(`[data-square="${move.to}"]`);
          if (square) {
            square.classList.add(move.capture ? 'possible-capture' : 'possible-move');
          }
        });
      }
      
      function calculatePossibleMoves(squareName) {
        // Simplified move calculation - replace with proper chess logic
        const moves = [];
        const piece = getPieceAtSquare(squareName);
        
        if (!piece) return moves;
        
        // This is a placeholder - implement proper chess move generation
        const file = squareName.charCodeAt(0) - 97;
        const rank = parseInt(squareName[1]) - 1;
        
        // Example: pawn moves
        if (piece.toLowerCase() === 'p') {
          const direction = piece === 'P' ? 1 : -1;
          const newRank = rank + direction;
          
          if (newRank >= 0 && newRank < 8) {
            const newSquare = String.fromCharCode(97 + file) + (newRank + 1);
            if (!getPieceAtSquare(newSquare)) {
              moves.push({ to: newSquare, capture: false });
            }
          }
        }
        
        return moves;
      }
      
      function isPossibleMove(squareName) {
        return possibleMoves.some(move => move.to === squareName);
      }
      
      async function makeMove(from, to) {
        try {
          clearSelection();
          showBoardLoading(true);
          
          // Check if move requires promotion
          const piece = getPieceAtSquare(from);
          const isPromotion = piece && piece.toLowerCase() === 'p' && 
                             (to[1] === '8' || to[1] === '1');
          
          let promotion = null;
          if (isPromotion) {
            promotion = await showPromotionDialog();
            if (!promotion) {
              showBoardLoading(false);
              return;
            }
          }
          
          const response = await api.makeMove(gameId, from, to, promotion);
          
          if (response.ok) {
            gameData = response.data.game;
            updateGameDisplay();
            renderBoard();
            api.showSuccess('Move made successfully!');
          } else {
            api.showError(api.formatError(response));
          }
        } catch (error) {
          console.error('Move error:', error);
          api.showError('Failed to make move');
        } finally {
          showBoardLoading(false);
        }
      }
      
      function showPromotionDialog() {
        return new Promise((resolve) => {
          const dialog = document.getElementById('promotionDialog');
          dialog.classList.add('show');
          
          const pieces = dialog.querySelectorAll('.promotion-piece');
          pieces.forEach(piece => {
            piece.onclick = () => {
              dialog.classList.remove('show');
              resolve(piece.dataset.piece);
            };
          });
        });
      }
      
      function setupEventListeners() {
        // Back button
        document.querySelector('.back-btn').addEventListener('click', (e) => {
          e.preventDefault();
          router.navigate('/lobby');
        });
        
        // Game controls
        document.getElementById('offerDrawBtn').addEventListener('click', () => {
          api.showToast('Draw offer feature coming soon!', 'info');
        });
        
        document.getElementById('resignBtn').addEventListener('click', () => {
          if (confirm('Are you sure you want to resign?')) {
            api.showToast('Resignation feature coming soon!', 'info');
          }
        });
        
        document.getElementById('flipBoardBtn').addEventListener('click', () => {
          api.showToast('Board flip feature coming soon!', 'info');
        });
        
        document.getElementById('analysisBtn').addEventListener('click', () => {
          api.showToast('Analysis feature coming soon!', 'info');
        });
        
        // Move history clicks
        document.addEventListener('click', (e) => {
          if (e.target.classList.contains('move-white') || e.target.classList.contains('move-black')) {
            api.showToast('Move navigation coming soon!', 'info');
          }
        });
      }
      
      function setupPeriodicUpdates() {
        // Refresh game state every 3 seconds
        const gameInterval = setInterval(async () => {
          if (document.visibilityState === 'visible' && gameData?.status === 'active') {
            try {
              const response = await api.getGameDetail(gameId);
              if (response.ok && response.data.moves.length !== gameData.moves.length) {
                gameData = response.data;
                updateGameDisplay();
                renderBoard();
              }
            } catch (error) {
              console.error('Failed to refresh game:', error);
            }
          }
        }, 3000);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
          clearInterval(gameInterval);
        });
      }
      
      function showBoardLoading(show) {
        const loadingEl = document.getElementById('boardLoading');
        if (show) {
          loadingEl.classList.add('show');
        } else {
          loadingEl.classList.remove('show');
        }
      }
      
      function getStatusText(status) {
        const statusMap = {
          waiting: 'Waiting',
          active: 'Active',
          finished: 'Finished'
        };
        return statusMap[status] || status;
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initGamePage);
    } else {
      initGamePage();
    }
  </script>
</body>
</html>